/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.21
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/*************************************************************** -*- c -*-
 * Tcl/precommon.swg
 *
 * Rename all exported symbols from common.swg, to avoid symbol
 * clashes if multiple interpreters are included
 *
 ************************************************************************/

#define SWIG_TypeRegister    SWIG_Tcl_TypeRegister
#define SWIG_TypeCheck       SWIG_Tcl_TypeCheck
#define SWIG_TypeCast        SWIG_Tcl_TypeCast
#define SWIG_TypeDynamicCast SWIG_Tcl_TypeDynamicCast
#define SWIG_TypeName        SWIG_Tcl_TypeName
#define SWIG_TypeQuery       SWIG_Tcl_TypeQuery
#define SWIG_TypeClientData  SWIG_Tcl_TypeClientData
#define SWIG_PackData        SWIG_Tcl_PackData 
#define SWIG_UnpackData      SWIG_Tcl_UnpackData 


/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  if defined(_MSC_VER) || defined(__GNUC__)
#    if defined(STATIC_LINKED)
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) extern a
#    else
#      define SWIGEXPORT(a) __declspec(dllexport) a
#      define SWIGIMPORT(a) extern a
#    endif
#  else
#    if defined(__BORLANDC__)
#      define SWIGEXPORT(a) a _export
#      define SWIGIMPORT(a) a _export
#    else
#      define SWIGEXPORT(a) a
#      define SWIGIMPORT(a) a
#    endif
#  endif
#else
#  define SWIGEXPORT(a) a
#  define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#  define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#  define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

  typedef void *(*swig_converter_func)(void *);
  typedef struct swig_type_info *(*swig_dycast_func)(void **);

  typedef struct swig_type_info {
    const char             *name;
    swig_converter_func     converter;
    const char             *str;
    void                   *clientdata;
    swig_dycast_func        dcast;
    struct swig_type_info  *next;
    struct swig_type_info  *prev;
  } swig_type_info;

#ifdef SWIG_NOINCLUDE

  SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
  SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
  SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
  SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
  SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
  SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
  SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);
  SWIGIMPORT(char *)           SWIG_PackData(char *, void *, int);
  SWIGIMPORT(char *)           SWIG_UnpackData(char *, void *, int);

#else

  static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
  SWIGRUNTIME(swig_type_info *)
    SWIG_TypeRegister(swig_type_info *ti) {
    swig_type_info *tc, *head, *ret, *next;
    /* Check to see if this type has already been registered */
    tc = swig_type_list;
    while (tc) {
      if (strcmp(tc->name, ti->name) == 0) {
        /* Already exists in the table.  Just add additional types to the list */
        if (tc->clientdata) ti->clientdata = tc->clientdata;
        head = tc;
        next = tc->next;
        goto l1;
      }
      tc = tc->prev;
    }
    head = ti;
    next = 0;

    /* Place in list */
    ti->prev = swig_type_list;
    swig_type_list = ti;

    /* Build linked lists */
    l1:
    ret = head;
    tc = ti + 1;
    /* Patch up the rest of the links */
    while (tc->name) {
      head->next = tc;
      tc->prev = head;
      head = tc;
      tc++;
    }
    if (next) next->prev = head;
    head->next = next;
    return ret;
  }

/* Check the typename */
  SWIGRUNTIME(swig_type_info *) 
    SWIG_TypeCheck(char *c, swig_type_info *ty) {
    swig_type_info *s;
    if (!ty) return 0;        /* Void pointer */
    s = ty->next;             /* First element always just a name */
    do {
      if (strcmp(s->name,c) == 0) {
        if (s == ty->next) return s;
        /* Move s to the top of the linked list */
        s->prev->next = s->next;
        if (s->next) {
          s->next->prev = s->prev;
        }
        /* Insert s as second element in the list */
        s->next = ty->next;
        if (ty->next) ty->next->prev = s;
        ty->next = s;
        s->prev = ty;
        return s;
      }
      s = s->next;
    } while (s && (s != ty->next));
    return 0;
  }

/* Cast a pointer up an inheritance hierarchy */
  SWIGRUNTIME(void *) 
    SWIG_TypeCast(swig_type_info *ty, void *ptr) {
    if ((!ty) || (!ty->converter)) return ptr;
    return (*ty->converter)(ptr);
  }

/* Set the clientdata field for a type */
  SWIGRUNTIME(void)
    SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
    swig_type_info *tc, *equiv;
    if (ti->clientdata == clientdata) return;
    ti->clientdata = clientdata;
    equiv = ti->next;
    while (equiv) {
      if (!equiv->converter) {
        tc = swig_type_list;
        while (tc) {
          if ((strcmp(tc->name, equiv->name) == 0))
            SWIG_TypeClientData(tc,clientdata);
          tc = tc->prev;
        }
      }
      equiv = equiv->next;
    }
  }

/* Pack binary data into a string */
  SWIGRUNTIME(char *)
    SWIG_PackData(char *c, void *ptr, int sz) {
    static char hex[17] = "0123456789abcdef";
    int i;
    unsigned char *u = (unsigned char *) ptr;
    register unsigned char uu;
    for (i = 0; i < sz; i++,u++) {
      uu = *u;
      *(c++) = hex[(uu & 0xf0) >> 4];
      *(c++) = hex[uu & 0xf];
    }
    return c;
  }

/* Unpack binary data from a string */
  SWIGRUNTIME(char *)
    SWIG_UnpackData(char *c, void *ptr, int sz) {
    register unsigned char uu = 0;
    register int d;
    unsigned char *u = (unsigned char *) ptr;
    int i;
    for (i = 0; i < sz; i++, u++) {
      d = *(c++);
      if ((d >= '0') && (d <= '9'))
        uu = ((d - '0') << 4);
      else if ((d >= 'a') && (d <= 'f'))
        uu = ((d - ('a'-10)) << 4);
      d = *(c++);
      if ((d >= '0') && (d <= '9'))
        uu |= (d - '0');
      else if ((d >= 'a') && (d <= 'f'))
        uu |= (d - ('a'-10));
      *u = uu;
    }
    return c;
  }

#endif

#ifdef __cplusplus
}
#endif

/*
 * $Header: /space/repo/1/dev/dev/fsgdf/fsgdf_wrap.c,v 1.16 2008/01/18 21:23:25 nicks Exp $
 * 
 * swigtcl8.swg
 */

#include <tcl.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Constant table */

#define SWIG_TCL_INT     1
#define SWIG_TCL_FLOAT   2
#define SWIG_TCL_STRING  3
#define SWIG_TCL_POINTER 4
#define SWIG_TCL_BINARY  5

/* Flags for pointer conversion */
#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Swig fail macro */

#define SWIG_fail   goto fail

/* Constant information structure */
  typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
  } swig_const_info;

  typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
  typedef void  (*swig_delete_func)(ClientData);

  typedef struct swig_method {
    const char     *name;
    swig_wrapper   method;
  } swig_method;

  typedef struct swig_attribute {
    const char     *name;
    swig_wrapper   getmethod;
    swig_wrapper   setmethod;
  } swig_attribute;

  typedef struct swig_class {
    const char         *name;
    swig_type_info   **type;
    swig_wrapper       constructor;
    void              (*destructor)(void *);
    swig_method        *methods;
    swig_attribute     *attributes;
    struct swig_class **bases;
  } swig_class;

  typedef struct swig_instance {
    Tcl_Obj       *thisptr;
    void          *thisvalue;
    swig_class   *classptr;
    int            destroy;
    Tcl_Command    cmdtok;
  } swig_instance;

#define SWIG_NewPointerObj(ptr, type, flags) \
  SWIG_Tcl_NewPointerObj(ptr, type, flags)
#define SWIG_ConvertPtr(oc, ptr, ty, flags) \
  SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
#define SWIG_ConvertPtrFromString(c, ptr, ty, flags) \
  SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)
#define SWIG_ConvertPacked(obj, ptr, sz, ty, flags) \
  SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty, flags)
#define SWIG_MakePtr(c, ptr, ty, flags) \
  SWIG_Tcl_MakePtr(c, ptr, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type, flags) \
  SWIG_Tcl_NewPackedObj(ptr, sz, type, flags)
#define SWIG_GetArgs SWIG_Tcl_GetArgs
#define SWIG_PointerTypeFromString(c) \
  SWIG_Tcl_PointerTypeFromString(c)
#define SWIG_Acquire(ptr) \
  SWIG_Tcl_Acquire(ptr)
#define SWIG_Disown(ptr) \
  SWIG_Tcl_Disown(ptr)
#define SWIG_Thisown(ptr) \
  SWIG_Tcl_Thisown(ptr)
#define SWIG_InstallConstants(interp, constants) \
  SWIG_Tcl_InstallConstants(interp, constants)
#define SWIG_GetConstant(key) \
  SWIG_Tcl_GetConstant(key)
#define SWIG_NewInstanceObj(thisvalue, type, flags) \
  SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)
#define SWIG_ObjectConstructor SWIG_Tcl_ObjectConstructor
#define SWIG_MethodCommand SWIG_Tcl_MethodCommand
#define SWIG_ObjectDelete SWIG_Tcl_ObjectDelete

#ifdef SWIG_NOINCLUDE

  SWIGIMPORT(int)       SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *, char *, void **, swig_type_info *,int flags);
  SWIGIMPORT(int)       SWIG_Tcl_ConvertPtr(Tcl_Interp *, Tcl_Obj *, void **, swig_type_info *, int flags);
  SWIGIMPORT(int)       SWIG_Tcl_ConvertPacked(Tcl_Interp *, Tcl_Obj *, void *, int sz, swig_type_info *, int flags);
  SWIGIMPORT(void)      SWIG_Tcl_MakePtr(char *, void *, swig_type_info *, int flags);
  SWIGIMPORT(Tcl_Obj *) SWIG_Tcl_NewPointerObj(void *, swig_type_info *, int flags);
  SWIGIMPORT(Tcl_Obj *) SWIG_Tcl_NewPackedObj(void *, int sz, swig_type_info *, int flags);
  SWIGIMPORT(int)       SWIG_Tcl_GetArgs(Tcl_Interp *, int, Tcl_Obj *CONST [], const char *, ...);
  SWIGIMPORT(char *)    SWIG_Tcl_PointerTypeFromString(char *c);
  SWIGIMPORT(void)      SWIG_Tcl_Acquire(void *ptr);
  SWIGIMPORT(int)       SWIG_Tcl_Disown(void *ptr);
  SWIGIMPORT(int)       SWIG_Tcl_Thisown(void *ptr);
  SWIGIMPORT(void)      SWIG_Tcl_InstallConstants(Tcl_Interp *interp, struct swig_const_info constants[]);
  SWIGIMPORT(Tcl_Obj *) SWIG_Tcl_GetConstant(const char *key);
  SWIGIMPORT(Tcl_Obj *) SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *, swig_type_info *, int flags);
  SWIGIMPORT(int)       SWIG_Tcl_ObjectConstructor(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST objv[]);
  SWIGIMPORT(int)       SWIG_Tcl_MethodCommand(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST objv[]);
  SWIGIMPORT(void)      SWIG_Tcl_ObjectDelete(ClientData);

#else

/* Object support */
  static Tcl_HashTable  swigobjectTable;
  static int            swigobjectTableinit = 0;

/* Acquire ownership of a pointer */
  SWIGRUNTIME(void)
    SWIG_Tcl_Acquire(void *ptr) {
    Tcl_HashEntry *entryPtr;
    int newobj;
    if (!swigobjectTableinit) {
      Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
      swigobjectTableinit = 1;
    }
    entryPtr = Tcl_CreateHashEntry(&swigobjectTable, (char *) ptr, &newobj);
  }

/* Disown a pointer.  Returns 1 if we owned it to begin with */
  SWIGRUNTIME(int)
    SWIG_Tcl_Disown(void *ptr) {
    Tcl_HashEntry *entryPtr;
    if (!swigobjectTableinit) return 0;
    entryPtr = Tcl_FindHashEntry(&swigobjectTable, (char *) ptr);
    if (entryPtr) {
      Tcl_DeleteHashEntry(entryPtr);
      return 1;
    }
    return 0;
  }

  SWIGRUNTIME(int)
    SWIG_Tcl_Thisown(void *ptr) {
    if (!swigobjectTableinit) return 0;
    if (Tcl_FindHashEntry(&swigobjectTable, (char *) ptr)) {
      return 1;
    }
    return 0;
  }

/* Convert a pointer value */
  SWIGRUNTIME(int)
    SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, char *c, void **ptr, swig_type_info *ty, int flags) {
    swig_type_info *tc;
    /* Pointer values must start with leading underscore */
    while (*c != '_') {
      *ptr = (void *) 0;
      if (strcmp(c,"NULL") == 0) return TCL_OK;
      /* Hmmm. It could be an object name. */
      if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) == TCL_OK) {
        Tcl_Obj *result = Tcl_GetObjResult(interp);
        c = Tcl_GetStringFromObj(result, NULL);
        continue;
      }
      Tcl_ResetResult(interp);
      if (flags & SWIG_POINTER_EXCEPTION) 
        Tcl_SetResult(interp, (char *) "Type error. Expected a pointer", TCL_STATIC);
      return TCL_ERROR;
    }
    c++;
    c = SWIG_UnpackData(c,ptr,sizeof(void *));
    if (ty) {
      tc = SWIG_TypeCheck(c,ty);
      if ((!tc) && (flags & SWIG_POINTER_EXCEPTION)) {
        Tcl_SetResult(interp, (char *) "Type error. Expected ", TCL_STATIC);
        Tcl_AppendElement(interp, (char *) ty->name);
        return TCL_ERROR;
      } else if (!tc) {
        Tcl_ResetResult(interp);
        return TCL_ERROR;
      }
      if (flags & SWIG_POINTER_DISOWN) {
        SWIG_Disown((void *) *ptr);
      }
      *ptr = SWIG_TypeCast(tc,(void *) *ptr);
    }
    return TCL_OK;
  }

/* Convert a pointer value */
  SWIGRUNTIME(int)
    SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
    return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
  }

/* Take a pointer and convert it to a string */
  SWIGRUNTIME(void)
    SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int flags) {
    if (ptr) {
      *(c++) = '_';
      c = SWIG_PackData(c,&ptr,sizeof(void *));
      strcpy(c,ty->name);
    } else {
      strcpy(c,(char *)"NULL");
    }
    flags = 0;
  }

/* Create a new pointer object */
  SWIGRUNTIME(Tcl_Obj *)
    SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
    Tcl_Obj *robj;
    char result[512];
    SWIG_MakePtr(result,ptr,type,flags);
    robj = Tcl_NewStringObj(result,-1);
    return robj;
  }

  SWIGRUNTIME(Tcl_Obj *)
    SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type, int flags) {
    char result[1024];
    char *r = result;
    if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
    *(r++) = '_';
    r = SWIG_PackData(r,ptr,sz);
    strcpy(r,type->name);
    flags = 0;
    return Tcl_NewStringObj(result,-1);
  }

  static Tcl_HashTable   swigconstTable;
  static int             swigconstTableinit = 0;

/* Install Constants */
  SWIGRUNTIME(void)
    SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
    int i;
    Tcl_Obj *obj;
    Tcl_HashEntry *entryPtr;
    int            newobj;

    if (!swigconstTableinit) {
      Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
      swigconstTableinit = 1;
    }
    for (i = 0; constants[i].type; i++) {
      switch(constants[i].type) {
      case SWIG_TCL_INT:
        obj = Tcl_NewIntObj(constants[i].lvalue);
        break;
      case SWIG_TCL_FLOAT:
        obj = Tcl_NewDoubleObj(constants[i].dvalue);
        break;
      case SWIG_TCL_STRING:
        obj = Tcl_NewStringObj((char *) constants[i].pvalue,-1);
        break;
      case SWIG_TCL_POINTER:
        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_TCL_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype),0);
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        Tcl_ObjSetVar2(interp,Tcl_NewStringObj(constants[i].name,-1), NULL, obj, TCL_GLOBAL_ONLY);
        entryPtr = Tcl_CreateHashEntry(&swigconstTable, constants[i].name, &newobj);
        Tcl_SetHashValue(entryPtr, (ClientData) obj);
      }
    }
  }

  SWIGRUNTIME(Tcl_Obj *)
    SWIG_Tcl_GetConstant(const char *key) {
    Tcl_HashEntry *entryPtr;
    if (!swigconstTableinit) return 0;
    entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
    if (entryPtr) {
      return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
    }
    printf("Searching %s\n", key);
    return 0;
  }

/* Get arguments */
  SWIGRUNTIME(int)
    SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
    int        argno = 0, opt = 0;
    long       tempi;
    double     tempd;
    const char *c;
    va_list    ap;
    void      *vptr;
    Tcl_Obj   *obj = 0;
    swig_type_info *ty;

    va_start(ap,fmt);
    for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
      if (*c == '|') {
        opt = 1;
        c++;
      }
      if (argno >= (objc-1)) {
        if (!opt) {
          Tcl_SetResult(interp, (char *) "Wrong # args. ", TCL_STATIC);
          goto argerror;
        } else {
          va_end(ap);
          return TCL_OK;
        }
      }

      vptr = va_arg(ap,void *);
      if (vptr) {
        if (isupper(*c)) {
          obj = SWIG_GetConstant(Tcl_GetStringFromObj(objv[argno+1],0));
          if (!obj) obj = objv[argno+1];
        } else {
          obj = objv[argno+1];
        }
        switch(*c) {
        case 'i': case 'I':
        case 'l': case 'L':
        case 'h': case 'H':
        case 'b': case 'B':
          if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
          if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
          else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
          else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
          else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
          break;
        case 'f': case 'F':
        case 'd': case 'D':
          if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
          if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
          else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
          break;
        case 's': case 'S':
          if (*(c+1) == '#') {
            int *vlptr = (int *) va_arg(ap, void *);
            *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
            c++;
          } else {
            *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
          }
          break;
        case 'c': case 'C':
          *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
          break;
        case 'p': case 'P':
          ty = (swig_type_info *) va_arg(ap, void *);
          if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, SWIG_POINTER_EXCEPTION) == TCL_ERROR) goto argerror;
          break;
        case 'o': case 'O':
          *((Tcl_Obj **)vptr) = objv[argno+1];
          break;
        default:
          break;
        }
      }
    }

    if ((*c != ';') && ((objc-1) > argno)) {
      Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
      goto argerror;
    }
    va_end(ap);
    return TCL_OK;

    argerror:
    {
      char temp[32];
      sprintf(temp,"%d", argno+1);
      c = strchr(fmt,':');
      if (!c) c = strchr(fmt,';');
      if (!c) c = (char *)"";
      Tcl_AppendResult(interp,c," argument ", temp, NULL);
      va_end(ap);
      return TCL_ERROR;
    }
  }

  SWIGRUNTIME(void)
    SWIG_Tcl_ObjectDelete(ClientData clientData) {
    swig_instance *si = (swig_instance *) clientData;
    if ((si) && (si->destroy) && (SWIG_Disown(si->thisvalue))) {
      if (si->classptr->destructor) {
        (si->classptr->destructor)(si->thisvalue);
      }
    }
    Tcl_DecrRefCount(si->thisptr);
    free(si);
  }

/* Function to invoke object methods given an instance */
  SWIGRUNTIME(int)
    SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
    char *method,   *attrname;
    swig_instance   *inst = (swig_instance *) clientData;
    swig_method     *meth;
    swig_attribute  *attr;
    Tcl_Obj         *oldarg;
    Tcl_Obj         **objv;
    int              rcode;
    swig_class      *cls;
    swig_class      *cls_stack[64];
    int              cls_stack_bi[64];
    int              cls_stack_top = 0;
    int              numconf = 2;
    int              bi;

    objv = (Tcl_Obj **) _objv;
    if (objc < 2) {
      Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
    method = Tcl_GetStringFromObj(objv[1],NULL);
    if (strcmp(method,"-acquire") == 0) {
      inst->destroy = 1;
      SWIG_Acquire(inst->thisvalue);
      return TCL_OK;
    }
    if (strcmp(method,"-disown") == 0) {
      if (inst->destroy) {
        SWIG_Disown(inst->thisvalue);
      }
      inst->destroy = 0;
      return TCL_OK;
    }
    if (strcmp(method,"-delete") == 0) {
      Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
      return TCL_OK;
    }
    cls_stack[cls_stack_top] = inst->classptr;
    cls_stack_bi[cls_stack_top] = -1;
    cls = inst->classptr;
    while (1) {
      bi = cls_stack_bi[cls_stack_top];
      cls = cls_stack[cls_stack_top];
      if (bi != -1) {
        cls = cls->bases[bi];
        if (cls) {
          cls_stack_bi[cls_stack_top]++;
          cls_stack_top++;
          cls_stack[cls_stack_top] = cls;
          cls_stack_bi[cls_stack_top] = -1;
          continue;
        }
      }
      if (!cls) {
        cls_stack_top--;
        if (cls_stack_top < 0) break;
        else continue;
      }
      cls_stack_bi[cls_stack_top]++;

      meth = cls->methods;
      /* Check for methods */
      while (meth && meth->name) {
        if (strcmp(meth->name,method) == 0) {
          oldarg = objv[1];
          objv[1] = inst->thisptr;
          Tcl_IncrRefCount(inst->thisptr);
          rcode = (*meth->method)(clientData,interp,objc,objv);
          objv[1] = oldarg;
          Tcl_DecrRefCount(inst->thisptr);
          return rcode;
        }
        meth++;
      }
      /* Check class methods for a match */
      if (strcmp(method,"cget") == 0) {
        if (objc < 3) {
          Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
          return TCL_ERROR;
        }
        attrname = Tcl_GetStringFromObj(objv[2],NULL);
        attr = cls->attributes;
        while (attr && attr->name) {
          if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
            oldarg = objv[1];
            objv[1] = inst->thisptr;
            Tcl_IncrRefCount(inst->thisptr);
            rcode = (*attr->getmethod)(clientData,interp,2, objv);
            objv[1] = oldarg;
            Tcl_DecrRefCount(inst->thisptr);
            return rcode;
          }
          attr++;
        }
        if (strcmp(attrname, "-this") == 0) {
          Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
          return TCL_OK;
        }
        if (strcmp(attrname, "-thisown") == 0) {
          if (SWIG_Thisown(inst->thisvalue)) {
            Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
          } else {
            Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
          }
          return TCL_OK;
        }
      } else if (strcmp(method, "configure") == 0) {
        int i;
        if (objc < 4) {
          Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
          return TCL_ERROR;
        }
        i = 2;
        while (i < objc) {
          attrname = Tcl_GetStringFromObj(objv[i],NULL);
          attr = cls->attributes;
          while (attr && attr->name) {
            if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
              oldarg = objv[i];
              objv[i] = inst->thisptr;
              Tcl_IncrRefCount(inst->thisptr);
              rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
              objv[i] = oldarg;
              Tcl_DecrRefCount(inst->thisptr);
              if (rcode != TCL_OK) return rcode;
              numconf += 2;
            }
            attr++;
          }
          i+=2;
        }
      }
    }
    if (strcmp(method,"configure") == 0) {
      if (numconf >= objc) {
        return TCL_OK;
      } else {
        Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
        return TCL_ERROR;
      }
    }
    if (strcmp(method,"cget") == 0) {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
    }

    Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
    cls = inst->classptr;
    bi = 0;
    while (cls) {
      meth = cls->methods;
      while (meth && meth->name) {
        char *cr = (char *) Tcl_GetStringResult(interp);
        if (!strstr(strchr(cr,':'), meth->name))
          Tcl_AppendElement(interp, (char *) meth->name);
        meth++;
      }
      cls = inst->classptr->bases[bi++];
    }
    return TCL_ERROR;
  }

/* This function takes the current result and turns it into an object command */
  SWIGRUNTIME(Tcl_Obj *)
    SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
    Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
    /* Check to see if this pointer belongs to a class or not */
    if ((type->clientdata) && (interp)) {
      Tcl_CmdInfo    ci;
      char          *name;
      name = Tcl_GetStringFromObj(robj,NULL);
      if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
        swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
        newinst->thisptr = Tcl_DuplicateObj(robj);
        Tcl_IncrRefCount(newinst->thisptr);
        newinst->thisvalue = thisvalue;
        newinst->classptr = (swig_class *) type->clientdata;
        newinst->destroy = flags;
        newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
        if (flags) {
          SWIG_Acquire(thisvalue);
        }
      }
    }
    return robj;
  }

#endif

/* Structure for command table */
  typedef struct {
    const char *name;
    int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
    ClientData  clientdata;
  } swig_command_info;

/* Structure for variable linking table */
  typedef struct {
    const char *name;
    void *addr;
    char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
    char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
  } swig_var_info;


/* Contract support */

#define SWIG_contract_assert(expr, msg)  if (!(expr)) { Tcl_SetResult(interp, (char *) msg, TCL_STATIC ); goto fail; } else

#ifdef __cplusplus
}
#endif






/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_float swig_types[0] 
#define  SWIGTYPE_p_FSGD swig_types[1] 
#define  SWIGTYPE_p_int swig_types[2] 
static swig_type_info *swig_types[4];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Fsgdf_Init
#define SWIG_name    "fsgdf"
#define SWIG_prefix  ""
#define SWIG_version "0.0"


#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
  SWIGEXPORT(int) SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif



#include "fsgdf.h"

extern FSGD *gdfRead(char *,int);
extern int gdfPrintStdout(FSGD *);
extern int gdfGetTitle(FSGD *,char *);
extern int gdfGetMeasurementName(FSGD *,char *);
extern int gdfGetSubjectName(FSGD *,char *);
extern int gdfGetDataFileName(FSGD *,char *);
extern int gdfGetNumClasses(FSGD *,int *);
extern int gdfGetNthClassLabel(FSGD *,int,char *);
extern int gdfGetNthClassMarker(FSGD *,int,char *);
extern int gdfGetNthClassColor(FSGD *,int,char *);
extern int gdfGetNumVariables(FSGD *,int *);
extern int gdfGetNthVariableLabel(FSGD *,int,char *);
extern int gdfGetDefaultVariable(FSGD *,char *);
extern int gdfGetDefaultVariableIndex(FSGD *,int *);
extern int gdfGetNumSubjects(FSGD *,int *);
extern int gdfGetNthSubjectID(FSGD *,int,char *);
extern int gdfGetNthSubjectClass(FSGD *,int,int *);
extern int gdfGetNthSubjectNthValue(FSGD *,int,int,float *);
extern int gdfGetNthSubjectMeasurement(FSGD *,int,int,int,int,float *);
extern int gdfOffsetSlope(FSGD *,int,int,int,int,int,float *,float *);
#ifdef __cplusplus
extern "C" {
#endif
  static int
  _wrap_gdfRead(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    char *arg1 ;
    int arg2 ;
    FSGD *result;
    
    if (SWIG_GetArgs(interp, objc, objv,"si:gdfRead gdfname loaddata ",&arg1,&arg2) == TCL_ERROR) SWIG_fail;
    result = (FSGD *)gdfRead(arg1,arg2);
    
    Tcl_SetObjResult(interp,SWIG_NewInstanceObj((void *) result, SWIGTYPE_p_FSGD,0));
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfPrintStdout(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"o:gdfPrintStdout gd ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfPrintStdout(arg1);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetTitle(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    char *arg2 = (char*)calloc(2048,sizeof(char));
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:gdfGetTitle gd OUTSTRING ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg2 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetTitle(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg2);
      Tcl_Obj *o = Tcl_NewStringObj(arg2,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg2);
    }
    return TCL_OK;
  fail:
    {
      free(arg2);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetMeasurementName(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    char *arg2 = (char*)calloc(2048,sizeof(char));
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:gdfGetMeasurementName gd OUTSTRING ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg2 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetMeasurementName(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg2);
      Tcl_Obj *o = Tcl_NewStringObj(arg2,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg2);
    }
    return TCL_OK;
  fail:
    {
      free(arg2);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetSubjectName(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    char *arg2 ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"os:gdfGetSubjectName gd OUSTRING ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetSubjectName(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetDataFileName(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    char *arg2 = (char*)calloc(2048,sizeof(char)) ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:gdfGetDataFileName gd OUTSTRING ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg2 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetDataFileName(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg2);
      Tcl_Obj *o = Tcl_NewStringObj(arg2,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg2);
    }
    return TCL_OK;
  fail:
    {
      free(arg2);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNumClasses(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int *arg2 = (int *) 0 ;
    int result;
    int temp2 ;
    
    arg2 = &temp2;
    if (SWIG_GetArgs(interp, objc, objv,"o:gdfGetNumClasses gd ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetNumClasses(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewIntObj((int) *(arg2));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthClassLabel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    char *arg3 = (char*)calloc(2048,sizeof(char)) ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oio:gdfGetNthClassLabel gd nclass OUTSTRING ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg3 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetNthClassLabel(arg1,arg2,arg3);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg3);
      Tcl_Obj *o = Tcl_NewStringObj(arg3,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg3);
    }
    return TCL_OK;
  fail:
    {
      free(arg3);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthClassMarker(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    char *arg3 = (char*)calloc(2048,sizeof(char)) ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oio:gdfGetNthClassMarker gd nclass OUTSTRING ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg3 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetNthClassMarker(arg1,arg2,arg3);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg3);
      Tcl_Obj *o = Tcl_NewStringObj(arg3,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg3);
    }
    return TCL_OK;
  fail:
    {
      free(arg3);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthClassColor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    char *arg3 = (char*)calloc(2048,sizeof(char)) ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oio:gdfGetNthClassColor gd nclass OUTSTRING ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg3 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetNthClassColor(arg1,arg2,arg3);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg3);
      Tcl_Obj *o = Tcl_NewStringObj(arg3,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg3);
    }
    return TCL_OK;
  fail:
    {
      free(arg3);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNumVariables(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int *arg2 = (int *) 0 ;
    int result;
    int temp2 ;
    
    arg2 = &temp2;
    if (SWIG_GetArgs(interp, objc, objv,"o:gdfGetNumVariables gd ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetNumVariables(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewIntObj((int) *(arg2));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthVariableLabel(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    char *arg3 = (char*)calloc(2048,sizeof(char)) ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oio:gdfGetNthVariableLabel gd nvariable OUTSTRING ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg3 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetNthVariableLabel(arg1,arg2,arg3);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg3);
      Tcl_Obj *o = Tcl_NewStringObj(arg3,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg3);
    }
    return TCL_OK;
  fail:
    {
      free(arg3);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetDefaultVariable(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    char *arg2 = (char*)calloc(2048,sizeof(char)) ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oo:gdfGetDefaultVariable gd OUTSTRING ",0,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg2 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetDefaultVariable(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg2);
      Tcl_Obj *o = Tcl_NewStringObj(arg2,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg2);
    }
    return TCL_OK;
  fail:
    {
      free(arg2);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetDefaultVariableIndex(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int *arg2 = (int *) 0 ;
    int result;
    int temp2 ;
    
    arg2 = &temp2;
    if (SWIG_GetArgs(interp, objc, objv,"o:gdfGetDefaultVariableIndex gd ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetDefaultVariableIndex(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewIntObj((int) *(arg2));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNumSubjects(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int *arg2 = (int *) 0 ;
    int result;
    int temp2 ;
    
    arg2 = &temp2;
    if (SWIG_GetArgs(interp, objc, objv,"o:gdfGetNumSubjects gd ",0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetNumSubjects(arg1,arg2);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewIntObj((int) *(arg2));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthSubjectID(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    char *arg3 = (char*)calloc(2048,sizeof(char)) ;
    int result;
    
    if (SWIG_GetArgs(interp, objc, objv,"oio:gdfGetNthSubjectID gd nsubject OUTSTRING ",0,&arg2,0) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    {
      arg3 = (char*)calloc(2048,sizeof(char));
    }
    result = (int)gdfGetNthSubjectID(arg1,arg2,arg3);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      int len = strlen(arg3);
      Tcl_Obj *o = Tcl_NewStringObj(arg3,len);
      Tcl_ListObjAppendElement(interp,(Tcl_GetObjResult(interp)),o);
    }
    {
      free(arg3);
    }
    return TCL_OK;
  fail:
    {
      free(arg3);
    }
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthSubjectClass(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    int *arg3 = (int *) 0 ;
    int result;
    int temp3 ;
    
    arg3 = &temp3;
    if (SWIG_GetArgs(interp, objc, objv,"oi:gdfGetNthSubjectClass gd nsubject ",0,&arg2) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetNthSubjectClass(arg1,arg2,arg3);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewIntObj((int) *(arg3));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthSubjectNthValue(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    int arg3 ;
    float *arg4 = (float *) 0 ;
    int result;
    float temp4 ;
    
    arg4 = &temp4;
    if (SWIG_GetArgs(interp, objc, objv,"oii:gdfGetNthSubjectNthValue gd nsubject nvariable ",0,&arg2,&arg3) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetNthSubjectNthValue(arg1,arg2,arg3,arg4);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewDoubleObj((double) *(arg4));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfGetNthSubjectMeasurement(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    int arg5 ;
    float *arg6 = (float *) 0 ;
    int result;
    float temp6 ;
    
    arg6 = &temp6;
    if (SWIG_GetArgs(interp, objc, objv,"oiiii:gdfGetNthSubjectMeasurement gd nsubject x y z ",0,&arg2,&arg3,&arg4,&arg5) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfGetNthSubjectMeasurement(arg1,arg2,arg3,arg4,arg5,arg6);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewDoubleObj((double) *(arg6));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }


  static int
  _wrap_gdfOffsetSlope(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    FSGD *arg1 = (FSGD *) 0 ;
    int arg2 ;
    int arg3 ;
    int arg4 ;
    int arg5 ;
    int arg6 ;
    float *arg7 = (float *) 0 ;
    float *arg8 = (float *) 0 ;
    int result;
    float temp7 ;
    float temp8 ;
    
    arg7 = &temp7;
    arg8 = &temp8;
    if (SWIG_GetArgs(interp, objc, objv,"oiiiii:gdfOffsetSlope gd nclass nvar x y z ",0,&arg2,&arg3,&arg4,&arg5,&arg6) == TCL_ERROR) SWIG_fail;
    if ((SWIG_ConvertPtr(objv[1], (void **) &arg1, SWIGTYPE_p_FSGD,SWIG_POINTER_EXCEPTION | 0) != TCL_OK)) SWIG_fail;
    result = (int)gdfOffsetSlope(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    Tcl_SetObjResult(interp,Tcl_NewIntObj((long) result));
    {
      Tcl_Obj *o;
      o = Tcl_NewDoubleObj((double) *(arg7));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    {
      Tcl_Obj *o;
      o = Tcl_NewDoubleObj((double) *(arg8));
      Tcl_ListObjAppendElement(interp,Tcl_GetObjResult(interp),o);
    }
    return TCL_OK;
  fail:
    return TCL_ERROR;
  }



  static swig_command_info swig_commands[] = {
    { SWIG_prefix "gdfRead", (swig_wrapper_func) _wrap_gdfRead, NULL},
    { SWIG_prefix "gdfPrintStdout", (swig_wrapper_func) _wrap_gdfPrintStdout, NULL},
    { SWIG_prefix "gdfGetTitle", (swig_wrapper_func) _wrap_gdfGetTitle, NULL},
    { SWIG_prefix "gdfGetMeasurementName", (swig_wrapper_func) _wrap_gdfGetMeasurementName, NULL},
    { SWIG_prefix "gdfGetSubjectName", (swig_wrapper_func) _wrap_gdfGetSubjectName, NULL},
    { SWIG_prefix "gdfGetDataFileName", (swig_wrapper_func) _wrap_gdfGetDataFileName, NULL},
    { SWIG_prefix "gdfGetNumClasses", (swig_wrapper_func) _wrap_gdfGetNumClasses, NULL},
    { SWIG_prefix "gdfGetNthClassLabel", (swig_wrapper_func) _wrap_gdfGetNthClassLabel, NULL},
    { SWIG_prefix "gdfGetNthClassMarker", (swig_wrapper_func) _wrap_gdfGetNthClassMarker, NULL},
    { SWIG_prefix "gdfGetNthClassColor", (swig_wrapper_func) _wrap_gdfGetNthClassColor, NULL},
    { SWIG_prefix "gdfGetNumVariables", (swig_wrapper_func) _wrap_gdfGetNumVariables, NULL},
    { SWIG_prefix "gdfGetNthVariableLabel", (swig_wrapper_func) _wrap_gdfGetNthVariableLabel, NULL},
    { SWIG_prefix "gdfGetDefaultVariable", (swig_wrapper_func) _wrap_gdfGetDefaultVariable, NULL},
    { SWIG_prefix "gdfGetDefaultVariableIndex", (swig_wrapper_func) _wrap_gdfGetDefaultVariableIndex, NULL},
    { SWIG_prefix "gdfGetNumSubjects", (swig_wrapper_func) _wrap_gdfGetNumSubjects, NULL},
    { SWIG_prefix "gdfGetNthSubjectID", (swig_wrapper_func) _wrap_gdfGetNthSubjectID, NULL},
    { SWIG_prefix "gdfGetNthSubjectClass", (swig_wrapper_func) _wrap_gdfGetNthSubjectClass, NULL},
    { SWIG_prefix "gdfGetNthSubjectNthValue", (swig_wrapper_func) _wrap_gdfGetNthSubjectNthValue, NULL},
    { SWIG_prefix "gdfGetNthSubjectMeasurement", (swig_wrapper_func) _wrap_gdfGetNthSubjectMeasurement, NULL},
    { SWIG_prefix "gdfOffsetSlope", (swig_wrapper_func) _wrap_gdfOffsetSlope, NULL},
    {0, 0, 0}
  };

  static swig_var_info swig_variables[] = {
    {0,0,0,0}
  };

  static swig_const_info swig_constants[] = {
    {0,0,0,0,0,0}
  };

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

  static swig_type_info _swigt__p_float[] = {{"_p_float", 0, "float *", 0},{"_p_float"},{0}};
  static swig_type_info _swigt__p_FSGD[] = {{"_p_FSGD", 0, "FSGD *", 0},{"_p_FSGD"},{0}};
  static swig_type_info _swigt__p_int[] = {{"_p_int", 0, "int *", 0},{"_p_int"},{0}};

  static swig_type_info *swig_types_initial[] = {
    _swigt__p_float, 
    _swigt__p_FSGD, 
    _swigt__p_int, 
    0
  };


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

#ifdef __cplusplus
}
#endif

SWIGEXPORT(int) SWIG_init(Tcl_Interp *interp) {
  int i;
  static int _init = 0;
  if (interp == 0) return TCL_ERROR;
#ifdef USE_TCL_STUBS
  if (Tcl_InitStubs(interp, (char*)"8.1", 0) == NULL) {
    return TCL_ERROR;
  }
#endif
    
  Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
    
#ifdef SWIG_namespace
  Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
#endif
  if (!_init) {
    for (i = 0; swig_types_initial[i]; i++) {
      swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    _init = 1;
  }
  for (i = 0; swig_commands[i].name; i++) {
    Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper, swig_commands[i].clientdata, NULL);
  }
  for (i = 0; swig_variables[i].name; i++) {
    Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
  }
  SWIG_InstallConstants(interp, swig_constants);
    
  return TCL_OK;
}
SWIGEXPORT(int) Fsgdf_SafeInit(Tcl_Interp *interp) {
  return SWIG_init(interp);
}

