/***************************************************************************
 *   Copyright (C) 2004 by Rudolph Pienaar / Christian Haselgrove          *
 *   {ch|rudolph}@nmr.mgh.harvard.edu                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
/// \file dijkstra_p1.cpp
///
/// \brief Brief description
/// Determine the shortest path on a freesurfer brain curvature map.
///
/// \b NAME
///
/// dijkstra_p1 (dijkstra prototype 1)
///
/// \b SYNPOSIS
///
/// dijkstra_p1 <--optionsFile [fileName]> <--dir [workingDir]> [--listen] [--listenOnPort <port>]
///
/// \b DESCRIPTION
///
/// Determine the shortest path along cost function based on the curvature,
/// sulcal height, and distance using a surface map generated by freesurfer.
/// It is hoped that such a shortest path will accurate trace the sulcal
/// fundus between a specified start and end vertex.
///
/// \b HISTORY
///
///  Week of 20 September 2004 - kdevelop integration / cvs setup
///

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdlib>

using namespace std;

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
//#include <string.h>
#include <getopt.h>

#include <sys/types.h>
#include <sys/stat.h>

#include "scanopt.h"
#include "dijkstra.h"
#include "c_SSocket.h"
#include "pstream.h"
#include "general.h"
#include "asynch.h"
#include "c_vertex.h"
#include "c_label.h"
#include "c_surface.h"

static struct option const longopts[] = {
  {"optionsFile", required_argument,  NULL, 'o'
  },
  {"dir",  required_argument,  NULL, 'd'},
  {"version",   no_argument,  NULL, 'v'},
  {"listen",   no_argument,  NULL, 'l'},
  {"listenOnPort", required_argument, NULL, 'L'},
  {NULL, 0, NULL, 0}
};

char*  Gpch_Progname;
char*  Progname = Gpch_Progname;
string  G_SELF          = "";  // "My" name
string          G_VERSION       =   // version
  "$Id: mris_pmake.cpp,v 1.1 2009/09/08 22:39:27 nicks Exp $";
stringstream Gsout("");
int   G_lw   = 20;  // print column
int   G_rw  = 20;  // widths (left and right)

void
version_show(void) {
  //
  // DESC
  //  Show program version.
  //
  // HISTORY
  // 21 October 2004
  //  o Initial design and coding.
  //

  cout << endl << "\t\t" << G_VERSION;
  cout << endl << "";
  exit(0);
}

void
synopsis_show(void) {
  //
  // DESC
  //  Show a simple synopsis of program usage.
  //
  // HISTORY
  // 24 September 2004
  //  o Initial design and coding.
  //

  cout << endl << "NAME";
  cout << endl << "";
  cout << endl << "\tdijskstra_p1.cpp";
  cout << endl << "\t\t" << G_VERSION;
  cout << endl << "";
  cout << endl << "SYNOPSIS";
  cout << endl << "";
  cout << endl << "\tdijkstra_p1 [OPTIONS]";
  cout << endl << "";
  cout << endl << "DESC";
  cout << endl << "";
  cout << endl << "\t`dijkstra_p1' (prototype 1) attempts to trace sulcal regions on a";
  cout << endl << "\tfreesurfer processed brain volume.";
  cout << endl << "";
  cout << endl << "\tIts behaviour is governed largely by the following command-line options:";
  cout << endl << "";
  cout << endl << "\tOPTIONS:";
  cout << endl << "";
  cout << endl << "\t--optionsFile=<fileName>, -o <fileName>";
  cout << endl << "";
  cout << endl << "\tThis defines an options file that contains several runtime parameters, including";
  cout << endl << "\tcost function variables, start and terminal path vertex indices, etc.";
  cout << endl << "";
  cout << endl << "\tNote that this will default to a file called \"options.txt\" If this contains";
  cout << endl << "\ta directory prefix, this will be assumed to indicate the working directory for";
  cout << endl << "\tany generated output files.";
  cout << endl << "";
  cout << endl << "\t--dir=<dirName>, -d <dirName>";
  cout << endl << "";
  cout << endl << "\tThe working directory. If <fileName> contains a directory prefix, this will";
  cout << endl << "\toverride that prefix. Used to specify directory that contains the optionFile";
  cout << endl << "\tand any generated output files.";
  cout << endl << "";
  cout << endl << "\tNote that this will default to a file called \"options.txt\"";
  cout << endl << "";
  cout << endl << "\t--listen";
  cout << endl << "";
  cout << endl << "\tStart in LISTEN mode, i.e. do not calculate a path, but simply listen on";
  cout << endl << "\tembedded socket (see options file for further instructions). Note that the";
  cout << endl << "\tenvironment described in the options file is still parsed in this mode.";
  cout << endl << "\tThis parameter is useful in forcing a re-read of a possibly changed";
  cout << endl << "\toptions file, without acting on these changes.";
  cout << endl << "";
  cout << endl << "\t--listenOnPort <port>";
  cout << endl << "";
  cout << endl << "\tSimilar to above, but do not parse environment. Create a server socket on";
  cout << endl << "\t<port> and do nothing else. In this mode, the program requires an explicit";
  cout << endl << "\t'HUP' text string to be UDP-sent to <port> to perform the actual path search.";
  cout << endl << "";
  cout << endl << "";
  cout << endl << "";
}

int
main(
  int   argc,
  char**   ppch_argv) {

  /* ----- initializations ----- */

  /*    char*  ppch_default[] = { "dijkstra_p1" , "--listen"};
      argc  = 2;
      ppch_argv  = ppch_default;*/

  Gpch_Progname  = strrchr(ppch_argv[0], '/');
  Gpch_Progname  = (Gpch_Progname == NULL ? ppch_argv[0] : Gpch_Progname+1);
  string  str_progname(Gpch_Progname);
  G_SELF  = str_progname;
  ;

  string   str_asynchComms  = "HUP";
  C_scanopt*    pcso_options  = NULL;
  s_env   st_env;
  s_env_nullify(st_env);

  s_weights   st_costWeight;
  s_Dweights   st_DcostWeight;
  c_SSocket_UDP_receive* pCSSocketReceive = NULL;
  bool   b_socketCreated  = false;

  // Prior to completely populating the enter st_env structure, we fill in
  // some defaults to "boot strap" the process.
  st_env.str_workingDir = "./";
  st_env.str_optionsFileName = "options.txt";
  st_env.b_surfacesKeepInSync = true;   // This allows us to
  // propogate changes
  // in the working
  // surface to the
  // auxillary surface.
  string   str_optionsFQName  = "";
  string   str_patchFQName  = "";

  // Process command line options
  while (1) {
    int opt;
    int optionIndex = 0;
    opt = getopt_long(argc, ppch_argv, "", longopts, &optionIndex);
    if ( opt == -1)
      break;

    switch (opt) {
    case 'o':
      st_env.str_optionsFileName.assign(optarg, strlen(optarg));
      break;
    case 'd':
      st_env.str_workingDir.assign(optarg, strlen(optarg));
      break;
    case 'l':
      str_asynchComms = "LISTEN";
      break;
    case 'L':
      str_asynchComms   = "LISTENPORT";
      st_env.port   = atoi(optarg);
      st_env.timeoutSec  = 60;
      break;
    case '?':
      synopsis_show();
      exit(1);
      break;
    case 'v':
      version_show();
      break;
    default:
      cout << "?? getopt returned character code " << opt << endl;
    }
  }

  // The main functional and event processing loop
  while (str_asynchComms != "TERM") {

    if ( str_asynchComms == "HUP"  ||  \
         str_asynchComms == "LISTEN" || \
         str_asynchComms == "LISTENPORT" || \
         str_asynchComms == "RUN") {

      system("echo > lock");   // signal a "lock"
      // semaphore on
      //  the file system

      if (str_asynchComms != "RUN") {
        // Create scanopt objects to parse the (possibly changed)
        // options file
        str_optionsFQName = st_env.str_workingDir + st_env.str_optionsFileName;
        pcso_options  = new C_scanopt(str_optionsFQName, e_EquLink);

        if (str_asynchComms != "LISTENPORT") {
          // Parse the options file
          s_env_scan( st_env, *pcso_options);
          s_weights_scan( st_costWeight,  *pcso_options);
          s_Dweights_scan( st_DcostWeight, *pcso_options);
          st_env.pSTw  = &st_costWeight;
          st_env.pSTDw = &st_DcostWeight;
        }

        if (st_env.port && !b_socketCreated) {
          // Create a UDP socket
          pCSSocketReceive  = new c_SSocket_UDP_receive(
                                st_env.port, st_env.timeoutSec);
          b_socketCreated = true;
        }
        if (!pCSSocketReceive)
          str_asynchComms = "TERM";
      }

      if ( str_asynchComms == "HUP"  ||  \
           str_asynchComms == "RUN" &&
           st_env.pSTw != NULL) {
        Gsout.str("");
        Gsout << "Determining path from vertex " << st_env.startVertex;
        Gsout  << " to vertex " << st_env.endVertex << "..." << flush;
        ULOUT(Gsout.str());
        SLOUT("PROCESSING: path");

        //----------------------------------
        // The "heart" of this entire system
        s_env_costFctSet(&st_env, costFunc_defaultDetermine, e_default);
        if (!dijkstra(st_env)) exit(1);
        //----------------------------------

        nULOUT("\t\t[ ok ]\n");
        nSLOUT("\t\t\t\t\t\t[ ok ]\n");
        Gsout.str("");

        ULOUT("Marking (rip) path along vertices...");
        s_env_activeSurfaceSetIndex(&st_env, (int) e_workingCurvature);
        surface_ripMark(st_env);
        nULOUT("\t\t\t\t[ ok ]\n");

        if (st_env.b_patchFile_save) {
          ULOUT("Saving patch file...");
          str_patchFQName =  st_env.str_workingDir +
                             st_env.str_patchFileName;
          if (MRISwritePatch(  st_env.pMS_curvature,
                               (char*) str_patchFQName.c_str()) != NO_ERROR)
            exit(1);
          nULOUT("\t\t\t\t\t\t[ ok ]\n");
        }

        if (st_env.b_labelFile_save) {
          ULOUT("Labelling and saving all target vertices... ");
          //label_save(st_env);
          void* pv_void = NULL;
          label_workingSurface_saveTo(st_env, vertex_ripFlagIsTrue, pv_void);
          if (st_env.b_surfacesKeepInSync) {
            surface_workingToAux_ripTrueCopy(st_env);
            label_auxSurface_saveTo(st_env, vertex_ripFlagIsTrue, pv_void);
          }
          nULOUT("\t\t\t[ ok ]\n")
        }

        if (st_env.b_surfacesClear) {
          ULOUT("Clearing (rip) path along vertices...");
          s_env_activeSurfaceSetIndex(&st_env, (int) e_workingCurvature);
          surface_ripClear(st_env, true);
          if (st_env.b_surfacesKeepInSync) {
            s_env_activeSurfaceSetIndex(&st_env, (int) e_auxillary);
            surface_ripClear(st_env, true);
            // NB!! Remember to set the "active" surface back
            // to the "working" surface. The dijkstra()
            // function operates on this "active" surface.
            s_env_activeSurfaceSetIndex(&st_env, (int) e_workingCurvature);
          }
          nULOUT("\t\t\t\t[ ok ]\n");
        }

      }
      /* ----- clean up and exit ----- */
      if (str_asynchComms != "RUN") delete pcso_options;
    }

    // Listen on the socket for asynchronous user evernts
    if (pCSSocketReceive) {
      SLOUT("Ready\n");
      system("rm lock 2>/dev/null");  // "unlock" semaphore
      ULOUT("Listening for socket comms...\n");
      str_asynchComms  = asynchEvent_poll(pCSSocketReceive, 5);
      Gsout.str("");
      Gsout << "COMMS: Received \t\t\t\t\t\t[ " << str_asynchComms << " ]" << endl;
      SLOUT(Gsout.str());
      Gsout.str("");
      Gsout << "\tReceived \t\t\t\t\t\t[ " << str_asynchComms << " ]" << endl;
      ULOUT(Gsout.str());
      asynchEvent_process(st_env, str_asynchComms);
      Gsout.str("");
      Gsout << "PROCESSED: " << str_asynchComms << endl;
      SLOUT(Gsout.str());
    }
  }

  delete pCSSocketReceive;
  if (st_env.pcsm_syslog) {
    st_env.pcsm_syslog->timer(eSM_stop);
    SLOUT("Ready\n");
  }
  if (st_env.pcsm_userlog) {
    st_env.pcsm_userlog->timer(eSM_stop);
  }
  return EXIT_SUCCESS;

} /* end main() */

/* eof */

