/***************************************************************************
 *   Copyright (C) 2004 by Rudolph Pienaar / Christian Haselgrove          *
 *   {ch|rudolph}@nmr.mgh.harvard.edu                                      *
 *                                                                         *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
/// \file mris_pmake.cpp
///
/// \brief Brief description
/// Determine the shortest path on a freesurfer brain curvature map.
///
/// \b NAME
///
/// mris_pmake (dijkstra prototype 1)
///
/// \b SYNPOSIS
///
/// mris_pmake <--optionsFile [fileName]> <--dir [workingDir]> [--listen] [--listenOnPort <port>]
///
/// \b DESCRIPTION
///
/// Determine the shortest path along cost function based on the curvature,
/// sulcal height, and distance using a surface map generated by freesurfer.
/// It is hoped that such a shortest path will accurate trace the sulcal
/// fundus between a specified start and end vertex.
///
/// \b HISTORY
///
///  Week of 20 September 2004 - kdevelop integration / cvs setup
///
///  27 October 2009
///  o Resurrection!
///    Changed setting of default cost function to occur during system
///    init. Previously this happened prior to each call to dijkstra(...).
///    This allows for dijkstra RUN to use arbitrary cost (old behaviour
///    was to only allow arbitrary cost function selection for ply searching).
///
///  November - December 2009
///  o Modification to allow running without dsh.
///  

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <cstdlib>

using namespace std;

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>

#include "help.h"
#include "scanopt.h"
#include "dijkstra.h"
#include "C_mpmProg.h"
#include "c_SSocket.h"
#include "pstream.h"
#include "general.h"
#include "asynch.h"
#include "c_vertex.h"
#include "c_label.h"
#include "c_surface.h"


// Some global vars...
extern  const option longopts[];
stringstream            Gsout("");
char*   Gpch_Progname;
char*   Progname        = Gpch_Progname;
bool    Gb_stdout       = true;         // Global flag controlling output to
                                        //+stdout
string  G_SELF          = "";           // "My" name
string  G_VERSION       =               // version
  "$Id: mris_pmake.cpp,v 1.13 2010/07/14 17:56:46 rudolph Exp $";
char 	pch_buffer[65536];

// "Class"-like globals...
s_env                         st_env;
string                        str_asynchComms         = "HUP";
c_SSocket_UDP_receive*        pCSSocketReceive        = NULL;

int
main(
    int         argc,
    char**      ppch_argv) {

  /* ----- initializations ----- */
  Gpch_Progname  = strrchr(ppch_argv[0], '/');
  Gpch_Progname  = (Gpch_Progname == NULL ? ppch_argv[0] : Gpch_Progname+1);
  string	str_progname(Gpch_Progname);
  G_SELF        = str_progname;

  // "Construct" a default environment structure.
  s_env_nullify(st_env);
	
  // Prior to completely populating the enter st_env structure, we fill in
  // some defaults to "boot strap" the process.
  st_env.str_workingDir         = "./";
  st_env.str_optionsFileName    = "options.txt";
  st_env.b_surfacesKeepInSync   = true;         // This allows us to
                                                //+ propogate changes
                                                //+ in the working
                                                //+ surface to the
                                                //+ auxillary surface.

  // Set the default cost function in the enviroment
  s_env_costFctSet(&st_env, costFunc_defaultDetermine, e_default);

  // Process command line options
  str_asynchComms       = commandLineOptions_process(argc, ppch_argv, st_env);

  // The main functional and event processing loop
  while (str_asynchComms != "TERM") {

    if ( str_asynchComms == "HUP"               || \
         str_asynchComms == "INITMPMPROG"       || \
         str_asynchComms == "RUNPROG") {

      system("echo > lock");            // signal a "lock"
                                        //+ semaphore on
                                        //+ the file system

      if (str_asynchComms 	== "HUP") 
	str_asynchComms = s_env_HUP(st_env, &pCSSocketReceive);
      
      if (str_asynchComms	== "RUNPROG") {
          if(!st_env.b_mpmProgUse) 
              s_env_mpmProgSetIndex(&st_env, st_env.empmProg_current);
	  ULOUT(lsprintf(st_env.lw, pch_buffer, 
	  	"Running embedded program '%s'\n",
	        st_env.vstr_mpmProgName[st_env.empmProg_current].c_str()));
          if(st_env.pCmpmProg) st_env.pCmpmProg->run();
          else {
              fprintf(stderr, "Warning -- mpmProg has not been created!\n");
              fprintf(stderr, "Have you run 'ENV mpmProg set <X>'?\n");
          }
          if(st_env.b_exitOnDone) str_asynchComms = "TERM";
      }
    }

    // Listen on the socket for asynchronous user evernts
    if (pCSSocketReceive && !st_env.b_exitOnDone) {
      SLOUT("Ready\n");
      ULOUT("Listening for socket comms...\n");
      str_asynchComms  = asynchEvent_poll(pCSSocketReceive, 5);
      colsprintf(st_env.lw, st_env.rw, pch_buffer,
          	"COMMS: Received", "[ %s ]\n", 
          	str_asynchComms.c_str());
      SLOUT(pch_buffer);
      ULOUT(pch_buffer);
      asynchEvent_process(st_env, str_asynchComms);
      SLOUT(colsprintf(st_env.lw, st_env.rw, pch_buffer,
          		"PROCESSED", "[ %s ]\n",
          		str_asynchComms.c_str()));
    } else {
	// Process does not have listen server or has exitOnDone
	// and can exit (otherwise hangs in infinite wait loop without
	// processing new str_asynchComms).
	str_asynchComms = "TERM";
    }
  }

  delete pCSSocketReceive;
  if (st_env.pcsm_syslog) {
    st_env.pcsm_syslog->timer(eSM_stop);
    SLOUT("Ready\n");
  }
  if (st_env.pcsm_userlog) {
    st_env.pcsm_userlog->timer(eSM_stop);
  }
  system("rm -f lock 2>/dev/null");  // "unlock" semaphore
  return EXIT_SUCCESS;

} /* end main() */

/* eof */

