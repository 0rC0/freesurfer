/*---------------------------------------------------------------
  Name: resample.c
  $Id: resample.c,v 1.1 2001/02/06 18:10:19 greve Exp $
  Author: Douglas N. Greve
  Purpose: code to perform resapling from one space to another, 
  including: volume-to-volume, volume-to-surface, and surface-to-surface.

  Notes: 

  1. Values on the surface are stored as MRI structures. In general,
  they cannot be stored as part of the MRIS structure because this
  does not accomodate multiple values per vertex. When stored as an
  MRI, width = nvertices, height=1, depth=1, nframes=nframes.

  2. Interpolation - the code implies that trilinear and sinc 
  interpolation are available. They are not as of 2/4/01.

  3. Float2Int - the software supports three ways to convert floating
  to integer when computing the index of a voxel: round, floor, tkreg.
  Ideally, round should be used because it makes the mapping invertible.
  However, tkregister uses it's own funky scheme (replicated with the
  tkreg option), and paint uses floor. In the end, the conversion must
  be compatible with the registration program.

  4. Volume-to-Volume - V2V is a necessary step when converting functional
  data to talairach or painting onto the surface. The model as of 2/4/01
  assumes that the transformation is completely linear from one space to
  another, though there are variables for intermediate transformations
  built in. The four variables are: (1) Quantization matrix Q, (2) Field-
  of-view matrix F, (3) Warping matrix W, and (4), Registration matrix D.

  D - Registration matrix. Converts from Anatomical Space to Unwarpded
      Scanner Space.
  W - Warping matrix. Converts from Unwarpded Scanner Space to Warped
      Scanner Space.
  F - FOV matrix. Converts from Warpded Scanner Space to Field-of-View
      Space (the space created by the axes centered in the FOV and 
      parallel with the edges of the FOV).
  Q - Quantization matrix. Converts from FOV space to ColRowSlice Index
      Space.

  The matrix in register.dat = D*W*F

  In theory, the warping matrix can be replaced by a non-linear warping 
  function to account for warping of the scanner space, but this is yet 
  to be implemented.
  ---------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "matrix.h"
#include "mri.h"
#include "mrisurf.h"
#include "mrishash.h"
#include "label.h"
#include "resample.h"
#include "bfileio.h"
#include "corio.h"

/*---------------------------------------------------------
  interpolation_code(): gets a code that controls the 
  interpolation from a string. Returns -1 if the string is 
  unrecoginzed.
  ---------------------------------------------------------*/
int interpolation_code(char *interpolation_string)
{
  if(!strcasecmp(interpolation_string,"nearest"))
    return(INTERP_NEAREST);

  if(!strcasecmp(interpolation_string,"tli"))
    return(INTERP_TLI); /* Tri-linear interp */

  if(!strcasecmp(interpolation_string,"sinc"))
    return(INTERP_SINC);

  return(-1);
}
/*---------------------------------------------------------
  float2int_code(): gets a code that controls the floating
  point to integer conversion method from a string. Returns
  -1 if the string is unrecoginzed.
  ---------------------------------------------------------*/
int float2int_code(char *float2int_string)
{
  if(!strcasecmp(float2int_string,"round") || 
     !strcasecmp(float2int_string,"rint"))
    return(FLT2INT_ROUND);

  if(!strcasecmp(float2int_string,"floor")) return(FLT2INT_FLOOR);

  if(!strcasecmp(float2int_string,"tkreg")) return(FLT2INT_TKREG);

  return(-1);
}

/*-----------------------------------------------------------
  XYZAnat2CRSFunc_TkReg() - computes the col, row, and slc in
  a functional volume given the x,y,z in the anatomical volume
  along with a registration matrix (generated by tkregister) and
  the dimensions of the functional volume:
    npixels  = number of rows = number of columns
    pixsize  = size of in-plane pixels (mm)
    nslcs    = number of slices
    slcthick = distance between slices (mm)
  When volumes are coronally sliced, then col is LR (sagital), 
  row is SI (axial), and slc is AP (cor)
  -----------------------------------------------------------*/
int XYZAnat2CRSFunc_TkReg(int *col, int *row, int *slc,
			  int npixels, float pixsize,
			  int nslcs,   float slcthick,
			  float xanat, float yanat, float zanat,
			  MATRIX *Reg)
{
  MATRIX *Qf;
  MATRIX *QfR;
  MATRIX *xyz, *crs;

  /* compute the tkregister quantization matrix */
  Qf = FOVQuantMtx_TkReg(npixels, pixsize, nslcs, slcthick);

  /* QfR = Qf* R*/
  QfR = MatrixMultiply(Qf,Reg,NULL);

  /* load xyz into a vector */
  xyz = MatrixAlloc(4,1,MATRIX_REAL);
  xyz->rptr[0+1][0+1] = xanat;
  xyz->rptr[1+1][0+1] = yanat;
  xyz->rptr[2+1][0+1] = zanat;
  xyz->rptr[3+1][0+1] = 1.0;

  /* crs = Qf*R*xyz */
  crs = MatrixMultiply(QfR,xyz,NULL);

  /* extract col, row, slice from the crs vector */
  /* convert floats to ints as only tkregister can */
  float2int_TkReg(col,row,slc, 
		  crs->rptr[0+1][0+1],
		  crs->rptr[1+1][0+1],
		  crs->rptr[2+1][0+1]);

  MatrixFree(&Qf);  
  MatrixFree(&QfR);
  MatrixFree(&xyz);
  MatrixFree(&crs);

  return(0);
}
/*----------------------------------------------------------
  float2int_TkReg() - converts floats to int as only 
  tkregsiter can. When volumes are coronally sliced, then
  col is LR (sagital), row is SI (axial), and slc is AP (cor)
  ----------------------------------------------------------*/
int float2int_TkReg(int *col, int *row, int *slc, 
		    float fltcol, float fltrow, float fltslc)
{
  *col = (int)(fltcol);
  *row = (int)(ceil(fltrow));
  *slc = (int)(fltslc);
  return(0);
}
/*-----------------------------------------------------------
  FOVQuantMtx_TkReg() -- computes the FOV quantization matrix 
  which converts an x,y,z into a col,row,slc : crs = Q*xyz. This
  particular formulation is the one used by TkRegister. Note:
  Q is a 4x4 matrix in order to accomodate translation.
    npixels  = number of rows = number of columns
    pixsize  = size of in-plane pixels (mm)
    nslcs    = number of slices
    slcthick = distance between slices (mm)
    -----------------------------------------------------------*/
MATRIX * FOVQuantMtx_TkReg(int npixels, float pixsize, 
			   int nslcs,   float slcthick)
{
  MATRIX *Q;

  Q = MatrixAlloc(4, 4, MATRIX_REAL );
  MatrixClear(Q);

  Q->rptr[0+1][0+1] = -1/pixsize;
  Q->rptr[0+1][3+1] =  npixels/2;

  Q->rptr[1+1][2+1] =  1/slcthick;
  Q->rptr[1+1][3+1] = -nslcs/2;

  Q->rptr[2+1][1+1] = -1/pixsize;
  Q->rptr[2+1][3+1] =  npixels/2;

  Q->rptr[3+1][3+1] = 1.0;

  return(Q);
}
/*-----------------------------------------------------------
  FOVDeQuantMatrix() -- computes the volume dequantization matrix which
  converts a col,row,slc into an x,y,z: xyz = deQ*crs
-----------------------------------------------------------*/
MATRIX * FOVDeQuantMatrix(int ncols, int nrows, int nslcs, 
			  float colres, float rowres, float slcres  )
{
  MATRIX *deQ;

  deQ = MatrixAlloc(4, 4, MATRIX_REAL );
  MatrixClear(deQ);

  deQ->rptr[0+1][0+1] = -colres;
  /*deQ->rptr[0+1][3+1] =  colres*(ncols-1)/2;*/
  deQ->rptr[0+1][3+1] =  colres*(ncols)/2;

  deQ->rptr[1+1][2+1] =  slcres;
  /*deQ->rptr[1+1][3+1] = -slcres*(nslcs-1)/2;*/
  deQ->rptr[1+1][3+1] = -slcres*(nslcs)/2;

  deQ->rptr[2+1][1+1] = -rowres;
  /*deQ->rptr[2+1][3+1] =  rowres*(nrows-1)/2;*/
  deQ->rptr[2+1][3+1] =  rowres*(nrows)/2;

  deQ->rptr[3+1][3+1] = 1.0;

  return(deQ);
}
/*-----------------------------------------------------------
  FOVQuantMatrix() -- computes the volume quantization matrix which
  converts a x,y,z into col,row,slc : crs = Q*xyz
  -----------------------------------------------------------*/
MATRIX * FOVQuantMatrix(int ncols, int nrows, int nslcs, 
			  float colres, float rowres, float slcres  )
{
  MATRIX *deQ, *Q;

  deQ = FOVDeQuantMatrix(ncols,nrows,nslcs,colres,rowres,slcres);
  Q   = MatrixInverse(deQ,NULL);
  MatrixFree(&deQ);

  return(Q);
}
/*------------------------------------------------------------
  ComputeQFWD() - computes the matrix product of Q, F, W, D.
  If any matrix is NULL, then it is treated as the idenity.
  ------------------------------------------------------------*/
MATRIX *ComputeQFWD(MATRIX *Q, MATRIX *F, MATRIX *W, MATRIX *D, MATRIX *QFWD)
{
  MATRIX *QFWDtmp;

  if(QFWD==NULL) QFWDtmp = MatrixAlloc(4,4,MATRIX_REAL);
  else           QFWDtmp = QFWD;

  MatrixIdentity(4,QFWDtmp);

  if(Q != NULL)  MatrixMultiply(QFWDtmp, Q, QFWDtmp);
  if(F != NULL)  MatrixMultiply(QFWDtmp, F, QFWDtmp);
  if(W != NULL)  MatrixMultiply(QFWDtmp, W, QFWDtmp);
  if(D != NULL)  MatrixMultiply(QFWDtmp, D, QFWDtmp);

  return(QFWDtmp);
}

/*------------------------------------------------------------
  vol2vol_linear() - resample one volume into another assuming
  that the transformation is completely linear.  Msrc2trg is the
  linear mapping from the Anatomical Space of the Source Subject
  to the Anatomical Space of the Target Subject.
------------------------------------------------------------*/
MRI *vol2vol_linear(MRI *SrcVol, 
		    MATRIX *Qsrc, MATRIX *Fsrc, MATRIX *Wsrc, MATRIX *Dsrc, 
		    MATRIX *Qtrg, MATRIX *Ftrg, MATRIX *Wtrg, MATRIX *Dtrg, 
		    int   nrows_trg, int   ncols_trg, int   nslcs_trg,
		    MATRIX *Msrc2trg, int InterpMethod, int float2int)
{
  MATRIX *QFWDsrc, *QFWDtrg, *invQFWDtrg;
  MATRIX *Tcrs2Scrs, *invMsrc2trg;
  MATRIX *Scrs, *Tcrs, *Txyz;
  MRI *TrgVol;
  int   irow_trg, icol_trg, islc_trg; /* integer row, col, slc in target */
  int   irow_src, icol_src, islc_src; /* integer row, col, slc in source */
  float srcval;
  int frm;
  
  if(InterpMethod != INTERP_NEAREST){
    fprintf(stderr,"vol2vol_linear(): only support for nearest interpolation\n");
    return(NULL);
  }

  /* compute the transforms */
  QFWDsrc = ComputeQFWD(Qsrc,Fsrc,Wsrc,Dsrc,NULL);
  QFWDtrg = ComputeQFWD(Qtrg,Ftrg,Wtrg,Dtrg,NULL);
  invQFWDtrg = MatrixInverse(QFWDtrg,NULL);
  if(Msrc2trg != NULL) invMsrc2trg = MatrixInverse(Msrc2trg,NULL);
  else                 invMsrc2trg = MatrixIdentity(4,NULL);
  Tcrs2Scrs = MatrixMultiply(QFWDsrc,invMsrc2trg,NULL);
  MatrixMultiply(Tcrs2Scrs , invQFWDtrg, Tcrs2Scrs);

  /* Tcrs2Scrs - maps Target ColRowSlice to that of the Source */

  /* preallocate the row-col-slc vectors */
  Tcrs = MatrixAlloc(4,1,MATRIX_REAL);
  Tcrs->rptr[3+1][0+1] = 1.0;
  Scrs = MatrixAlloc(4,1,MATRIX_REAL);
  Txyz = MatrixAlloc(4,1,MATRIX_REAL);
  Txyz->rptr[3+1][0+1] = 1.0;

  /* allocate a volume to hold the output */
  TrgVol = MRIallocSequence(ncols_trg, nrows_trg, nslcs_trg,
			    MRI_FLOAT,SrcVol->nframes);
  if(TrgVol == NULL) return(NULL);

  /* Go through each target voxel and compute the location of
     the closest source voxel */
  for(islc_trg = 0; islc_trg < nslcs_trg; islc_trg++){
    for(irow_trg = 0; irow_trg < nrows_trg; irow_trg++){
      for(icol_trg = 0; icol_trg < ncols_trg; icol_trg++){

	/* Load the Target col-row-slc vector */
	Tcrs->rptr[0+1][0+1] = icol_trg;
	Tcrs->rptr[1+1][0+1] = irow_trg;
	Tcrs->rptr[2+1][0+1] = islc_trg;

	/* Compute the corresponding Source col-row-slc vector */
	MatrixMultiply(Tcrs2Scrs,Tcrs,Scrs);

	/* nearest neighbor */
	switch(float2int){
	case FLT2INT_ROUND:
	  icol_src = (int)rint(Scrs->rptr[0+1][0+1]);
	  irow_src = (int)rint(Scrs->rptr[1+1][0+1]);
	  islc_src = (int)rint(Scrs->rptr[2+1][0+1]);
	  break;
	case FLT2INT_FLOOR:
	  icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
	  irow_src = (int)floor(Scrs->rptr[1+1][0+1]);
	  islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
	  break;
	case FLT2INT_TKREG:
	  icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
	  irow_src = (int) ceil(Scrs->rptr[1+1][0+1]);
	  islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
	  break;
	default:
	  fprintf(stderr,"vol2vol_linear(): unrecoginized float2int code %d\n",
		  float2int);
	  MRIfree(&TrgVol);
	  return(NULL);
	  break;
	}

	/* make sure the Source Voxel is in the volume */
	if(irow_src < 0 || irow_src >= SrcVol->height ||
	   icol_src < 0 || icol_src >= SrcVol->width  ||
	   islc_src < 0 || islc_src >= SrcVol->depth ) continue;

        /* map each frame */
	for(frm = 0; frm < SrcVol->nframes; frm++){
	  srcval = MRIFseq_vox(SrcVol,icol_src,irow_src,islc_src,frm);
	  MRIFseq_vox(TrgVol,icol_trg,irow_trg,islc_trg,frm) = srcval;
	}

      }
    }
  }

  MatrixFree(&QFWDsrc);
  MatrixFree(&QFWDtrg);
  MatrixFree(&invQFWDtrg);
  MatrixFree(&Tcrs2Scrs);
  MatrixFree(&invMsrc2trg);
  MatrixFree(&Scrs);
  MatrixFree(&Tcrs);

  printf("mri_vol2vol_linear: done\n");

  return(TrgVol);  
}
/*-----------------------------------------------------------------------
  label2mask_linear() - converts a label into a masking volume. The masking
  volume is the same FOV as the source volume.  The mask has a value of 1
  where ever there is a label point and the SrcMskVol is > 0.5; the mask is 
  zero everywhere else.  The SrcMskVol is a mask of the same FOV as the source;
  it is ignored if NULL.
------------------------------------------------------------------------*/
MRI *label2mask_linear(MRI *SrcVol, 
		       MATRIX *Qsrc, MATRIX *Fsrc, MATRIX *Wsrc, MATRIX *Dsrc, 
		       MRI *SrcMskVol, MATRIX *Msrc2lbl, LABEL *Label, 
		       int float2int, int *nlabelhits, int *nfinalhits)
{
  MATRIX *QFWDsrc;
  MATRIX *Lxyz2Scrs;
  MATRIX *Scrs, *Lxyz, *Mlbl2src;
  MRI *FinalMskVol;
  int   irow_src, icol_src, islc_src; /* integer row, col, slc in source */
  float mskval;
  int vlbl;
  
  /* compute the transforms */
  QFWDsrc = ComputeQFWD(Qsrc,Fsrc,Wsrc,Dsrc,NULL);
  if(Msrc2lbl != NULL) Mlbl2src = MatrixInverse(Msrc2lbl,NULL);
  else                 Mlbl2src = NULL;
  if(Mlbl2src != NULL) Lxyz2Scrs = MatrixMultiply(QFWDsrc,Mlbl2src,NULL);    
  else                 Lxyz2Scrs = MatrixCopy(QFWDsrc,NULL);

  printf("\n");
  printf("Lxyz2Scrs:\n");
  MatrixPrint(stdout,Lxyz2Scrs);
  printf("\n");

  /* preallocate the row-col-slc vectors */
  Lxyz = MatrixAlloc(4,1,MATRIX_REAL);
  Lxyz->rptr[3+1][0+1] = 1.0;
  Scrs = MatrixAlloc(4,1,MATRIX_REAL);

  /* allocate an output volume -- same size as source*/
  FinalMskVol = MRIallocSequence(SrcVol->width,SrcVol->height,SrcVol->depth,
				 MRI_FLOAT,1);
  if(FinalMskVol == NULL) return(NULL);
  
  *nlabelhits = 0;
  *nfinalhits = 0;
  
  /* Go through each point in the label */
  for(vlbl = 0; vlbl < Label->n_points; vlbl++){
    
    /* load the label xyz into a vector */
    Lxyz->rptr[0+1][0+1] = Label->lv[vlbl].x;
    Lxyz->rptr[1+1][0+1] = Label->lv[vlbl].y;
    Lxyz->rptr[2+1][0+1] = Label->lv[vlbl].z;
    
    /* compute the corresponding col, row, and slice in the source vol */
    MatrixMultiply(Lxyz2Scrs,Lxyz,Scrs);
    
    /* Convert the analog col, row, and slice to integer */
    switch(float2int){
    case FLT2INT_ROUND:
      icol_src = (int)rint(Scrs->rptr[0+1][0+1]);
      irow_src = (int)rint(Scrs->rptr[1+1][0+1]);
      islc_src = (int)rint(Scrs->rptr[2+1][0+1]);
      break;
    case FLT2INT_FLOOR:
      icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
      irow_src = (int)floor(Scrs->rptr[1+1][0+1]);
      islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
      break;
    case FLT2INT_TKREG:
      icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
      irow_src = (int) ceil(Scrs->rptr[1+1][0+1]);
      islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
      break;
    default:
      fprintf(stderr,"label2mask_linear(): unrecoginized float2int code %d\n",
	      float2int);
      MRIfree(&FinalMskVol);
      return(NULL);
      break;
    }
    
    /* check that the point is within the source volume */
    if(irow_src < 0 || irow_src >= SrcVol->height ||
       icol_src < 0 || icol_src >= SrcVol->width  ||
       islc_src < 0 || islc_src >= SrcVol->depth ) continue;
    (*nlabelhits)++;

    /* check that the point is within the input mask */
    if(SrcMskVol != NULL){
      mskval = MRIFseq_vox(SrcMskVol,icol_src,irow_src,islc_src,0);
      if(mskval < 0.5) continue;
    }

    /* ok, now set the mask value to 1 */
    MRIFseq_vox(FinalMskVol,icol_src,irow_src,islc_src,0) = 1;

    /* increment the number of hits */
    (*nfinalhits)++;
  }

  fprintf(stderr,"INFO: label2mask: there were %d hits\n", *nfinalhits);

  MatrixFree(&QFWDsrc);
  MatrixFree(&Lxyz2Scrs);
  MatrixFree(&Scrs);
  MatrixFree(&Lxyz);
  if(Mlbl2src != NULL) MatrixFree(&Mlbl2src);

  printf("label2mask_linear: done\n");

  return(FinalMskVol);  
}
/*-----------------------------------------------------------------------
  vol2maskavg() -- averages all the voxels within a mask.  SrcVol and
  SrcMskVol must be the same size.  Searchs SrcMskVol for voxels whose
  value is > 0.5. For all such voxels, averages the corresponding values
  found in SrcVol.  Returns an MRI "volume" of dimension 1X1X1Xnframes.
  -----------------------------------------------------------------------*/
MRI * vol2maskavg(MRI *SrcVol, MRI *SrcMskVol, int *nhits)
{
  int r,c,s,f;
  MRI *MskAvg;
  float mskval, val;

  /* make sure that SrcVol and SrcMskVol are the same dimension */
  if(SrcVol->width  != SrcMskVol->width ||
     SrcVol->height != SrcMskVol->height ||
     SrcVol->depth  != SrcMskVol->depth){
    fprintf(stderr,"ERROR: vol2maskavg: SrcVol and SrcMskVol do "
	    "not have the same dimension\n");
    return(NULL);
  }

  /* allocate an output "volume" */
  MskAvg = MRIallocSequence(1,1,1,MRI_FLOAT,SrcVol->nframes);
  if(MskAvg == NULL) return(NULL);

  /* go through each voxel */
  *nhits = 0;
  for(c=0; c < SrcVol->width; c++){
    for(r=0; r < SrcVol->height; r++){
      for(s=0; s < SrcVol->depth; s++){
	/* get mask value at r,c,s */
	mskval = MRIFseq_vox(SrcMskVol,c,r,s,0); 
	if(mskval > 0.5){ 
	  /* accumulate sum over suprathreshold points */
	  (*nhits)++;
	  for(f=0; f < SrcVol->nframes; f++){
	    val = MRIFseq_vox(SrcVol,c,r,s,f);
	    MRIFseq_vox(MskAvg,0,0,0,f) += val;
	  }
	}
      }
    }
  }

  printf("INFO: vol2maskavg: nhits = %d\n",*nhits);
  if(*nhits != 0){
    /* divide by the number of hits to get the average*/
    for(f=0; f < SrcVol->nframes; f++){
      val = MRIFseq_vox(MskAvg,0,0,0,f);
      MRIFseq_vox(MskAvg,0,0,0,f) = val/(*nhits);
      /*printf("%2d %g %g\n",f,val,MRIFseq_vox(MskAvg,0,0,0,f));*/
    }
  }
  else{
    fprintf(stderr,"WARNING: there were no voxels in the input mask > 0.5\n");
  }

  /* return the Masked Average */
  return(MskAvg);
}
/*----------------------------------------------------------------
  ProjNormFracThick() - projects along the surface normal a given
  fraction of the thickness at that point.
  ----------------------------------------------------------------*/
int ProjNormFracThick(float *x, float *y, float *z, 
		      MRI_SURFACE *surf, int vtx, float frac)
{
  float r;
  r = frac * surf->vertices[vtx].curv;
  *x = surf->vertices[vtx].x + r*surf->vertices[vtx].nx;
  *y = surf->vertices[vtx].y + r*surf->vertices[vtx].ny;
  *z = surf->vertices[vtx].z + r*surf->vertices[vtx].nz;
  return(0);
}
/*------------------------------------------------------------
  vol2surf_linear() - resamples data from a volume onto surface 
  vertices assuming the the transformation from the volume into
  anatomical space is fully linear.
  ------------------------------------------------------------*/
MRI *vol2surf_linear(MRI *SrcVol, 
		     MATRIX *Qsrc, MATRIX *Fsrc, MATRIX *Wsrc, MATRIX *Dsrc, 
		     MRI_SURFACE *TrgSurf, float ProjFrac, 
		     int InterpMethod, int float2int)
{
  MATRIX *QFWDsrc;
  MATRIX *Scrs, *Txyz;
  MRI *TrgVol;
  int   irow_src, icol_src, islc_src; /* integer row, col, slc in source */
  float srcval, Tx, Ty, Tz;
  int frm;
  int vtx,nhits;
  
  if(InterpMethod != INTERP_NEAREST){
    fprintf(stderr,"vol2surf_linear(): only support for nearest "
	    "interpolation\n");
    return(NULL);
  }

  /* compute the transforms */
  QFWDsrc = ComputeQFWD(Qsrc,Fsrc,Wsrc,Dsrc,NULL);

  /* preallocate the row-col-slc vectors */
  Scrs = MatrixAlloc(4,1,MATRIX_REAL);
  Txyz = MatrixAlloc(4,1,MATRIX_REAL);
  Txyz->rptr[3+1][0+1] = 1.0;

  /* allocate a "volume" to hold the output */
  TrgVol = MRIallocSequence(TrgSurf->nvertices,1,1,MRI_FLOAT,SrcVol->nframes);
  if(TrgVol == NULL) return(NULL);

  nhits = 0;
  /*--- loop through each vertex ---*/
  for(vtx = 0; vtx < TrgSurf->nvertices; vtx++){

    if(ProjFrac != 0.0)
      ProjNormFracThick(&Tx,&Ty,&Tz,TrgSurf,vtx,ProjFrac);
    else{
      Tx = TrgSurf->vertices[vtx].x;
      Ty = TrgSurf->vertices[vtx].y;
      Tz = TrgSurf->vertices[vtx].z;
    }

    /* Load the Target xyz vector */
    Txyz->rptr[0+1][0+1] = Tx;
    Txyz->rptr[1+1][0+1] = Ty;
    Txyz->rptr[2+1][0+1] = Tz;

    /* Compute the corresponding Source col-row-slc vector */
    MatrixMultiply(QFWDsrc,Txyz,Scrs);

    /* nearest neighbor */
    switch(float2int){
    case FLT2INT_ROUND:
      icol_src = (int)rint(Scrs->rptr[0+1][0+1]);
      irow_src = (int)rint(Scrs->rptr[1+1][0+1]);
      islc_src = (int)rint(Scrs->rptr[2+1][0+1]);
      break;
    case FLT2INT_FLOOR:
      icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
      irow_src = (int)floor(Scrs->rptr[1+1][0+1]);
      islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
      break;
    case FLT2INT_TKREG:
      icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
      irow_src = (int) ceil(Scrs->rptr[1+1][0+1]);
      islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
      break;
    default:
      fprintf(stderr,"vol2surf_linear(): unrecoginized float2int code %d\n",
	      float2int);
      MRIfree(&TrgVol);
      return(NULL);
      break;
    }

    /* check that the point is in the bounds of the volume */
    if(irow_src < 0 || irow_src >= SrcVol->height ||
       icol_src < 0 || icol_src >= SrcVol->width  ||
       islc_src < 0 || islc_src >= SrcVol->depth ) continue;

    /* only gets here if it is in bounds */
    nhits ++;
    
    for(frm = 0; frm < SrcVol->nframes; frm++){
      srcval = MRIFseq_vox(SrcVol,icol_src,irow_src,islc_src,frm);
      MRIFseq_vox(TrgVol,vtx,0,0,frm) = srcval;
    }
  }

  MatrixFree(&QFWDsrc);
  MatrixFree(&Scrs);
  MatrixFree(&Txyz);


  printf("vol2surf_linear: nhits = %d/%d\n",nhits,TrgSurf->nvertices);

  return(TrgVol);  
}

/*----------------------------------------------------------------
  MRI *surf2surf_nnfr() - resample values on one surface to another
  using nearest-neighbor forward/reverse (nnfr) method. If the 
  ReverseMapFlag=0, the reverse loop is not implemented. The forward
  loop assures that each target vertex is mapped to a source vertex.
  A source vertex may map to multiple target vertices (fan-out),
  however, there may be some source vertices that do not map to any 
  target vertex ("lost vertices"). If the reverse loop is chosen,
  then the lost vertices will be mapped to their closest target
  vertex; this will also generate fan-in.

  Several diagnostic results are returned:
     SrcHits - number of target vertices mapped to by each source
               vertex (measures fan-out).
     SrcDist - average distance of a source vertex to it's mapping
               target vertices.
     TrgHits - number of source vertices mapped to each target
               vertex (measures fan-in).
     TrgDist - average distance of a target vertex to it's mapping
               source vertices.
  ----------------------------------------------------------------*/
MRI *surf2surf_nnfr(MRI *SrcSurfVals, MRI_SURFACE *SrcSurfReg, 
		    MRI_SURFACE *TrgSurfReg, MRI **SrcHits,
		    MRI **SrcDist, MRI **TrgHits, MRI **TrgDist,
		    int ReverseMapFlag, int UseHash)
{
  MRI *TrgSurfVals = NULL;
  int svtx, tvtx, f,n, nunmapped, nrevhits,nSrcLost;
  VERTEX *v;
  MHT *SrcHash, *TrgHash;
  float dmin;

  /* check dimension consistency */
  if(SrcSurfVals->width != SrcSurfReg->nvertices){
    fprintf(stderr,"surf2surf_nnfr(): Vals and Reg dimension mismatch\n");
    fprintf(stderr,"nVals = %d, nReg %d\n",SrcSurfVals->width,
	    SrcSurfReg->nvertices);
    return(NULL);
  }

  /* allocate a "volume" to hold the output */
  TrgSurfVals = MRIallocSequence(TrgSurfReg->nvertices,1,1,
				 MRI_FLOAT,SrcSurfVals->nframes);
  if(TrgSurfVals == NULL) return(NULL);

  /* number of source vertices mapped to each target vertex */
  *TrgHits = MRIallocSequence(TrgSurfReg->nvertices,1,1,MRI_FLOAT,1);
  if(*TrgHits == NULL) return(NULL);

  /* Average distance of a target vertex from its source vertices  */
  *TrgDist = MRIallocSequence(TrgSurfReg->nvertices,1,1,MRI_FLOAT,1);
  if(*TrgDist == NULL) return(NULL);

  /* number of target vertices mapped to by each source vertex */
  *SrcHits = MRIallocSequence(SrcSurfReg->nvertices,1,1,MRI_FLOAT,1);
  if(*SrcHits == NULL) return(NULL);

  /* Average distance of a source vertex from its target vertices  */
  *SrcDist = MRIallocSequence(SrcSurfReg->nvertices,1,1,MRI_FLOAT,1);
  if(*SrcDist == NULL) return(NULL);

  /* build hash tables */
  if(UseHash){
    printf("surf2surf_nnfr: building source hash (res=16).\n");
    SrcHash = MHTfillVertexTableRes(SrcSurfReg, NULL,CURRENT_VERTICES,16);
  }

  /*---------------------------------------------------------------
    Go through the forwad loop (finding closest srcvtx to each trgvtx).
    This maps each target vertex to a source vertex */
  printf("Surf2Surf: Forward Loop (%d)\n",TrgSurfReg->nvertices);
  nunmapped = 0;
  for(tvtx = 0; tvtx < TrgSurfReg->nvertices; tvtx++){
    if(!UseHash){
      if(tvtx%100 == 0) {printf("%5d ",tvtx);fflush(stdout);}
      if(tvtx%1000 == 999){printf("\n");fflush(stdout);}
    }
    /* find closest source vertex */
    v = &(TrgSurfReg->vertices[tvtx]);
    if(UseHash) svtx = MHTfindClosestVertexNo(SrcHash,SrcSurfReg,v,&dmin);
    else        svtx = MRISfindClosestVertex(SrcSurfReg,v->x,v->y,v->z);

    if(svtx < 0) {/* this can only happen with MHT */
      nunmapped ++;
      printf("Unmapped: %3d tvtx = %6d, %6.2f %6.2f %6.2f\n",
	     nunmapped,tvtx,v->x,v->y,v->z);
      continue;
    }
    
    /* update the number of hits and distance */
    MRIFseq_vox((*SrcHits),svtx,0,0,0) ++;
    MRIFseq_vox((*TrgHits),tvtx,0,0,0) ++;
    MRIFseq_vox((*SrcDist),svtx,0,0,0) += dmin;
    MRIFseq_vox((*TrgDist),tvtx,0,0,0) += dmin;

    /* accumulate mapped values for each frame */
    for(f=0; f < SrcSurfVals->nframes; f++)
      MRIFseq_vox(TrgSurfVals,tvtx,0,0,f) += 
	MRIFseq_vox(SrcSurfVals,svtx,0,0,f);
  }
  printf("\n");

  /*---------------------------------------------------------------
    Go through the reverse loop (finding closest trgvtx to each srcvtx
    unmapped by the forward loop). This assures that each source vertex
    is represented in the map */
  if(ReverseMapFlag){
    if(UseHash){
      MHTfree(&SrcHash);
      printf("surf2surf_nnfr: building target hash (res=16).\n");
      TrgHash = MHTfillVertexTableRes(TrgSurfReg, NULL,CURRENT_VERTICES,16);
    }
    printf("Surf2Surf: Reverse Loop (%d)\n",SrcSurfReg->nvertices);
    nrevhits = 0;
    for(svtx = 0; svtx < SrcSurfReg->nvertices; svtx++){
      if(MRIFseq_vox((*SrcHits),svtx,0,0,0) == 0){
	nrevhits ++;
	/* find closest target vertex */
	v = &(SrcSurfReg->vertices[svtx]);
	if(UseHash) tvtx = MHTfindClosestVertexNo(TrgHash,TrgSurfReg,v,&dmin);
	else  	  tvtx = MRISfindClosestVertex(TrgSurfReg,v->x,v->y,v->z);
	if(tvtx < 0) {/* this can only happen with MHT */
	  nunmapped ++;
	  printf("Unmapped: %3d svtx = %6d, %6.2f %6.2f %6.2f\n",
		 nunmapped,svtx,v->x,v->y,v->z);
	  continue;
	}
	/* update the number of hits and distance */
	MRIFseq_vox((*SrcHits),svtx,0,0,0) ++;
	MRIFseq_vox((*TrgHits),tvtx,0,0,0) ++;
	MRIFseq_vox((*SrcDist),svtx,0,0,0) += dmin;
	MRIFseq_vox((*TrgDist),tvtx,0,0,0) += dmin;
	/* accumulate mapped values for each frame */
	for(f=0; f < SrcSurfVals->nframes; f++)
	  MRIFseq_vox(TrgSurfVals,tvtx,0,0,f) += 
	    MRIFseq_vox(SrcSurfVals,svtx,0,0,f);
      }
    }
    if(UseHash)MHTfree(&TrgHash);
    printf("Reverse Loop had %d hits\n",nrevhits);
  }

  /*---------------------------------------------------------------
    Finally, divide the value at each target vertex by the number
    of source vertices mapping into it */
  printf("Surf2Surf: Dividing by number of hits (%d)\n",TrgSurfReg->nvertices);
  for(tvtx = 0; tvtx < TrgSurfReg->nvertices; tvtx++){
    n = MRIFseq_vox((*TrgHits),tvtx,0,0,0);
    if(n > 1) {
      MRIFseq_vox((*TrgDist),tvtx,0,0,0) /= n; /* average distances */
      for(f=0; f < SrcSurfVals->nframes; f++)
	MRIFseq_vox(TrgSurfVals,tvtx,0,0,f) /= n;
    }
  }
  /* go through the source loop to average the distance */
  nSrcLost = 0;
  for(svtx = 0; svtx < SrcSurfReg->nvertices; svtx++){
    n = MRIFseq_vox((*SrcHits),svtx,0,0,0);
    if(n == 1) continue;
    if(n > 1) MRIFseq_vox((*SrcDist),svtx,0,0,0) /= n;
    else{/* unmapped */
      MRIFseq_vox((*SrcDist),svtx,0,0,0) = -10; 
      nSrcLost ++;
    }
  }

  printf("INFO: nSrcLost = %d\n",nSrcLost);

  return(TrgSurfVals);
}

/*-------------------------------------------------------------
  crs2ind() -- returns linear index into a volume stored by column,
  row, slice.
  --------------------------------------------------------------------*/
int crs2ind(int *ind, int c, int r, int s, int ncols, int nrows, int nslcs )
{
  if(c < 0 || c >= ncols){
    fprintf(stderr,"crs2ind: col %d out of bounds (0,%d)\n",c,ncols-1);
    return(1);
  }
  if(r < 0 || r >= nrows){
    fprintf(stderr,"crs2ind: row %d out of bounds (0,%d)\n",r,nrows-1);
    return(1);
  }
  if(s < 0 || s >= nslcs){
    fprintf(stderr,"crs2ind: slc %d out of bounds (0,%d)\n",c,nslcs-1);
    return(1);
  }

  *ind = c + r * ncols + s * nrows*ncols ;

  return(0);
}
/*-------------------------------------------------------------
  ind2crs() -- returns the column, row, and slice of an element in a 
  volume given the index of the element in the volume assuming that
  the elements are stored by column, row, then slice.
  --------------------------------------------------------------------*/
int ind2crs(int *c, int *r, int *s, int ind, int ncols, int nrows, int nslcs)
{
  int i = ind, ntot, nrowcols;

  nrowcols = nrows*ncols;
  ntot = nrowcols*nslcs;
  if(i < 0 || i >= ntot){
    fprintf(stderr,"ind2crs: index %d out of bounds (0,%d)\n",i,ntot-1);
    return(1);
  }

  *s  = (int ) (i/nrowcols);
  i  = i - *s * (nrowcols);

  *r  = (int ) (i/ncols);
  i  = i - *r * ncols;

  *c  = (int ) i;

  return(0);
}
/*-------------------------------------------------------------*/
int MatrixFill(MATRIX *M, float val)
{
  int r,c;

  for(r=0;r < M->rows; r++){
    for(c=0; c < M->cols; c++){
      M->rptr[r+1][c+1] = val;
    }
  }
  return(0);
}
/*-------------------------------------------------------------*/
MATRIX * RandMatrix(int rows, int cols)
{
  int r,c;
  MATRIX *M;

  M = MatrixAlloc(rows, cols, MATRIX_REAL);

  for(r=0;r < M->rows; r++){
    for(c=0; c < M->cols; c++){
      M->rptr[r+1][c+1] = drand48();
    }
  }
  return(M);;
}
/*-------------------------------------------------------------*/
MATRIX * ConstMatrix(int rows, int cols, float val)
{
  int r,c;
  MATRIX *M;

  M = MatrixAlloc(rows, cols, MATRIX_REAL);

  for(r=0;r < M->rows; r++){
    for(c=0; c < M->cols; c++){
      M->rptr[r+1][c+1] = val;
    }
  }
  return(M);;
}

/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/
/*-------------------------------------------------------------------*/



#if 0
/* this is superceded by label2mask_linear() and vol2maskavg() */
/*------------------------------------------------------------*/
MRI *vol2roi_linear(MRI *SrcVol, 
		    MATRIX *Qsrc, MATRIX *Fsrc, MATRIX *Wsrc, MATRIX *Dsrc, 
		    MRI *SrcMskVol, MATRIX *Msrc2lbl, LABEL *Label, 
		    int float2int, int *nhits, MRI *FinalMskVol)
{
  MATRIX *QFWDsrc;
  MATRIX *Lxyz2Scrs;
  MATRIX *Scrs, *Lxyz, *Mlbl2src;
  MRI *ROI;
  int   irow_src, icol_src, islc_src; /* integer row, col, slc in source */
  float srcval, roival, mskval;
  int frm, vlbl;
  
  /* compute the transforms */
  QFWDsrc = ComputeQFWD(Qsrc,Fsrc,Wsrc,Dsrc,NULL);
  if(Msrc2lbl != NULL) Mlbl2src = MatrixInverse(Msrc2lbl,NULL);
  else                 Mlbl2src = NULL;
  if(Mlbl2src != NULL) Lxyz2Scrs = MatrixMultiply(QFWDsrc,Mlbl2src,NULL);    
  else                 Lxyz2Scrs = MatrixCopy(QFWDsrc,NULL);

  printf("\n");
  printf("Lxyz2Scrs:\n");
  MatrixPrint(stdout,Lxyz2Scrs);
  printf("\n");

  /* preallocate the row-col-slc vectors */
  Lxyz = MatrixAlloc(4,1,MATRIX_REAL);
  Lxyz->rptr[3+1][0+1] = 1.0;
  Scrs = MatrixAlloc(4,1,MATRIX_REAL);

  /* allocate an output "volume" */
  ROI = MRIallocSequence(1,1,1,MRI_FLOAT,SrcVol->nframes);
  if(ROI == NULL) return(NULL);
  
  *nhits = 0;
  
  for(vlbl = 0; vlbl < Label->n_points; vlbl++){
    
    Lxyz->rptr[0+1][0+1] = Label->lv[vlbl].x;
    Lxyz->rptr[1+1][0+1] = Label->lv[vlbl].y;
    Lxyz->rptr[2+1][0+1] = Label->lv[vlbl].z;
    
    MatrixMultiply(Lxyz2Scrs,Lxyz,Scrs);
    
    /* nearest neighbor */
    switch(float2int){
    case FLT2INT_ROUND:
      icol_src = (int)rint(Scrs->rptr[0+1][0+1]);
      irow_src = (int)rint(Scrs->rptr[1+1][0+1]);
      islc_src = (int)rint(Scrs->rptr[2+1][0+1]);
      break;
    case FLT2INT_FLOOR:
      icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
      irow_src = (int)floor(Scrs->rptr[1+1][0+1]);
      islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
      break;
    case FLT2INT_TKREG:
      icol_src = (int)floor(Scrs->rptr[0+1][0+1]);
      irow_src = (int) ceil(Scrs->rptr[1+1][0+1]);
      islc_src = (int)floor(Scrs->rptr[2+1][0+1]);
      break;
    default:
      fprintf(stderr,"vol2roi_linear(): unrecoginized float2int code %d\n",
	      float2int);
      MRIfree(&ROI);
      return(NULL);
      break;
    }
    
    if(irow_src < 0 || irow_src >= SrcVol->height ||
       icol_src < 0 || icol_src >= SrcVol->width  ||
       islc_src < 0 || islc_src >= SrcVol->depth ) continue;

    if(SrcMskVol != NULL){
      mskval = MRIFseq_vox(SrcMskVol,icol_src,irow_src,islc_src,0);
      if(mskval < 0.5) continue;
    }

    if(FinalMskVol != NULL){
      mskval = 10 + drand48();
      MRIFseq_vox(FinalMskVol,icol_src,irow_src,islc_src,0) = mskval;
    }

    (*nhits)++;
    for(frm = 0; frm < SrcVol->nframes; frm++){
      srcval = MRIFseq_vox(SrcVol,icol_src,irow_src,islc_src,frm);
      roival = MRIFseq_vox(ROI,0,0,0,frm);
      roival = roival + srcval;
      MRIFseq_vox(ROI,0,0,0,frm) = roival;
    }
  }

  fprintf(stderr,"INFO: vol2roi: there were %d hits\n", *nhits);

  /* divide by the number of hits */
  if( *nhits > 0){
    for(frm = 0; frm < SrcVol->nframes; frm++){
      roival = MRIFseq_vox(ROI,0,0,0,frm);
      roival = roival/(*nhits);
      MRIFseq_vox(ROI,0,0,0,frm) = roival;
    }
  }
  else{
    fprintf(stderr,"WARNING: vol2roi: no hits found\n");
  }

  MatrixFree(&QFWDsrc);
  MatrixFree(&Lxyz2Scrs);
  MatrixFree(&Scrs);
  MatrixFree(&Lxyz);
  if(Mlbl2src != NULL) MatrixFree(&Mlbl2src);

  printf("vol2roi_linear: done\n");

  return(ROI);  
}
#endif

#if 0
/* -------------------------------------------------------------------- 
   ComputeVolNNbrsOfVol() - for each voxel index in Vol1, computes the 
   nearest neighbor in Vol2 based on the matrix Pv1tov2. Pv1tov2 converts 
   CRS in volume 1 to CRS in volume 1 (CRS = col, row, slice). The result
   is a list whose length equals the number of voxels in Vol1. The nth value
   in the list is the index of the voxel in Vol2 that is closest to the
   nth voxel in Vol1.  The index of a voxel is the location of that voxel 
   when all the voxels are arranged linearly by col, row, slice.

   Because the mapping is nearest-neighbor, the result could have been returned
   in a vector of ints. However, for compatibility with multiple-neighbor maps,
   the result is returned in a Ragged Array (see raggedarray.c)
   -------------------------------------------------------------------- */
RAGGEDARRAY * 
ComputeVolNNbrsOfVol(int nrows1, int ncols1, int nslcs1, 
		     int nrows2, int ncols2, int nslcs2, 
		     MATRIX *Pv1tov2)
{
  RAGGEDARRAY * NbrMap;
  int r1,c1,s1,volindex1,nvoxs1;
  int r2,c2,s2,volindex2;
  MATRIX *crs1, *crs2;

  crs1 = MatrixAlloc(4,1,MATRIX_REAL); /* row, col, slice */
  crs2 = MatrixAlloc(4,1,MATRIX_REAL); /* row, col, slice */

  /* Total number of voxels in volume 1 */
  nvoxs1 = nrows1*ncols1*nslcs1;

  /* Allocate a Neighbor Map using a Ragged Array (see raggedarray.c).*/
  NbrMap = ra_alloc(nvoxs1,RAGRAY_INT);
  if(NbrMap == NULL) return(NULL);

  /* Go through all voxels in volume 1 */
  for(s1=0; s1<nslcs1; s1++){
    for(r1=0; r1<nrows1; r1++){
      for(c1=0; c1<ncols1; c1++){

	/* Compute the linear index for c1,r1,s1 */
	crs2ind(&volindex1,c1,r1,s1,ncols1,nrows1,nslcs1);

	/* Load a vector with col, row, and slice of volume 1 */
	crs1->rptr[0+1][0+1] = c1;
	crs1->rptr[1+1][0+1] = r1;
	crs1->rptr[2+1][0+1] = s1;

	/* Compute the corresponding col, row, and slice of volume 2 */
	MatrixMultiply(Pv1tov2,crs1,crs2); /* crs2 = Pv1tov2 * crs1 */

	/* Unload col, row, and slice of volume 2 from vector */
	/* (Truncation is used for historical purposes) */
	c2 = (int)rint(crs2->rptr[0+1][0+1]);
	r2 = (int)rint(crs2->rptr[1+1][0+1]);
	s2 = (int)rint(crs2->rptr[2+1][0+1]);

	/* Make sure that the voxel is in bounds of volume 2 */
	if(c2 < 0 || c2 >= ncols2 || r2 < 0 || r2 >= nrows2 || 
	   s2 < 0 || s2 >= nslcs2){
	  /*printf("%5d  %7.3f %7.3f %7.3f\n",volindex1,
		 crs2->rptr[0+1][0+1],crs2->rptr[0+1][1+1],
		 crs2->rptr[2+1][0+1]);*/
	  continue;
	}

	/* Compute the linear index for c2,r2,s2 */
	crs2ind(&volindex2,c2,r2,s2,ncols2,nrows2,nslcs2);

	/* volindex1 and volindex2 are now a pair */
	/* Add pair to map */
	ra_ivalappend(volindex2,NbrMap,volindex1);

      }
    }
  }

  MatrixFree(&crs1);
  MatrixFree(&crs2);

  return(NbrMap);
}

/* -------------------------------------------------------------------- 
   ComputeVolNNbrsOfSurf() - for each vertex in the Surface, computes the 
   nearest neighbor in a Volume of size ncols, nrows, nslices based on
   the matrix Qs2v. Qs2v  converts an x,y,z in Surface space to column, row,
   and slice in the volume (crs = Qs2v * xyz).

   The result is a list whose length equals the number of verticies in the 
   surface. The nth value in the list is the index of the voxel in the Volume 
   that  is closest to the nth vertex on the Surface.  The index of a voxel is 
   the location of that voxel when all the voxels are arranged linearly by col, row, 
   slice.

   Because the mapping is nearest-neighbor, the result could have been returned
   in a vector of ints. However, for compatibility with multiple-neighbor maps,
   the result is returned in a Ragged Array (see raggedarray.c)

   projfrac: allows the x,y,z of a vertex to be recomputed by projecting along
   the surface-normal a distance equal to projfrac*thickness. projfrac is
   intended to be between 0 and 1, which 0 being no change in the vertex xyz, and 
   1 being projection to the other side of cortex.

   Historically, this mapping is used for "painting", and Qs2v = Qf*R, where
   R is the registration matrix and Qf is the functional quantization matrix
   (see FOVQuantMatrix()).
   -------------------------------------------------------------------- */
RAGGEDARRAY * 
ComputeVolNNbrsOfSurf(MRI_SURFACE *surf, 
		      int nrows, int ncols, int nslcs, 
		      MATRIX *Qs2v, float projfrac)
{
  RAGGEDARRAY * NbrMap;
  int r,c,s,volindex,vtx;
  float x,y,z;
  MATRIX *xyz, *crs;

  /* Allocate a Neighbor Map using a Ragged Array (see raggedarray.c).*/
  NbrMap = ra_alloc(surf->nvertices,RAGRAY_INT);
  if(NbrMap == NULL) return(NULL);

  /* Create vectors for (surf) xyz and (vol) crs*/
  xyz = MatrixAlloc(4,1,MATRIX_REAL);
  xyz->rptr[3+1][0+1] = 1.0;
  crs = MatrixAlloc(4,1,MATRIX_REAL); /* row, col, slice */

  /*-----------------------------------------------*/
  for(vtx = 0; vtx < surf->nvertices; vtx ++){

    /* Get the xyz of the vertex as projected along the normal a
       distance equal to a fraction of the cortical thickness at
       that point. */
    ProjNormFracThick(&x,&y,&z,surf,vtx,projfrac);

    /* load vertex xyz values into a vector */
    xyz->rptr[0+1][0+1] = x;
    xyz->rptr[1+1][0+1] = y;
    xyz->rptr[2+1][0+1] = z;

    /* compute the floating row, col, and slice */
    MatrixMultiply(Qs2v,xyz,crs); /* crs = Qs2v * xyz */

    /* Unload col, row, and slice of volume from vector */
    /* (Truncation is used for historical purposes) */
    c = (int)(floor(crs->rptr[0+1][0+1]));
    r = (int)(floor(crs->rptr[1+1][0+1]));
    s = (int)(floor(crs->rptr[2+1][0+1]));

    /* check for out-of-bounds */
    if(c < 0 || c >= ncols || r < 0 || r >= nrows || 
       s < 0 || s >= nslcs) continue;

    /* compute the volume index corresponding to the row, col, and slice */
    crs2ind(&volindex,c,r,s,nrows,ncols,nslcs);

    if(vtx < 10){
      printf("%d   %6.2f %6.2f %6.2f   %6.2f %6.2f %6.2f  %3d %3d %3d  %d\n",vtx,
	     x,y,z,crs->rptr[0+1][0+1],crs->rptr[1+1][0+1],
	     crs->rptr[2+1][0+1],  c,r,s,volindex);
    }

    /* vtx and volumeindex are now a pair */
    /* Add pair to the map */
    ra_ivalappend(volindex,NbrMap,vtx);

  }
  /*-----------------------------------------------*/

  MatrixFree(&xyz);
  MatrixFree(&crs);

  return(NbrMap);
}
#endif
#if 0
/*------------------------------------------------------
  resample()
  A: Na X nfrms
  B: Nb X nfrms
  A2B: Nb X nNeighbors
  ------------------------------------------------------*/
MATRIX * resample_nbrmean(MATRIX *A, RAGRAY *A2B)
{
  MATRIX *B;
  int nfrms, Na, Nb, amax;
  int tmp1, tmp2, err;
  int a,b,c,f;

  Na    = A->rows;
  nfrms = A->cols;
  Nb    = A2B->nrows;

  /* check that A2B values are within bounds of A */
  amax  = ra_ivalmax(A2B, &tmp1, &tmp2, &err);
  if(amax >= Na){
    fprintf(stderr,"A2B value at (%d,%d) = %d > Na=%d\n",
	    tmp1,tmp2,amax,Na);
    return(NULL);
  }

  B = MatrixAlloc(Nb, nfrms, MATRIX_REAL );
  MatrixClear( B );

  for(b=0;b<Nb;b++){
    for(f=0; f < nfrms; f++){
      B->rptr[b+1][f+1] = 0.0;
      if(A2B->ncols[b] > 0){
	for(c = 0; c < A2B->ncols[b]; c++){
	  a = A2B->irptr[b][c];
	  B->rptr[b+1][f+1] += A->rptr[a+1][f+1];
	}
	B->rptr[b+1][f+1] /= A2B->ncols[b];
      }
      else B->rptr[b+1][f+1] = 0.0;
    }
  }

  return(B);
}
#endif


#if 0
2/4/01
This is replaced by surf2surf_nnfr with the ReverseMapFlag=0.
/*----------------------------------------------------------------
  MRI *surf2surf_nnf() - resample values on one surface to another
  using nearest-neighbor, forward only (nnf) method.
----------------------------------------------------------------*/
MRI *surf2surf_nnf(MRI *SrcSurfVals, MRI_SURFACE *SrcSurfReg, 
		   MRI_SURFACE *TrgSurfReg, int UseHash)
{
  MRI *TrgSurfVals = NULL;
  int svtx, tvtx, f, nunmapped;
  VERTEX *v;
  MHT *SrcHash;
  float dmin;

  if(SrcSurfVals->width != SrcSurfReg->nvertices){
    fprintf(stderr,"surf2surf_nnf(): Vals and Reg dimension mismatch\n");
    fprintf(stderr,"nVals = %d, nReg %d\n",SrcSurfVals->width,
	    SrcSurfReg->nvertices);
    return(NULL);
  }

  /* allocate a "volume" to hold the output */
  TrgSurfVals = MRIallocSequence(TrgSurfReg->nvertices,1,1,
				 MRI_FLOAT,SrcSurfVals->nframes);
  if(TrgSurfVals == NULL) return(NULL);

  /* build hash tables */
  if(UseHash){
    printf("surf2surf_nnf: building source hash (res=16).\n");
    SrcHash = MHTfillVertexTableRes(SrcSurfReg, NULL,CURRENT_VERTICES,16);
  }

  /*---------------------------------------------------------------
    Go through the forward loop (finding closest srcvtx to each trgvtx).
    This maps each target vertex to a source vertex */
  printf("Surf2Surf: Forward Loop (%d)\n",TrgSurfReg->nvertices);
  nunmapped = 0;
  for(tvtx = 0; tvtx < TrgSurfReg->nvertices; tvtx++){
    if(!UseHash){
      if(tvtx%100 == 0) {printf("%5d ",tvtx);fflush(stdout);}
      if(tvtx%1000 == 999){printf("\n");fflush(stdout);}
    }

    /* find closest source vertex */
    v = &(TrgSurfReg->vertices[tvtx]);
    if(UseHash) svtx = MHTfindClosestVertexNo(SrcHash,SrcSurfReg,v,&dmin);
    else        svtx = MRISfindClosestVertex(SrcSurfReg,v->x,v->y,v->z);

    if(svtx < 0) {/* this can only happen with MHT */
      nunmapped ++;
      printf("Unmapped: %3d tvtx = %6d, %6.2f %6.2f %6.2f\n",
	     nunmapped,tvtx,v->x,v->y,v->z);
      continue;
    }

    /* accumulate mapped values for each frame */
    for(f=0; f < SrcSurfVals->nframes; f++)
      MRIFseq_vox(TrgSurfVals,tvtx,0,0,f) += MRIFseq_vox(SrcSurfVals,svtx,0,0,f);

    if(tvtx == 22232){
      printf("dmin = %g\n",dmin);
      printf("tvtx = %6d, %6.2f %6.2f %6.2f %g\n",tvtx,v->x,v->y,v->z,
	     MRIFseq_vox(TrgSurfVals,tvtx,0,0,0));
      v = &(SrcSurfReg->vertices[tvtx]);
      printf("svtx = %6d, %6.2f %6.2f %6.2f %g\n",svtx,v->x,v->y,v->z,
	     MRIFseq_vox(SrcSurfVals,svtx,0,0,0));

    }
  }
  printf("\n");

  /* no reverse loop */
  /* no need to divide by the number of source vertices because
     each target can only map to one source */

  return(TrgSurfVals);
}

#endif
