#include "registration/HistoTransform.h"
#include <sbl/core/Command.h>
#include <sbl/core/PathConfig.h>
#include <sbl/math/MathUtil.h>
#include <sbl/system/FileSystem.h>
#include <sbl/image/ImageUtil.h>
#include <sbl/image/MotionFieldUtil.h>
#include <sbl/image/ImageDraw.h>
using namespace sbl;
namespace hb {


//-------------------------------------------
// HISTO TRANSFORM CLASS
//-------------------------------------------


/// load transformation data generated by the registration commands
bool HistoTransform::load( const String &mrRawPath, const String &mrRegLinPath, 
						   const String &mrRegPath, const String &histoSplitPath, const String &histoRegPath ) {

	// load block offset
	// blockOffset is index of blockface image corresponding to slice #1 (not necessarily the first histology image)
	String fileName = histoRegPath + "/blockOffset.txt";
	File blockOffsetFile( fileName, FILE_READ, FILE_TEXT );
	if (blockOffsetFile.openSuccess()) {
		m_blockOffset = blockOffsetFile.readInt();
	} else {
		warning( "unable to read block offset file: %s", fileName.c_str() );
		return false;
	}
	disp( 1, "blockOffset: %d", m_blockOffset );

	// load histology motion fields
	Array<String> mfFileList = dirFileList( histoRegPath, "flow_", ".mf" );
	if (mfFileList.count() == 0) {
		warning( "unable to find histo motion field files at: %s", histoRegPath.c_str() );
		return false;
	}
	for (int i = 0; i < mfFileList.count(); i++) {
		String fileName = histoRegPath + "/" + mfFileList[ i ];
		aptr<MotionField> mf = loadMotionField( fileName );
		int mfWidth = mf->width(), mfHeight = mf->height();
		m_mfHisto.append( mf.release() );
		int sliceIndex = mfFileList[ i ].rightOfLast( '_' ).leftOfLast( '.' ).toInt();
		m_histoSliceIndex.append( sliceIndex );

		// load the full-size histo image (after split)
		fileName = histoSplitPath + sprintF( "/%d.png", sliceIndex );
		aptr<ImageGrayU> image = sbl::load<ImageGrayU>( fileName ); // fix(faster): we could get the image dimensions without loading the entire image
		int width = image->width(), height = image->height();
		m_histoShrinkX.append( (double) mfWidth / (double) width );
		m_histoShrinkY.append( (double) mfHeight / (double) height );
	}

	// load linear volume transform
	disp( 1, "loading linear volume transform" );
	String regLinTransformFileName = mrRegLinPath + "/linearTransform.txt";
	File regLinTransformFile( regLinTransformFileName, FILE_READ, FILE_TEXT );
	if (regLinTransformFile.openSuccess()) {
		m_regLinTransform = loadTransform( regLinTransformFile );
	} else {
		warning( "unable to open transform file: %s", regLinTransformFileName.c_str() );
		return false;
	}

	// load non-linear volume transform
	String cfSeqFileName = mrRegPath + "/cfSeq.cfs";
	m_cfSeq = loadCorresSeq( cfSeqFileName );
	if (m_cfSeq.count() == 0) {
		warning( "unable to open corres volume file: %s", cfSeqFileName.c_str() );
		return false;
	}

	// load MR file transform
	disp( 1, "loading MR file transform" );
	String mrTransformFileName = mrRawPath + "/volumeTransform.txt";
	File mrTransformFile( mrTransformFileName, FILE_READ, FILE_TEXT );
	if (mrTransformFile.openSuccess()) {
		m_mrTransform = loadTransform( mrTransformFile );
	} else {
		warning( "unable to open MR transform file: %s", mrTransformFileName.c_str() );
		return false;
	}
	return true;
}


/// compute inverses of mappings; this must be called before projectBackward()
void HistoTransform::computeInverses() {
	disp( 1, "computing inverses" );

	// compute inverse of MR file transform
	m_mrTransformInv = m_mrTransform.inverse();

	// compute inverse of linear volume registration transform
	m_regLinTransformInv = m_regLinTransform.inverse();

	// compute inverse of non-linear volume transform
	m_cfSeqInv = invert( m_cfSeq );

	// computer inverse of non-linear slice transforms
	for (int i = 0; i < m_mfHisto.count(); i++) {
		int width = m_mfHisto[ i ].width(), height = m_mfHisto[ i ].height();
		float uMin = 0, uMean = 0, uMax = 0, vMin = 0, vMean = 0, vMax = 0;
		motionFieldStats( m_mfHisto[ i ], uMin, vMin, uMean, vMean, uMax, vMax );
		disp( 1, "%d of %d, %5.3f / %5.3f / %5.3f, %5.3f / %5.3f / %5.3f", i, m_mfHisto.count(), uMin, uMean, uMax, vMin, vMean, vMax );
		ImageGrayU mask( width, height );
		mask.clear( 255 );
		int sampleStep = 4;
		aptr<MotionField> mfInv = invertMotionField( m_mfHisto[ i ], mask, sampleStep );
		motionFieldStats( *mfInv, uMin, vMin, uMean, vMean, uMax, vMax );
		m_mfHistoInv.append( mfInv.release() );
		disp( 1, "%d of %d, %5.3f / %5.3f / %5.3f, %5.3f / %5.3f / %5.3f", i, m_mfHisto.count(), uMin, uMean, uMax, vMin, vMean, vMax );
	}
	disp( 1, "done computing inverses" );
}


/// project a point from histology coordinates to MR coordinates
Point3 HistoTransform::projectForward( Point3 point, bool smallHistoCoords, bool verbose ) const {
	if (verbose) disp( 1, "init: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// get histo index
	int mfIndex = findHistoIndex( sbl::round( point.z ) );
	if (mfIndex == -1) {
		warning( "unable to find flow for histo index: %d", sbl::round( point.z ) );
		point.x = 0;
		point.y = 0;
		point.z = 0; 
		return point;
	}

	// shrink x, y coordinates to block-face size
	if (smallHistoCoords == false) {
		point.x *= m_histoShrinkX[ mfIndex ];
		point.y *= m_histoShrinkY[ mfIndex ];
	}
	if (verbose) disp( 1, "after histo shrink: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// map according to flow
	const MotionField &mf = m_mfHisto[ mfIndex ];
	if (mf.inBounds( (float) point.x, (float) point.y ) == false) {
		warning( "projected out of motion field: %f, %f", point.x, point.y );
		point.x = 0;
		point.y = 0;
		point.z = 0; 
		return point;
	}
	float u = mf.uInterp( (float) point.x, (float) point.y );
	float v = mf.vInterp( (float) point.x, (float) point.y );
	point.x += u;
	point.y += v;
	if (verbose) disp( 1, "after mf: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// map z coord
	point.z = m_histoSliceIndex[ mfIndex ] + m_blockOffset;
	if (verbose) disp( 1, "after block offset: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// apply non-linear volume mapping
	int xInt = round( (float) point.x );
	int yInt = round( (float) point.y );
	int zInt = round( (float) point.z );
	int cfWidth = m_cfSeq[ 0 ].width(), cfHeight = m_cfSeq[ 0 ].height();
	if (xInt < 0 || xInt >= cfWidth || yInt < 0 || yInt >= cfHeight || zInt < 0 || zInt >= m_cfSeq.count()) {
		warning( "projected out of corres volume: %d, %d, %d", xInt, yInt, zInt );
		point.x = 0;
		point.y = 0;
		point.z = 0; 
		return point;
	}
	point.x += m_cfSeq[ zInt ].u( xInt, yInt );
	point.y += m_cfSeq[ zInt ].v( xInt, yInt );
	point.z += m_cfSeq[ zInt ].w( xInt, yInt );
	if (verbose) disp( 1, "after reg non-lin: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// apply linear transform
	point = m_regLinTransform.transform( point );
	if (verbose) disp( 1, "after reg lin: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// apply MR transform
	point = m_mrTransform.transform( point );
	if (verbose) disp( 1, "after MR: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );
	return point;
}


/// project a point from MR coordinates to histology coordinates
Point3 HistoTransform::projectBackward( Point3 point, bool smallHistoCoords, bool verbose ) const {
	if (verbose) disp( 1, "init: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// apply MR transform
	point = m_mrTransformInv.transform( point );
	if (verbose) disp( 1, "after MR inv: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// apply linear transform
	point = m_regLinTransformInv.transform( point );
	if (verbose) disp( 1, "after reg lin: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// apply non-linear field
	int xInt = round( (float) point.x );
	int yInt = round( (float) point.y );
	int zInt = round( (float) point.z );
	int cfWidth = m_cfSeq[ 0 ].width(), cfHeight = m_cfSeq[ 0 ].height();
	if (xInt < 0 || xInt >= cfWidth || yInt < 0 || yInt >= cfHeight || zInt < 0 || zInt >= m_cfSeq.count()) {
		warning( "projected out of corres volume: %d, %d, %d", xInt, yInt, zInt );
		point.x = 0;
		point.y = 0;
		point.z = 0; 
		return point;
	}
	point.x += m_cfSeqInv[ zInt ].u( xInt, yInt );
	point.y += m_cfSeqInv[ zInt ].v( xInt, yInt );
	point.z += m_cfSeqInv[ zInt ].w( xInt, yInt );
	if (verbose) disp( 1, "after reg non-lin: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// map z coord
	point.z = point.z - m_blockOffset;
	if (verbose) disp( 1, "after block offset: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// map according to flow
	int mfIndex = findHistoIndex( sbl::round( point.z ) );
	if (mfIndex == -1) {
		warning( "unable to find flow for histo index: %d", sbl::round( point.z ) );
		point.x = 0;
		point.y = 0;
		point.z = 0; 
		return point;
	}	
	const MotionField &mfInv = m_mfHistoInv[ mfIndex ];
	if (mfInv.inBounds( (float) point.x, (float) point.y ) == false) {
		warning( "projected out of motion field: %f, %f", point.x, point.y );
		point.x = 0;
		point.y = 0;
		point.z = 0; 
		return point;
	}
	float u = mfInv.uInterp( (float) point.x, (float) point.y );
	float v = mfInv.vInterp( (float) point.x, (float) point.y );
	point.x += u;
	point.y += v;	
	if (verbose) disp( 1, "after mf inv: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );

	// expand x, y coordinates from block-face size to histo size
	if (smallHistoCoords == false) {
		point.x /= m_histoShrinkX[ mfIndex ];
		point.y /= m_histoShrinkY[ mfIndex ];
	}
	if (verbose) disp( 1, "after histo unshrink: %3.1f, %3.1f, %3.1f", point.x, point.y, point.z );
	return point;
}


// find the index within the motion field array corresponding to the given slice index
int HistoTransform::findHistoIndex( int z ) const {
	int mfIndex = -1;
	for (int i = 0; i < m_histoSliceIndex.length(); i++) {
		if (m_histoSliceIndex[ i ] == z) 
			mfIndex = i;
	}
	return mfIndex;
}


//-------------------------------------------
// COMMANDS
//-------------------------------------------


/// project a set of points from histology coordinates to MR coordinates or vice versa
void projectPoints( Config &conf ) {

	// get command parameters
	String inputFileName = addDataPath( conf.readString( "inputFileName" ) );
	String outputFileName = addDataPath( conf.readString( "outputFileName" ) );
	bool projectForward = conf.readBool( "projectForward", true );
	bool smallHistoCoords = conf.readBool( "smallHistoCoords", false ); // true if using post-hprep coordinates
	String mrRawPath = addDataPath( conf.readString( "mrRawPath", "mri/rawFlash20" ) );
	String mrRegLinPath = addDataPath( conf.readString( "mrRegLinPath", "mri/regLin" ) );
	String mrRegPath = addDataPath( conf.readString( "mrRegPath", "mri/reg" ) );
	String histoSplitPath = addDataPath( conf.readString( "histoSplitPath" "histo/split" ) );
	String histoRegPath = addDataPath( conf.readString( "histoRegPath" "histo/reg" ) );

	// open input file 
	File inputFile( inputFileName, FILE_READ, FILE_TEXT );
	if (inputFile.openSuccess() == false) {
		warning( "error reading input file: %s", inputFileName.c_str() );
		return;
	}

	// open output file
	File outputFile( outputFileName, FILE_WRITE, FILE_TEXT );
	if (outputFile.openSuccess() == false) {
		warning( "error opening output file: %s", outputFileName.c_str() );
		return;
	}

	// load transformation data
	HistoTransform histoTransform;
	if (histoTransform.load( mrRawPath, mrRegLinPath, mrRegPath, histoSplitPath, histoRegPath ) == false) {
		return; // don't need to print warning; loadTransform will do that
	}

	// loop over input points, projecting each one
	while (inputFile.endOfFile() == false) {

		// read input point
		String inputLine = inputFile.readLine();
		Array<String> inputSplit = inputLine.split( "," );
		if (inputSplit.count()) {
			if (inputSplit.count() != 3) {
				warning( "invalid line: %s (expect 3 numbers separated by commas)", inputLine.c_str() );
			}
			Point3 point;
			point.x = inputSplit[ 0 ].strip().toFloat();
			point.y = inputSplit[ 1 ].strip().toFloat();
			point.z = inputSplit[ 2 ].strip().toFloat();

			// project histo coord to MR coord
			if (projectForward) {
				point = histoTransform.projectForward( point, smallHistoCoords, false );

			// project MR coord to histo coord
			} else {
				point = histoTransform.projectBackward( point, smallHistoCoords, false );
			}

			// write output line
			outputFile.writeF( "%f,%f,%f\n", point.x, point.y, point.z );
		}

		// check for user cancel
		if (checkCommandEvents())
			break;
	}
}


/// test histo-to-MR-to-histo coordinate projection using assorted points from the histology slices
void testProjectPoints( Config &conf ) {

	// get command parameters
	String mrRawPath = addDataPath( conf.readString( "mrRawPath", "mri/rawFlash20" ) );
	String mrRegLinPath = addDataPath( conf.readString( "mrRegLinPath", "mri/regLin" ) );
	String mrRegPath = addDataPath( conf.readString( "mrRegPath", "mri/reg" ) );
	String histoSplitPath = addDataPath( conf.readString( "histoSplitPath", "histo/split" ) );
	String histoRegPath = addDataPath( conf.readString( "histoRegPath", "histo/reg" ) );
	String outputPath = addDataPath( conf.readString( "outputPath", "histo/proj" ) );
	int step = conf.readInt( "step", 100 );
	bool verbose = conf.readBool( "verbose", true );

	// load transformation data
	HistoTransform histoTransform;
	if (histoTransform.load( mrRawPath, mrRegLinPath, mrRegPath, histoSplitPath, histoRegPath ) == false) {
		return; // don't need to print warning; loadTransform will do that
	}
	histoTransform.computeInverses();

	// check for user cancel
	if (checkCommandEvents())
		return;

	// get list of input (post-prep) histo images
	Array<String> fileList = dirFileList( histoSplitPath, "", ".png" );
	if (fileList.count() == 0) {
		warning( "unable to find histo motion field files at: %s", histoSplitPath.c_str() );
		return;
	}
	
	// make sure output path exists
	createDir( outputPath );

	// loop over histo images
	VectorD allError;
	int badCount = 0;
	for (int i = 0; i < fileList.count(); i++) {

		// load the histo image and compute a mask 
		String fileName = histoSplitPath + "/" + fileList[ i ];
		aptr<ImageGrayU> image = load<ImageGrayU>( fileName );
		int hWidth = image->width(), hHeight = image->height();
		aptr<ImageGrayU> mask = threshold( *image, 254, true );
		int hSliceIndex = fileList[ i ].leftOfLast( '.' ).toInt();

		// we will save diagnostic images for the middle histo image 
		aptr<ImageColorU> histoMarkers;
		if (i == fileList.count() / 2)
			histoMarkers = toColor( *image );

		// loop over image, checking points in mask
		VectorD sliceError;
		for (int y = 0; y < hHeight; y += step) {
			for (int x = 0; x < hWidth; x += step) {
				if (mask->data( x, y )) {
					Point3 point;
					point.x = x;
					point.y = y;
					point.z = hSliceIndex;
					Point3 forPoint = histoTransform.projectForward( point, false, verbose );
					if (forPoint.x == 0 && forPoint.y == 0 && forPoint.z == 0) {
						badCount++;
						continue;
					}
					Point3 backPoint = histoTransform.projectBackward( forPoint, false, verbose );
					if (backPoint.x == 0 && backPoint.y == 0 && backPoint.z == 0) {
						badCount++;
						continue;
					}
					double xDiff = point.x - backPoint.x;
					double yDiff = point.y - backPoint.y;
					double zDiff = point.z - backPoint.z;
					double err = sqrt( xDiff * xDiff + yDiff * yDiff + zDiff * zDiff );
					sliceError.append( err );
					allError.append( err );
					if (histoMarkers.get()) {
						drawCross( *histoMarkers, x, y, 10, 255, 0, 0, true );
					}
				}
			}
		}
		disp( 1, "slice: %d, error: %f / %f / %f", hSliceIndex, sliceError.min(), sliceError.mean(), sliceError.max() );

		// save diagnostic images
		if (histoMarkers.get()) {
			saveImage( *histoMarkers, outputPath + "/histoMarkers.png" );
		}

		// check for user cancel
		if (checkCommandEvents())
			break;
	}
	disp( 1, "error: %f / %f / %f", allError.min(), allError.mean(), allError.max() );
	disp( 1, "bad count: %d", badCount );
}


//-------------------------------------------
// INIT / CLEAN-UP
//-------------------------------------------


// register commands, etc. defined in this module
void initHistoTransform() {
	registerCommand( "hproj", projectPoints );
	registerCommand( "hprojtest", testProjectPoints );
}


} // end namespace hb
