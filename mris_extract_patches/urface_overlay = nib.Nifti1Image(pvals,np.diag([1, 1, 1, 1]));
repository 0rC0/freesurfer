Help on module nibabel.nifti1 in nibabel:

NNAAMMEE
    nibabel.nifti1 - Read / write access to NIfTI1 image format

FFIILLEE
    /homes/4/fischl/links/git/annaconda/lib/python2.7/site-packages/nibabel/nifti1.py

DDEESSCCRRIIPPTTIIOONN
    NIfTI1 format defined at http://nifti.nimh.nih.gov/nifti-1/

CCLLAASSSSEESS
    __builtin__.list(__builtin__.object)
        Nifti1Extensions
    __builtin__.object
        Nifti1Extension
            Nifti1DicomExtension
    nibabel.analyze.AnalyzeImage(nibabel.spatialimages.SpatialImage)
        Nifti1Pair
            Nifti1Image
    nibabel.spm99analyze.SpmAnalyzeHeader(nibabel.analyze.AnalyzeHeader)
        Nifti1Header
            Nifti1PairHeader
    
    class NNiiffttii11DDiiccoommEExxtteennssiioonn(Nifti1Extension)
     |  NIfTI1 DICOM header extension
     |  
     |  This class is a thin wrapper around pydicom to read a binary DICOM
     |  byte string. If pydicom is available, content is exposed as a Dicom Dataset.
     |  Otherwise, this silently falls back to the standard NiftiExtension class
     |  and content is the raw bytestring loaded directly from the nifti file
     |  header.
     |  
     |  Method resolution order:
     |      Nifti1DicomExtension
     |      Nifti1Extension
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  ____iinniitt____(self, code, content, parent_hdr=None)
     |      Parameters
     |      ----------
     |      code : int or str
     |        Canonical extension code as defined in the NIfTI standard, given
     |        either as integer or corresponding label
     |        (see :data:`~nibabel.nifti1.extension_codes`)
     |      content : bytes or pydicom Dataset or None
     |        Extension content - either a bytestring as read from the NIfTI file
     |        header or an existing pydicom Dataset. If a bystestring, the content
     |        is converted into a Dataset on initialization. If None, a new empty
     |        Dataset is created.
     |      parent_hdr : :class:`~nibabel.nifti1.Nifti1Header`, optional
     |        If a dicom extension belongs to an existing
     |        :class:`~nibabel.nifti1.Nifti1Header`, it may be provided here to
     |        ensure that the DICOM dataset is written with correctly corresponding
     |        endianness; otherwise it is assumed the dataset is little endian.
     |      
     |      Notes
     |      -----
     |      
     |      code should always be 2 for DICOM.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Extension:
     |  
     |  ____eeqq____(self, other)
     |  
     |  ____nnee____(self, other)
     |  
     |  ____rreepprr____(self)
     |  
     |  ggeett__ccooddee(self)
     |      Return the canonical extension type code.
     |  
     |  ggeett__ccoonntteenntt(self)
     |      Return the extension content in its runtime representation.
     |  
     |  ggeett__ssiizzeeoonnddiisskk(self)
     |      Return the size of the extension in the NIfTI file.
     |  
     |  wwrriittee__ttoo(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Nifti1Extension:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
    
    class NNiiffttii11EExxtteennssiioonn(__builtin__.object)
     |  Baseclass for NIfTI1 header extensions.
     |  
     |  This class is sufficient to handle very simple text-based extensions, such
     |  as `comment`. More sophisticated extensions should/will be supported by
     |  dedicated subclasses.
     |  
     |  Methods defined here:
     |  
     |  ____eeqq____(self, other)
     |  
     |  ____iinniitt____(self, code, content)
     |      Parameters
     |      ----------
     |      code : int or str
     |        Canonical extension code as defined in the NIfTI standard, given
     |        either as integer or corresponding label
     |        (see :data:`~nibabel.nifti1.extension_codes`)
     |      content : str
     |        Extension content as read from the NIfTI file header. This content is
     |        converted into a runtime representation.
     |  
     |  ____nnee____(self, other)
     |  
     |  ____rreepprr____(self)
     |  
     |  ggeett__ccooddee(self)
     |      Return the canonical extension type code.
     |  
     |  ggeett__ccoonntteenntt(self)
     |      Return the extension content in its runtime representation.
     |  
     |  ggeett__ssiizzeeoonnddiisskk(self)
     |      Return the size of the extension in the NIfTI file.
     |  
     |  wwrriittee__ttoo(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
    
    class NNiiffttii11EExxtteennssiioonnss(__builtin__.list)
     |  Simple extension collection, implemented as a list-subclass.
     |  
     |  Method resolution order:
     |      Nifti1Extensions
     |      __builtin__.list
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  ____ccmmpp____(self, other)
     |  
     |  ____rreepprr____(self)
     |  
     |  ccoouunntt(self, ecode)
     |      Returns the number of extensions matching a given *ecode*.
     |      
     |      Parameters
     |      ----------
     |      code : int | str
     |          The ecode can be specified either literal or as numerical value.
     |  
     |  ggeett__ccooddeess(self)
     |      Return a list of the extension code of all available extensions
     |  
     |  ggeett__ssiizzeeoonnddiisskk(self)
     |      Return the size of the complete header extensions in the NIfTI file.
     |  
     |  wwrriittee__ttoo(self, fileobj, byteswap)
     |      Write header extensions to fileobj
     |      
     |      Write starts at fileobj current file position.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |         Should implement ``write`` method
     |      byteswap : boolean
     |        Flag if byteswapping the data is required.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  ffrroomm__ffiilleeoobbjj(klass, fileobj, size, byteswap) from __builtin__.type
     |      Read header extensions from a fileobj
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like object
     |          We begin reading the extensions at the current file position
     |      size : int
     |          Number of bytes to read. If negative, fileobj will be read till its
     |          end.
     |      byteswap : boolean
     |          Flag if byteswapping the read data is required.
     |      
     |      Returns
     |      -------
     |      An extension list. This list might be empty in case not extensions
     |      were present in fileobj.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from __builtin__.list:
     |  
     |  ____aadddd____(...)
     |      x.__add__(y) <==> x+y
     |  
     |  ____ccoonnttaaiinnss____(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  ____ddeelliitteemm____(...)
     |      x.__delitem__(y) <==> del x[y]
     |  
     |  ____ddeellsslliiccee____(...)
     |      x.__delslice__(i, j) <==> del x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  ____eeqq____(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  ____ggee____(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  ____ggeettaattttrriibbuuttee____(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  ____ggeettiitteemm____(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  ____ggeettsslliiccee____(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  ____ggtt____(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  ____iiaadddd____(...)
     |      x.__iadd__(y) <==> x+=y
     |  
     |  ____iimmuull____(...)
     |      x.__imul__(y) <==> x*=y
     |  
     |  ____iinniitt____(...)
     |      x.__init__(...) initializes x; see help(type(x)) for signature
     |  
     |  ____iitteerr____(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  ____llee____(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  ____lleenn____(...)
     |      x.__len__() <==> len(x)
     |  
     |  ____lltt____(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  ____mmuull____(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  ____nnee____(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  ____rreevveerrsseedd____(...)
     |      L.__reversed__() -- return a reverse iterator over the list
     |  
     |  ____rrmmuull____(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  ____sseettiitteemm____(...)
     |      x.__setitem__(i, y) <==> x[i]=y
     |  
     |  ____sseettsslliiccee____(...)
     |      x.__setslice__(i, j, y) <==> x[i:j]=y
     |      
     |      Use  of negative indices is not supported.
     |  
     |  ____ssiizzeeooff____(...)
     |      L.__sizeof__() -- size of L in memory, in bytes
     |  
     |  aappppeenndd(...)
     |      L.append(object) -- append object to end
     |  
     |  eexxtteenndd(...)
     |      L.extend(iterable) -- extend list by appending elements from the iterable
     |  
     |  iinnddeexx(...)
     |      L.index(value, [start, [stop]]) -> integer -- return first index of value.
     |      Raises ValueError if the value is not present.
     |  
     |  iinnsseerrtt(...)
     |      L.insert(index, object) -- insert object before index
     |  
     |  ppoopp(...)
     |      L.pop([index]) -> item -- remove and return item at index (default last).
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  rreemmoovvee(...)
     |      L.remove(value) -- remove first occurrence of value.
     |      Raises ValueError if the value is not present.
     |  
     |  rreevveerrssee(...)
     |      L.reverse() -- reverse *IN PLACE*
     |  
     |  ssoorrtt(...)
     |      L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;
     |      cmp(x, y) -> -1, 0, 1
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from __builtin__.list:
     |  
     |  ____hhaasshh____ = None
     |  
     |  ____nneeww____ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class NNiiffttii11HHeeaaddeerr(nibabel.spm99analyze.SpmAnalyzeHeader)
     |  Class for NIfTI1 header
     |  
     |  The NIfTI1 header has many more coded fields than the simpler Analyze
     |  variants.  NIfTI1 headers also have extensions.
     |  
     |  Nifti allows the header to be a separate file, as part of a nifti image /
     |  header pair, or to precede the data in a single file.  The object needs to
     |  know which type it is, in order to manage the voxel offset pointing to the
     |  data, extension reading, and writing the correct magic string.
     |  
     |  This class handles the header-preceding-data case.
     |  
     |  Method resolution order:
     |      Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  ____iinniitt____(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  ccooppyy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  ggeett__bbeesstt__aaffffiinnee(self)
     |      Select best of available transforms
     |  
     |  ggeett__ddaattaa__sshhaappee(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |  
     |  ggeett__ddiimm__iinnffoo(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  ggeett__iinntteenntt(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  ggeett__nn__sslliicceess(self)
     |      Return the number of slices
     |  
     |  ggeett__qqffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  ggeett__qqffoorrmm__qquuaatteerrnniioonn(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  ggeett__ssffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  ggeett__sslliiccee__dduurraattiioonn(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  ggeett__sslliiccee__ttiimmeess(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  ggeett__ssllooppee__iinntteerr(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  ggeett__xxyyzztt__uunniittss(self)
     |  
     |  sseett__ddaattaa__sshhaappee(self, shape)
     |      Set shape of data  # noqa
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
     |      Nifti surface files, the first dimension is assumed to correspond to
     |      vertices/nodes on a surface, and dimensions two and three are
     |      constrained to have depth of 1. Dimensions 4-7 are constrained only by
     |      type bounds.
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |      
     |      The Nifti1 `standard header`_ allows for the following "point set"
     |      definition of a surface, not currently implemented in nibabel.
     |      
     |      ::
     |      
     |        To signify that the vector value at each voxel is really a
     |        spatial coordinate (e.g., the vertices or nodes of a surface mesh):
     |          - dataset must have a 5th dimension
     |          - intent_code must be NIFTI_INTENT_POINTSET
     |          - dim[0] = 5
     |          - dim[1] = number of points
     |          - dim[2] = dim[3] = dim[4] = 1
     |          - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
     |          - intent_name may describe the object these points come from
     |            (e.g., "pial", "gray/white" , "EEG", "MEG").
     |      
     |      .. _issue 100: https://github.com/nipy/nibabel/issues/100
     |      .. _issue 309: https://github.com/nipy/nibabel/issues/309
     |      .. _save77:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82
     |      .. _save50:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56
     |      .. _load_nifti.m:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89
     |      .. _standard header: http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
     |  
     |  sseett__ddiimm__iinnffoo(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  sseett__iinntteenntt(self, code, params=(), name='')
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # unknown code
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |  
     |  sseett__qqffoorrmm(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  sseett__ssffoorrmm(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  sseett__sslliiccee__dduurraattiioonn(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  sseett__sslliiccee__ttiimmeess(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  sseett__ssllooppee__iinntteerr(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  sseett__xxyyzztt__uunniittss(self, xyz=None, t=None)
     |  
     |  wwrriittee__ttoo(self, fileobj)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods defined here:
     |  
     |  ddeeffaauulltt__ssttrruuccttaarrrr(klass, endianness=None) from __builtin__.type
     |      Create empty header binary block with given endianness
     |  
     |  ffrroomm__ffiilleeoobbjj(klass, fileobj, endianness=None, check=True) from __builtin__.type
     |  
     |  ffrroomm__hheeaaddeerr(klass, header=None, check=True) from __builtin__.type
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  mmaayy__ccoonnttaaiinn__hheeaaddeerr(klass, binaryblock) from __builtin__.type
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  eexxttss__kkllaassss = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  hhaass__ddaattaa__iinntteerrcceepptt = True
     |  
     |  hhaass__ddaattaa__ssllooppee = True
     |  
     |  iiss__ssiinnggllee = True
     |  
     |  ppaaiirr__mmaaggiicc = 'ni1'
     |  
     |  ppaaiirr__vvooxx__ooffffsseett = 0
     |  
     |  qquuaatteerrnniioonn__tthhrreesshhoolldd = -3.5762786865234375e-07
     |  
     |  ssiinnggllee__mmaaggiicc = 'n+1'
     |  
     |  ssiinnggllee__vvooxx__ooffffsseett = 352
     |  
     |  tteemmppllaattee__ddttyyppee = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  aass__aannaallyyzzee__mmaapp(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  ddaattaa__ffrroomm__ffiilleeoobbjj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  ddaattaa__ttoo__ffiilleeoobbjj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tostring('F') == str_io.getvalue()
     |      True
     |  
     |  ggeett__bbaassee__aaffffiinnee(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  ggeett__ddaattaa__ddttyyppee(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  ggeett__ddaattaa__ooffffsseett(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  ggeett__zzoooommss(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  rraaww__ddaattaa__ffrroomm__ffiilleeoobbjj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  sseett__ddaattaa__ddttyyppee(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  sseett__ddaattaa__ooffffsseett(self, offset)
     |      Set offset into data file to read data
     |  
     |  sseett__zzoooommss(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  gguueesssseedd__eennddiiaann(klass, hdr) from __builtin__.type
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  ddeeffaauulltt__xx__fflliipp = True
     |  
     |  ssiizzeeooff__hhddrr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  ____ssttrr____(self)
     |      Return string representation for printing
     |  
     |  ggeett__vvaalluuee__llaabbeell(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  ____eeqq____(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  ____ggeettiitteemm____(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  ____iitteerr____(self)
     |  
     |  ____nnee____(self, other)
     |  
     |  ____sseettiitteemm____(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  aass__bbyytteesswwaappppeedd(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  cchheecckk__ffiixx(self, logger=None, error_level=None)
     |      Check structured data with checks
     |  
     |  ggeett(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  iitteemmss(self)
     |      Return items from structured data
     |  
     |  kkeeyyss(self)
     |      Return keys from structured data
     |  
     |  vvaalluueess(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  ddiiaaggnnoossee__bbiinnaarryybblloocckk(klass, binaryblock, endianness=None) from __builtin__.type
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  bbiinnaarryybblloocckk
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  eennddiiaannnneessss
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  ssttrruuccttaarrrr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: can't set attribute
    
    class NNiiffttii11IImmaaggee(Nifti1Pair)
     |  Class for single file NIfTI1 format image
     |  
     |  Method resolution order:
     |      Nifti1Image
     |      Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.filebasedimages.FileBasedImage
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  uuppddaattee__hheeaaddeerr(self)
     |      Harmonize header with image data and affine
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  ffiilleess__ttyyppeess = (('image', '.nii'),)
     |  
     |  hheeaaddeerr__ccllaassss = <class 'nibabel.nifti1.Nifti1Header'>
     |      Class for NIfTI1 header
     |      
     |      The NIfTI1 header has many more coded fields than the simpler Analyze
     |      variants.  NIfTI1 headers also have extensions.
     |      
     |      Nifti allows the header to be a separate file, as part of a nifti image /
     |      header pair, or to precede the data in a single file.  The object needs to
     |      know which type it is, in order to manage the voxel offset pointing to the
     |      data, extension reading, and writing the correct magic string.
     |      
     |      This class handles the header-preceding-data case.
     |  
     |  vvaalliidd__eexxttss = ('.nii',)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Pair:
     |  
     |  ____iinniitt____(self, dataobj, affine, header=None, extra=None, file_map=None)
     |  
     |  ggeett__qqffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  ggeett__ssffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  sseett__qqffoorrmm(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24).reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[ 2.,  0.,  0.,  0.],
     |             [ 0.,  3.,  0.,  0.],
     |             [ 0.,  0.,  4.,  0.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  sseett__ssffoorrmm(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24).reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[ 2.,  0.,  0.,  0.],
     |             [ 0.,  3.,  0.,  0.],
     |             [ 0.,  0.,  4.,  0.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[ 2.,  0.,  0.,  0.],
     |             [ 0.,  3.,  0.,  0.],
     |             [ 0.,  0.,  4.,  0.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Pair:
     |  
     |  rrww = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ggeett__ddaattaa__ddttyyppee(self)
     |  
     |  sseett__ddaattaa__ddttyyppee(self, dtype)
     |  
     |  ttoo__ffiillee__mmaapp(self, file_map=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ffrroomm__ffiillee__mmaapp(*args, **kwargs) from __builtin__.type
     |      class method to create image from mapping in `file_map ``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ffrroomm__ffiilleennaammee(*args, **kwargs) from __builtin__.type
     |      class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      
     |      Returns
     |      -------
     |      img : Analyze Image instance
     |  
     |  llooaadd = from_filename(*args, **kwargs) from __builtin__.type
     |      class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      
     |      Returns
     |      -------
     |      img : Analyze Image instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  IImmaaggeeAArrrraayyPPrrooxxyy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a ``header`` object with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      The header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' propoerty goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  mmaakkeeaabbllee = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ____ggeettiitteemm____(self)
     |      No slicing or dictionary interface for images
     |  
     |  ____ssttrr____(self)
     |  
     |  ggeett__aaffffiinnee(*args, **kwargs)
     |      Get affine from image
     |      
     |      get_affine method is deprecated.
     |      Please use the ``img.affine`` property instead.
     |      
     |      * deprecated from version: 2.1
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 4.0
     |  
     |  ggeett__ddaattaa(self, caching='fill')
     |      Return image data from image with any necessary scalng applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_data()`` on a proxy image is to read the
     |      data from the proxy, and store in an internal cache.  Future calls to
     |      ``get_data`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_data`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_data``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_data`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      
     |      Returns
     |      -------
     |      data : array
     |          array of image data
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_data`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_data``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_data(caching='unchanged')``; in this case ``get_data`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_data()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_data", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_data`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_data()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99
     |      
     |      The next time we call 'get_data', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_data()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_data(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_data(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0
     |  
     |  ggeett__sshhaappee(*args, **kwargs)
     |      Return shape for image
     |      
     |      get_shape method is deprecated.
     |      Please use the ``img.shape`` property instead.
     |      
     |      * deprecated from version: 1.2
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  oorrtthhoovviieeww(self)
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  uunnccaacchhee(self)
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_data()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_data()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_data()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_data()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_data() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_data()``, but when you uncache a proxy image, the result of
     |      ``img.get_data()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ffrroomm__iimmaaggee(klass, img) from __builtin__.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  aaffffiinnee
     |  
     |  ddaattaaoobbjj
     |  
     |  iinn__mmeemmoorryy
     |      True when array data is in memory
     |  
     |  sshhaappee
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  ggeett__ffiilleennaammee(self)
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames assoctiated with it
     |         (e.g Analyze ``.img, .hdr`` pair) then we return the more
     |         characteristic filename (the ``.img`` filename in the case of
     |         Analyze')
     |  
     |  ggeett__hheeaaddeerr(*args, **kwargs)
     |      Get header from image
     |      
     |      get_header method is deprecated.
     |      Please use the ``img.header`` property instead.
     |      
     |      * deprecated from version: 2.1
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 4.0
     |  
     |  sseett__ffiilleennaammee(self, filename)
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  ttoo__ffiilleennaammee(self, filename)
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ttoo__ffiilleess(*args, **kwargs)
     |      to_files method is deprecated.
     |      Please use the "to_file_map" method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  ttoo__ffiilleessppeecc(*args, **kwargs)
     |      to_filespec method is deprecated.
     |      Please use the "to_filename" method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  ffiilleessppeecc__ttoo__ffiillee__mmaapp(klass, filespec) from __builtin__.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  ffiilleessppeecc__ttoo__ffiilleess(*args, **kwargs) from __builtin__.type
     |      filespec_to_files class method is deprecated.
     |      Please use the "filespec_to_file_map" class method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  ffrroomm__ffiilleess(*args, **kwargs) from __builtin__.type
     |      from_files class method is deprecated.
     |      Please use the ``from_file_map`` class method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  iinnssttaannccee__ttoo__ffiilleennaammee(klass, img, filename) from __builtin__.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  mmaakkee__ffiillee__mmaapp(klass, mapping=None) from __builtin__.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  ppaatthh__mmaayybbee__iimmaaggee(klass, filename, sniff=None, sniff_max=1024) from __builtin__.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  hheeaaddeerr
    
    class NNiiffttii11PPaaiirr(nibabel.analyze.AnalyzeImage)
     |  Class for NIfTI1 format image, header pair
     |  
     |  Method resolution order:
     |      Nifti1Pair
     |      nibabel.analyze.AnalyzeImage
     |      nibabel.spatialimages.SpatialImage
     |      nibabel.filebasedimages.FileBasedImage
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  ____iinniitt____(self, dataobj, affine, header=None, extra=None, file_map=None)
     |  
     |  ggeett__qqffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_qform
     |      get_sform
     |  
     |  ggeett__ssffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |      
     |      See also
     |      --------
     |      set_sform
     |      get_qform
     |  
     |  sseett__qqffoorrmm(self, affine, code=None, strip_shears=True, **kwargs)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform. Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_qform
     |      set_sform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24).reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_qform()
     |      array([[ 2.,  0.,  0.,  0.],
     |             [ 0.,  3.,  0.,  0.],
     |             [ 0.,  0.,  4.,  0.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> img.get_qform(coded=True)
     |      (None, 0)
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_qform(aff2, 'talairach')
     |      >>> qaff, code = img.get_qform(coded=True)
     |      >>> np.all(qaff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  sseett__ssffoorrmm(self, affine, code=None, **kwargs)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      update_affine : bool, optional
     |          Whether to update the image affine from the header best affine
     |          after setting the qform.  Must be keyword argument (because of
     |          different position in `set_qform`). Default is True
     |      
     |      See also
     |      --------
     |      get_sform
     |      set_qform
     |      
     |      Examples
     |      --------
     |      >>> data = np.arange(24).reshape((2,3,4))
     |      >>> aff = np.diag([2, 3, 4, 1])
     |      >>> img = Nifti1Pair(data, aff)
     |      >>> img.get_sform()
     |      array([[ 2.,  0.,  0.,  0.],
     |             [ 0.,  3.,  0.,  0.],
     |             [ 0.,  0.,  4.,  0.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> saff
     |      array([[ 2.,  0.,  0.,  0.],
     |             [ 0.,  3.,  0.,  0.],
     |             [ 0.,  0.,  4.,  0.],
     |             [ 0.,  0.,  0.,  1.]])
     |      >>> int(code)
     |      2
     |      >>> aff2 = np.diag([3, 4, 5, 1])
     |      >>> img.set_sform(aff2, 'talairach')
     |      >>> saff, code = img.get_sform(coded=True)
     |      >>> np.all(saff == aff2)
     |      True
     |      >>> int(code)
     |      3
     |  
     |  uuppddaattee__hheeaaddeerr(self)
     |      Harmonize header with image data and affine
     |      
     |      See AnalyzeImage.update_header for more examples
     |      
     |      Examples
     |      --------
     |      >>> data = np.zeros((2,3,4))
     |      >>> affine = np.diag([1.0,2.0,3.0,1.0])
     |      >>> img = Nifti1Image(data, affine)
     |      >>> hdr = img.header
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  hheeaaddeerr__ccllaassss = <class 'nibabel.nifti1.Nifti1PairHeader'>
     |      Class for NIfTI1 pair header
     |  
     |  rrww = True
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ggeett__ddaattaa__ddttyyppee(self)
     |  
     |  sseett__ddaattaa__ddttyyppee(self, dtype)
     |  
     |  ttoo__ffiillee__mmaapp(self, file_map=None)
     |      Write image to `file_map` or contained ``self.file_map``
     |      
     |      Parameters
     |      ----------
     |      file_map : None or mapping, optional
     |         files mapping.  If None (default) use object's ``file_map``
     |         attribute instead
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  ffrroomm__ffiillee__mmaapp(*args, **kwargs) from __builtin__.type
     |      class method to create image from mapping in `file_map ``
     |      
     |      Parameters
     |      ----------
     |      file_map : dict
     |          Mapping with (kay, value) pairs of (``file_type``, FileHolder
     |          instance giving file-likes for each file needed for this image
     |          type.
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      
     |      Returns
     |      -------
     |      img : AnalyzeImage instance
     |  
     |  ffrroomm__ffiilleennaammee(*args, **kwargs) from __builtin__.type
     |      class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      
     |      Returns
     |      -------
     |      img : Analyze Image instance
     |  
     |  llooaadd = from_filename(*args, **kwargs) from __builtin__.type
     |      class method to create image from filename `filename`
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename of image to load
     |      mmap : {True, False, 'c', 'r'}, optional, keyword only
     |          `mmap` controls the use of numpy memory mapping for reading image
     |          array data.  If False, do not try numpy ``memmap`` for data array.
     |          If one of {'c', 'r'}, try numpy memmap with ``mode=mmap``.  A
     |          `mmap` value of True gives the same behavior as ``mmap='c'``.  If
     |          image data file cannot be memory-mapped, ignore `mmap` value and
     |          read array from file.
     |      
     |      Returns
     |      -------
     |      img : Analyze Image instance
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeImage:
     |  
     |  IImmaaggeeAArrrraayyPPrrooxxyy = <class 'nibabel.arrayproxy.ArrayProxy'>
     |      Class to act as proxy for the array that can be read from a file
     |      
     |      The array proxy allows us to freeze the passed fileobj and header such that
     |      it returns the expected data array.
     |      
     |      This implementation assumes a contiguous array in the file object, with one
     |      of the numpy dtypes, starting at a given file position ``offset`` with
     |      single ``slope`` and ``intercept`` scaling to produce output values.
     |      
     |      The class ``__init__`` requires a ``header`` object with methods:
     |      
     |      * get_data_shape
     |      * get_data_dtype
     |      * get_data_offset
     |      * get_slope_inter
     |      
     |      The header should also have a 'copy' method.  This requirement will go away
     |      when the deprecated 'header' propoerty goes away.
     |      
     |      This implementation allows us to deal with Analyze and its variants,
     |      including Nifti1, and with the MGH format.
     |      
     |      Other image types might need more specific classes to implement the API.
     |      See :mod:`nibabel.minc1`, :mod:`nibabel.ecat` and :mod:`nibabel.parrec` for
     |      examples.
     |  
     |  ffiilleess__ttyyppeess = (('image', '.img'), ('header', '.hdr'))
     |  
     |  mmaakkeeaabbllee = True
     |  
     |  vvaalliidd__eexxttss = ('.img', '.hdr')
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ____ggeettiitteemm____(self)
     |      No slicing or dictionary interface for images
     |  
     |  ____ssttrr____(self)
     |  
     |  ggeett__aaffffiinnee(*args, **kwargs)
     |      Get affine from image
     |      
     |      get_affine method is deprecated.
     |      Please use the ``img.affine`` property instead.
     |      
     |      * deprecated from version: 2.1
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 4.0
     |  
     |  ggeett__ddaattaa(self, caching='fill')
     |      Return image data from image with any necessary scalng applied
     |      
     |      The image ``dataobj`` property can be an array proxy or an array.  An
     |      array proxy is an object that knows how to load the image data from
     |      disk.  An image with an array proxy ``dataobj`` is a *proxy image*; an
     |      image with an array in ``dataobj`` is an *array image*.
     |      
     |      The default behavior for ``get_data()`` on a proxy image is to read the
     |      data from the proxy, and store in an internal cache.  Future calls to
     |      ``get_data`` will return the cached array.  This is the behavior
     |      selected with `caching` == "fill".
     |      
     |      Once the data has been cached and returned from an array proxy, if you
     |      modify the returned array, you will also modify the cached array
     |      (because they are the same array).  Regardless of the `caching` flag,
     |      this is always true of an array image.
     |      
     |      Parameters
     |      ----------
     |      caching : {'fill', 'unchanged'}, optional
     |          See the Notes section for a detailed explanation.  This argument
     |          specifies whether the image object should fill in an internal
     |          cached reference to the returned image data array. "fill" specifies
     |          that the image should fill an internal cached reference if
     |          currently empty.  Future calls to ``get_data`` will return this
     |          cached reference.  You might prefer "fill" to save the image object
     |          from having to reload the array data from disk on each call to
     |          ``get_data``.  "unchanged" means that the image should not fill in
     |          the internal cached reference if the cache is currently empty.  You
     |          might prefer "unchanged" to "fill" if you want to make sure that
     |          the call to ``get_data`` does not create an extra (cached)
     |          reference to the returned array.  In this case it is easier for
     |          Python to free the memory from the returned array.
     |      
     |      Returns
     |      -------
     |      data : array
     |          array of image data
     |      
     |      See also
     |      --------
     |      uncache: empty the array data cache
     |      
     |      Notes
     |      -----
     |      All images have a property ``dataobj`` that represents the image array
     |      data.  Images that have been loaded from files usually do not load the
     |      array data from file immediately, in order to reduce image load time
     |      and memory use.  For these images, ``dataobj`` is an *array proxy*; an
     |      object that knows how to load the image array data from file.
     |      
     |      By default (`caching` == "fill"), when you call ``get_data`` on a
     |      proxy image, we load the array data from disk, store (cache) an
     |      internal reference to this array data, and return the array.  The next
     |      time you call ``get_data``, you will get the cached reference to the
     |      array, so we don't have to load the array data from disk again.
     |      
     |      Array images have a ``dataobj`` property that already refers to an
     |      array in memory, so there is no benefit to caching, and the `caching`
     |      keywords have no effect.
     |      
     |      For proxy images, you may not want to fill the cache after reading the
     |      data from disk because the cache will hold onto the array memory until
     |      the image object is deleted, or you use the image ``uncache`` method.
     |      If you don't want to fill the cache, then always use
     |      ``get_data(caching='unchanged')``; in this case ``get_data`` will not
     |      fill the cache (store the reference to the array) if the cache is empty
     |      (no reference to the array).  If the cache is full, "unchanged" leaves
     |      the cache full and returns the cached array reference.
     |      
     |      The cache can effect the behavior of the image, because if the cache is
     |      full, or you have an array image, then modifying the returned array
     |      will modify the result of future calls to ``get_data()``.  For example
     |      you might do this:
     |      
     |      >>> import os
     |      >>> import nibabel as nib
     |      >>> from nibabel.testing import data_path
     |      >>> img_fname = os.path.join(data_path, 'example4d.nii.gz')
     |      
     |      >>> img = nib.load(img_fname) # This is a proxy image
     |      >>> nib.is_proxy(img.dataobj)
     |      True
     |      
     |      The array is not yet cached by a call to "get_data", so:
     |      
     |      >>> img.in_memory
     |      False
     |      
     |      After we call ``get_data`` using the default `caching` == 'fill', the
     |      cache contains a reference to the returned array ``data``:
     |      
     |      >>> data = img.get_data()
     |      >>> img.in_memory
     |      True
     |      
     |      We modify an element in the returned data array:
     |      
     |      >>> data[0, 0, 0, 0]
     |      0
     |      >>> data[0, 0, 0, 0] = 99
     |      >>> data[0, 0, 0, 0]
     |      99
     |      
     |      The next time we call 'get_data', the method returns the cached
     |      reference to the (modified) array:
     |      
     |      >>> data_again = img.get_data()
     |      >>> data_again is data
     |      True
     |      >>> data_again[0, 0, 0, 0]
     |      99
     |      
     |      If you had *initially* used `caching` == 'unchanged' then the returned
     |      ``data`` array would have been loaded from file, but not cached, and:
     |      
     |      >>> img = nib.load(img_fname)  # a proxy image again
     |      >>> data = img.get_data(caching='unchanged')
     |      >>> img.in_memory
     |      False
     |      >>> data[0, 0, 0] = 99
     |      >>> data_again = img.get_data(caching='unchanged')
     |      >>> data_again is data
     |      False
     |      >>> data_again[0, 0, 0, 0]
     |      0
     |  
     |  ggeett__sshhaappee(*args, **kwargs)
     |      Return shape for image
     |      
     |      get_shape method is deprecated.
     |      Please use the ``img.shape`` property instead.
     |      
     |      * deprecated from version: 1.2
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  oorrtthhoovviieeww(self)
     |      Plot the image using OrthoSlicer3D
     |      
     |      Returns
     |      -------
     |      viewer : instance of OrthoSlicer3D
     |          The viewer.
     |      
     |      Notes
     |      -----
     |      This requires matplotlib. If a non-interactive backend is used,
     |      consider using viewer.show() (equivalently plt.show()) to show
     |      the figure.
     |  
     |  uunnccaacchhee(self)
     |      Delete any cached read of data from proxied data
     |      
     |      Remember there are two types of images:
     |      
     |      * *array images* where the data ``img.dataobj`` is an array
     |      * *proxy images* where the data ``img.dataobj`` is a proxy object
     |      
     |      If you call ``img.get_data()`` on a proxy image, the result of reading
     |      from the proxy gets cached inside the image object, and this cache is
     |      what gets returned from the next call to ``img.get_data()``.  If you
     |      modify the returned data, as in::
     |      
     |          data = img.get_data()
     |          data[:] = 42
     |      
     |      then the next call to ``img.get_data()`` returns the modified array,
     |      whether the image is an array image or a proxy image::
     |      
     |          assert np.all(img.get_data() == 42)
     |      
     |      When you uncache an array image, this has no effect on the return of
     |      ``img.get_data()``, but when you uncache a proxy image, the result of
     |      ``img.get_data()`` returns to its original value.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  ffrroomm__iimmaaggee(klass, img) from __builtin__.type
     |      Class method to create new instance of own class from `img`
     |      
     |      Parameters
     |      ----------
     |      img : ``spatialimage`` instance
     |         In fact, an object with the API of ``spatialimage`` -
     |         specifically ``dataobj``, ``affine``, ``header`` and ``extra``.
     |      
     |      Returns
     |      -------
     |      cimg : ``spatialimage`` instance
     |         Image, of our own class
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.spatialimages.SpatialImage:
     |  
     |  aaffffiinnee
     |  
     |  ddaattaaoobbjj
     |  
     |  iinn__mmeemmoorryy
     |      True when array data is in memory
     |  
     |  sshhaappee
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  ggeett__ffiilleennaammee(self)
     |      Fetch the image filename
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      fname : None or str
     |         Returns None if there is no filename, or a filename string.
     |         If an image may have several filenames assoctiated with it
     |         (e.g Analyze ``.img, .hdr`` pair) then we return the more
     |         characteristic filename (the ``.img`` filename in the case of
     |         Analyze')
     |  
     |  ggeett__hheeaaddeerr(*args, **kwargs)
     |      Get header from image
     |      
     |      get_header method is deprecated.
     |      Please use the ``img.header`` property instead.
     |      
     |      * deprecated from version: 2.1
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 4.0
     |  
     |  sseett__ffiilleennaammee(self, filename)
     |      Sets the files in the object from a given filename
     |      
     |      The different image formats may check whether the filename has
     |      an extension characteristic of the format, and raise an error if
     |      not.
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |         If the image format only has one file associated with it,
     |         this will be the only filename set into the image
     |         ``.file_map`` attribute. Otherwise, the image instance will
     |         try and guess the other filenames from this given filename.
     |  
     |  ttoo__ffiilleennaammee(self, filename)
     |      Write image to files implied by filename string
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |         filename to which to save image.  We will parse `filename`
     |         with ``filespec_to_file_map`` to work out names for image,
     |         header etc.
     |      
     |      Returns
     |      -------
     |      None
     |  
     |  ttoo__ffiilleess(*args, **kwargs)
     |      to_files method is deprecated.
     |      Please use the "to_file_map" method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  ttoo__ffiilleessppeecc(*args, **kwargs)
     |      to_filespec method is deprecated.
     |      Please use the "to_filename" method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  ffiilleessppeecc__ttoo__ffiillee__mmaapp(klass, filespec) from __builtin__.type
     |      Make `file_map` for this class from filename `filespec`
     |      
     |      Class method
     |      
     |      Parameters
     |      ----------
     |      filespec : str
     |          Filename that might be for this image file type.
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |          `file_map` dict with (key, value) pairs of (``file_type``,
     |          FileHolder instance), where ``file_type`` is a string giving the
     |          type of the contained file.
     |      
     |      Raises
     |      ------
     |      ImageFileError
     |          if `filespec` is not recognizable as being a filename for this
     |          image type.
     |  
     |  ffiilleessppeecc__ttoo__ffiilleess(*args, **kwargs) from __builtin__.type
     |      filespec_to_files class method is deprecated.
     |      Please use the "filespec_to_file_map" class method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  ffrroomm__ffiilleess(*args, **kwargs) from __builtin__.type
     |      from_files class method is deprecated.
     |      Please use the ``from_file_map`` class method instead.
     |      
     |      * deprecated from version: 1.0
     |      * Will raise <class 'nibabel.deprecator.ExpiredDeprecationError'> as of version: 3.0
     |  
     |  iinnssttaannccee__ttoo__ffiilleennaammee(klass, img, filename) from __builtin__.type
     |      Save `img` in our own format, to name implied by `filename`
     |      
     |      This is a class method
     |      
     |      Parameters
     |      ----------
     |      img : ``any FileBasedImage`` instance
     |      
     |      filename : str
     |         Filename, implying name to which to save image.
     |  
     |  mmaakkee__ffiillee__mmaapp(klass, mapping=None) from __builtin__.type
     |      Class method to make files holder for this image type
     |      
     |      Parameters
     |      ----------
     |      mapping : None or mapping, optional
     |         mapping with keys corresponding to image file types (such as
     |         'image', 'header' etc, depending on image class) and values
     |         that are filenames or file-like.  Default is None
     |      
     |      Returns
     |      -------
     |      file_map : dict
     |         dict with string keys given by first entry in tuples in
     |         sequence klass.files_types, and values of type FileHolder,
     |         where FileHolder objects have default values, other than
     |         those given by `mapping`
     |  
     |  ppaatthh__mmaayybbee__iimmaaggee(klass, filename, sniff=None, sniff_max=1024) from __builtin__.type
     |      Return True if `filename` may be image matching this class
     |      
     |      Parameters
     |      ----------
     |      filename : str
     |          Filename for an image, or an image header (metadata) file.
     |          If `filename` points to an image data file, and the image type has
     |          a separate "header" file, we work out the name of the header file,
     |          and read from that instead of `filename`.
     |      sniff : None or (bytes, filename), optional
     |          Bytes content read from a previous call to this method, on another
     |          class, with metadata filename.  This allows us to read metadata
     |          bytes once from the image or header, and pass this read set of
     |          bytes to other image classes, therefore saving a repeat read of the
     |          metadata.  `filename` is used to validate that metadata would be
     |          read from the same file, re-reading if not.  None forces this
     |          method to read the metadata.
     |      sniff_max : int, optional
     |          The maximum number of bytes to read from the metadata.  If the
     |          metadata file is long enough, we read this many bytes from the
     |          file, otherwise we read to the end of the file.  Longer values
     |          sniff more of the metadata / image file, making it more likely that
     |          the returned sniff will be useful for later calls to
     |          ``path_maybe_image`` for other image classes.
     |      
     |      Returns
     |      -------
     |      maybe_image : bool
     |          True if `filename` may be valid for an image of this class.
     |      sniff : None or (bytes, filename)
     |          Read bytes content from found metadata.  May be None if the file
     |          does not appear to have useful metadata.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.filebasedimages.FileBasedImage:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  hheeaaddeerr
    
    class NNiiffttii11PPaaiirrHHeeaaddeerr(Nifti1Header)
     |  Class for NIfTI1 pair header
     |  
     |  Method resolution order:
     |      Nifti1PairHeader
     |      Nifti1Header
     |      nibabel.spm99analyze.SpmAnalyzeHeader
     |      nibabel.analyze.AnalyzeHeader
     |      nibabel.wrapstruct.LabeledWrapStruct
     |      nibabel.wrapstruct.WrapStruct
     |      __builtin__.object
     |  
     |  Data and other attributes defined here:
     |  
     |  iiss__ssiinnggllee = False
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Nifti1Header:
     |  
     |  ____iinniitt____(self, binaryblock=None, endianness=None, check=True, extensions=())
     |      Initialize header from binary data block and extensions
     |  
     |  ccooppyy(self)
     |      Return copy of header
     |      
     |      Take reference to extensions as well as copy of header contents
     |  
     |  ggeett__bbeesstt__aaffffiinnee(self)
     |      Select best of available transforms
     |  
     |  ggeett__ddaattaa__sshhaappee(self)
     |      Get shape of data
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_data_shape()
     |      (0,)
     |      >>> hdr.set_data_shape((1,2,3))
     |      >>> hdr.get_data_shape()
     |      (1, 2, 3)
     |      
     |      Expanding number of dimensions gets default zooms
     |      
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0, 1.0)
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |  
     |  ggeett__ddiimm__iinnffoo(self)
     |      Gets NIfTI MRI slice etc dimension information
     |      
     |      Returns
     |      -------
     |      freq : {None,0,1,2}
     |         Which data array axis is frequency encode direction
     |      phase : {None,0,1,2}
     |         Which data array axis is phase encode direction
     |      slice : {None,0,1,2}
     |         Which data array axis is slice encode direction
     |      
     |      where ``data array`` is the array returned by ``get_data``
     |      
     |      Because NIfTI1 files are natively Fortran indexed:
     |        0 is fastest changing in file
     |        1 is medium changing in file
     |        2 is slowest changing in file
     |      
     |      ``None`` means the axis appears not to be specified.
     |      
     |      Examples
     |      --------
     |      See set_dim_info function
     |  
     |  ggeett__iinntteenntt(self, code_repr='label')
     |      Get intent code, parameters and name
     |      
     |      Parameters
     |      ----------
     |      code_repr : string
     |         string giving output form of intent code representation.
     |         Default is 'label'; use 'code' for integer representation.
     |      
     |      Returns
     |      -------
     |      code : string or integer
     |          intent code, or string describing code
     |      parameters : tuple
     |          parameters for the intent
     |      name : string
     |          intent name
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.get_intent('code')
     |      (3, (10.0,), 'some score')
     |  
     |  ggeett__nn__sslliicceess(self)
     |      Return the number of slices
     |  
     |  ggeett__qqffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from qform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and qform code.  If False, just
     |          return affine.  {affine or None} means, return None if qform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine reconstructed from qform
     |          quaternion.  If `coded` is True, return None if qform code is 0,
     |          else return the affine.
     |      code : int
     |          Qform code. Only returned if `coded` is True.
     |  
     |  ggeett__qqffoorrmm__qquuaatteerrnniioonn(self)
     |      Compute quaternion from b, c, d of quaternion
     |      
     |      Fills a value by assuming this is a unit quaternion
     |  
     |  ggeett__ssffoorrmm(self, coded=False)
     |      Return 4x4 affine matrix from sform parameters in header
     |      
     |      Parameters
     |      ----------
     |      coded : bool, optional
     |          If True, return {affine or None}, and sform code.  If False, just
     |          return affine.  {affine or None} means, return None if sform code
     |          == 0, and affine otherwise.
     |      
     |      Returns
     |      -------
     |      affine : None or (4,4) ndarray
     |          If `coded` is False, always return affine from sform fields. If
     |          `coded` is True, return None if sform code is 0, else return the
     |          affine.
     |      code : int
     |          Sform code. Only returned if `coded` is True.
     |  
     |  ggeett__sslliiccee__dduurraattiioonn(self)
     |      Get slice duration
     |      
     |      Returns
     |      -------
     |      slice_duration : float
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_slice_duration(0.3)
     |      >>> print("%0.1f" % hdr.get_slice_duration())
     |      0.3
     |      
     |      Notes
     |      -----
     |      The NIfTI1 spec appears to require the slice dimension to be
     |      defined for slice_duration to have meaning.
     |  
     |  ggeett__sslliiccee__ttiimmeess(self)
     |      Get slice times from slice timing information
     |      
     |      Returns
     |      -------
     |      slice_times : tuple
     |          Times of acquisition of slices, where 0 is the beginning of
     |          the acquisition, ordered by position in file.  nifti allows
     |          slices at the top and bottom of the volume to be excluded from
     |          the standard slice timing specification, and calls these
     |          "padding slices".  We give padding slices ``None`` as a time
     |          of acquisition
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape((1, 1, 7))
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> hdr['slice_code'] = slice_order_codes['sequential increasing']
     |      >>> slice_times = hdr.get_slice_times()
     |      >>> np.allclose(slice_times, [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
     |      True
     |  
     |  ggeett__ssllooppee__iinntteerr(self)
     |      Get data scaling (slope) and DC offset (intercept) from header data
     |      
     |      Returns
     |      -------
     |      slope : None or float
     |         scaling (slope).  None if there is no valid scaling from these
     |         fields
     |      inter : None or float
     |         offset (intercept). None if there is no valid scaling or if offset
     |         is not finite.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.get_slope_inter()
     |      (1.0, 0.0)
     |      >>> hdr['scl_slope'] = 0
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = np.nan
     |      >>> hdr.get_slope_inter()
     |      (None, None)
     |      >>> hdr['scl_slope'] = 1
     |      >>> hdr['scl_inter'] = 1
     |      >>> hdr.get_slope_inter()
     |      (1.0, 1.0)
     |      >>> hdr['scl_inter'] = np.inf
     |      >>> hdr.get_slope_inter() #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |          ...
     |      HeaderDataError: Valid slope but invalid intercept inf
     |  
     |  ggeett__xxyyzztt__uunniittss(self)
     |  
     |  sseett__ddaattaa__sshhaappee(self, shape)
     |      Set shape of data  # noqa
     |      
     |      If ``ndims == len(shape)`` then we set zooms for dimensions higher than
     |      ``ndims`` to 1.0
     |      
     |      Nifti1 images can have up to seven dimensions. For FreeSurfer-variant
     |      Nifti surface files, the first dimension is assumed to correspond to
     |      vertices/nodes on a surface, and dimensions two and three are
     |      constrained to have depth of 1. Dimensions 4-7 are constrained only by
     |      type bounds.
     |      
     |      Parameters
     |      ----------
     |      shape : sequence
     |         sequence of integers specifying data array shape
     |      
     |      Notes
     |      -----
     |      Applies freesurfer hack for large vectors described in `issue 100`_ and
     |      `save_nifti.m <save77_>`_.
     |      
     |      Allows for freesurfer hack for 7th order icosahedron surface described
     |      in `issue 309`_, load_nifti.m_, and `save_nifti.m <save50_>`_.
     |      
     |      The Nifti1 `standard header`_ allows for the following "point set"
     |      definition of a surface, not currently implemented in nibabel.
     |      
     |      ::
     |      
     |        To signify that the vector value at each voxel is really a
     |        spatial coordinate (e.g., the vertices or nodes of a surface mesh):
     |          - dataset must have a 5th dimension
     |          - intent_code must be NIFTI_INTENT_POINTSET
     |          - dim[0] = 5
     |          - dim[1] = number of points
     |          - dim[2] = dim[3] = dim[4] = 1
     |          - dim[5] must be the dimensionality of space (e.g., 3 => 3D space).
     |          - intent_name may describe the object these points come from
     |            (e.g., "pial", "gray/white" , "EEG", "MEG").
     |      
     |      .. _issue 100: https://github.com/nipy/nibabel/issues/100
     |      .. _issue 309: https://github.com/nipy/nibabel/issues/309
     |      .. _save77:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L77-L82
     |      .. _save50:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/save_nifti.m#L50-L56
     |      .. _load_nifti.m:
     |          https://github.com/fieldtrip/fieldtrip/blob/428798b/external/freesurfer/load_nifti.m#L86-L89
     |      .. _standard header: http://nifti.nimh.nih.gov/pub/dist/src/niftilib/nifti1.h
     |  
     |  sseett__ddiimm__iinnffoo(self, freq=None, phase=None, slice=None)
     |      Sets nifti MRI slice etc dimension information
     |      
     |      Parameters
     |      ----------
     |      freq : {None, 0, 1, 2}
     |          axis of data array referring to frequency encoding
     |      phase : {None, 0, 1, 2}
     |          axis of data array referring to phase encoding
     |      slice : {None, 0, 1, 2}
     |          axis of data array referring to slice encoding
     |      
     |      ``None`` means the axis is not specified.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(1, 2, 0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info(freq=1, phase=2, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, 2, 0)
     |      >>> hdr.set_dim_info()
     |      >>> hdr.get_dim_info()
     |      (None, None, None)
     |      >>> hdr.set_dim_info(freq=1, phase=None, slice=0)
     |      >>> hdr.get_dim_info()
     |      (1, None, 0)
     |      
     |      Notes
     |      -----
     |      This is stored in one byte in the header
     |  
     |  sseett__iinntteenntt(self, code, params=(), name='')
     |      Set the intent code, parameters and name
     |      
     |      If parameters are not specified, assumed to be all zero. Each
     |      intent code has a set number of parameters associated. If you
     |      specify any parameters, then it will need to be the correct number
     |      (e.g the "f test" intent requires 2).  However, parameters can
     |      also be set in the file data, so we also allow not setting any
     |      parameters (empty parameter tuple).
     |      
     |      Parameters
     |      ----------
     |      code : integer or string
     |          code specifying nifti intent
     |      params : list, tuple of scalars
     |          parameters relating to intent (see intent_codes)
     |          defaults to ().  Unspecified parameters are set to 0.0
     |      name : string
     |          intent name (description). Defaults to ''
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_intent(0)  # unknown code
     |      >>> hdr.set_intent('z score')
     |      >>> hdr.get_intent()
     |      ('z score', (), '')
     |      >>> hdr.get_intent('code')
     |      (5, (), '')
     |      >>> hdr.set_intent('t test', (10,), name='some score')
     |      >>> hdr.get_intent()
     |      ('t test', (10.0,), 'some score')
     |      >>> hdr.set_intent('f test', (2, 10), name='another score')
     |      >>> hdr.get_intent()
     |      ('f test', (2.0, 10.0), 'another score')
     |      >>> hdr.set_intent('f test')
     |      >>> hdr.get_intent()
     |      ('f test', (0.0, 0.0), '')
     |  
     |  sseett__qqffoorrmm(self, affine, code=None, strip_shears=True)
     |      Set qform header values from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform. If None, only set code.
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing qform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing qform code in header != 0,
     |            `code`-> existing qform code in header
     |      
     |      strip_shears : bool, optional
     |          Whether to strip shears in `affine`.  If True, shears will be
     |          silently stripped. If False, the presence of shears will raise a
     |          ``HeaderDataError``
     |      
     |      Notes
     |      -----
     |      The qform transform only encodes translations, rotations and
     |      zooms. If there are shear components to the `affine` transform, and
     |      `strip_shears` is True (the default), the written qform gives the
     |      closest approximation where the rotation matrix is orthogonal. This is
     |      to allow quaternion representation. The orthogonal representation
     |      enforces orthogonal axes.
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['qform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_qform() == affine)
     |      False
     |      >>> hdr.set_qform(affine)
     |      >>> np.all(hdr.get_qform() == affine)
     |      True
     |      >>> int(hdr['qform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_qform(affine, code='talairach')
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code=None)
     |      >>> int(hdr['qform_code'])
     |      3
     |      >>> hdr.set_qform(affine, code='scanner')
     |      >>> int(hdr['qform_code'])
     |      1
     |      >>> hdr.set_qform(None)
     |      >>> int(hdr['qform_code'])
     |      0
     |  
     |  sseett__ssffoorrmm(self, affine, code=None)
     |      Set sform transform from 4x4 affine
     |      
     |      Parameters
     |      ----------
     |      affine : None or 4x4 array
     |          affine transform to write into sform.  If None, only set `code`
     |      code : None, string or integer, optional
     |          String or integer giving meaning of transform in *affine*.
     |          The default is None.  If code is None, then:
     |      
     |          * If affine is None, `code`-> 0
     |          * If affine not None and existing sform code in header == 0,
     |            `code`-> 2 (aligned)
     |          * If affine not None and existing sform code in header != 0,
     |            `code`-> existing sform code in header
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> int(hdr['sform_code'])  # gives 0 - unknown
     |      0
     |      >>> affine = np.diag([1,2,3,1])
     |      >>> np.all(hdr.get_sform() == affine)
     |      False
     |      >>> hdr.set_sform(affine)
     |      >>> np.all(hdr.get_sform() == affine)
     |      True
     |      >>> int(hdr['sform_code'])  # gives 2 - aligned
     |      2
     |      >>> hdr.set_sform(affine, code='talairach')
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code=None)
     |      >>> int(hdr['sform_code'])
     |      3
     |      >>> hdr.set_sform(affine, code='scanner')
     |      >>> int(hdr['sform_code'])
     |      1
     |      >>> hdr.set_sform(None)
     |      >>> int(hdr['sform_code'])
     |      0
     |  
     |  sseett__sslliiccee__dduurraattiioonn(self, duration)
     |      Set slice duration
     |      
     |      Parameters
     |      ----------
     |      duration : scalar
     |          time to acquire one slice
     |      
     |      Examples
     |      --------
     |      See ``get_slice_duration``
     |  
     |  sseett__sslliiccee__ttiimmeess(self, slice_times)
     |      Set slice times into *hdr*
     |      
     |      Parameters
     |      ----------
     |      slice_times : tuple
     |          tuple of slice times, one value per slice
     |          tuple can include None to indicate no slice time for that slice
     |      
     |      Examples
     |      --------
     |      >>> hdr = Nifti1Header()
     |      >>> hdr.set_dim_info(slice=2)
     |      >>> hdr.set_data_shape([1, 1, 7])
     |      >>> hdr.set_slice_duration(0.1)
     |      >>> times = [None, 0.2, 0.4, 0.1, 0.3, 0.0, None]
     |      >>> hdr.set_slice_times(times)
     |      >>> hdr.get_value_label('slice_code')
     |      'alternating decreasing'
     |      >>> int(hdr['slice_start'])
     |      1
     |      >>> int(hdr['slice_end'])
     |      5
     |  
     |  sseett__ssllooppee__iinntteerr(self, slope, inter=None)
     |      Set slope and / or intercept into header
     |      
     |      Set slope and intercept for image data, such that, if the image
     |      data is ``arr``, then the scaled image data will be ``(arr *
     |      slope) + inter``
     |      
     |      (`slope`, `inter`) of (NaN, NaN) is a signal to a containing image to
     |      set `slope`, `inter` automatically on write.
     |      
     |      Parameters
     |      ----------
     |      slope : None or float
     |         If None, implies `slope`  of NaN. If `slope` is None or NaN then
     |         `inter` should be None or NaN.  Values of 0, Inf or -Inf raise
     |         HeaderDataError
     |      inter : None or float, optional
     |         Intercept. If None, implies `inter` of NaN. If `slope` is None or
     |         NaN then `inter` should be None or NaN.  Values of Inf or -Inf raise
     |         HeaderDataError
     |  
     |  sseett__xxyyzztt__uunniittss(self, xyz=None, t=None)
     |  
     |  wwrriittee__ttoo(self, fileobj)
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from Nifti1Header:
     |  
     |  ddeeffaauulltt__ssttrruuccttaarrrr(klass, endianness=None) from __builtin__.type
     |      Create empty header binary block with given endianness
     |  
     |  ffrroomm__ffiilleeoobbjj(klass, fileobj, endianness=None, check=True) from __builtin__.type
     |  
     |  ffrroomm__hheeaaddeerr(klass, header=None, check=True) from __builtin__.type
     |      Class method to create header from another header
     |      
     |      Extend Analyze header copy by copying extensions from other Nifti
     |      types.
     |      
     |      Parameters
     |      ----------
     |      header : ``Header`` instance or mapping
     |         a header of this class, or another class of header for
     |         conversion to this type
     |      check : {True, False}
     |         whether to check header for integrity
     |      
     |      Returns
     |      -------
     |      hdr : header instance
     |         fresh header instance of our own class
     |  
     |  mmaayy__ccoonnttaaiinn__hheeaaddeerr(klass, binaryblock) from __builtin__.type
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Nifti1Header:
     |  
     |  eexxttss__kkllaassss = <class 'nibabel.nifti1.Nifti1Extensions'>
     |      Simple extension collection, implemented as a list-subclass.
     |  
     |  hhaass__ddaattaa__iinntteerrcceepptt = True
     |  
     |  hhaass__ddaattaa__ssllooppee = True
     |  
     |  ppaaiirr__mmaaggiicc = 'ni1'
     |  
     |  ppaaiirr__vvooxx__ooffffsseett = 0
     |  
     |  qquuaatteerrnniioonn__tthhrreesshhoolldd = -3.5762786865234375e-07
     |  
     |  ssiinnggllee__mmaaggiicc = 'n+1'
     |  
     |  ssiinnggllee__vvooxx__ooffffsseett = 352
     |  
     |  tteemmppllaattee__ddttyyppee = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  aass__aannaallyyzzee__mmaapp(self)
     |      Return header as mapping for conversion to Analyze types
     |      
     |      Collect data from custom header type to fill in fields for Analyze and
     |      derived header types (such as Nifti1 and Nifti2).
     |      
     |      When Analyze types convert another header type to their own type, they
     |      call this this method to check if there are other Analyze / Nifti
     |      fields that the source header would like to set.
     |      
     |      Returns
     |      -------
     |      analyze_map : mapping
     |          Object that can be used as a mapping thus::
     |      
     |              for key in analyze_map:
     |                  value = analyze_map[key]
     |      
     |          where ``key`` is the name of a field that can be set in an Analyze
     |          header type, such as Nifti1, and ``value`` is a value for the
     |          field.  For example, `analyze_map` might be a something like
     |          ``dict(regular='y', slice_duration=0.3)`` where ``regular`` is a
     |          field present in both Analyze and Nifti1, and ``slice_duration`` is
     |          a field restricted to Nifti1 and Nifti2.  If a particular Analyze
     |          header type does not recognize the field name, it will throw away
     |          the value without error.  See :meth:`Analyze.from_header`.
     |      
     |      Notes
     |      -----
     |      You can also return a Nifti header with the relevant fields set.
     |      
     |      Your header still needs methods ``get_data_dtype``, ``get_data_shape``
     |      and ``get_zooms``, for the conversion, and these get called *after*
     |      using the analyze map, so the methods will override values set in the
     |      map.
     |  
     |  ddaattaa__ffrroomm__ffiilleeoobbjj(self, fileobj)
     |      Read scaled data array from `fileobj`
     |      
     |      Use this routine to get the scaled image data from an image file
     |      `fileobj`, given a header `self`.  "Scaled" means, with any header
     |      scaling factors applied to the raw data in the file.  Use
     |      `raw_data_from_fileobj` to get the raw data.
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         scaled data array
     |      
     |      Notes
     |      -----
     |      We use the header to get any scale or intercept values to apply to the
     |      data.  Raw Analyze files don't have scale factors or intercepts, but
     |      this routine also works with formats based on Analyze, that do have
     |      scaling, such as SPM analyze formats and NIfTI.
     |  
     |  ddaattaa__ttoo__ffiilleeoobbjj(self, data, fileobj, rescale=True)
     |      Write `data` to `fileobj`, maybe rescaling data, modifying `self`
     |      
     |      In writing the data, we match the header to the written data, by
     |      setting the header scaling factors, iff `rescale` is True.  Thus we
     |      modify `self` in the process of writing the data.
     |      
     |      Parameters
     |      ----------
     |      data : array-like
     |         data to write; should match header defined shape
     |      fileobj : file-like object
     |         Object with file interface, implementing ``write`` and
     |         ``seek``
     |      rescale : {True, False}, optional
     |          Whether to try and rescale data to match output dtype specified by
     |          header. If True and scaling needed and header cannot scale, then
     |          raise ``HeaderTypeError``.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.analyze import AnalyzeHeader
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((1, 2, 3))
     |      >>> hdr.set_data_dtype(np.float64)
     |      >>> from io import BytesIO
     |      >>> str_io = BytesIO()
     |      >>> data = np.arange(6).reshape(1,2,3)
     |      >>> hdr.data_to_fileobj(data, str_io)
     |      >>> data.astype(np.float64).tostring('F') == str_io.getvalue()
     |      True
     |  
     |  ggeett__bbaassee__aaffffiinnee(self)
     |      Get affine from basic (shared) header fields
     |      
     |      Note that we get the translations from the center of the
     |      image.
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_shape((3, 5, 7))
     |      >>> hdr.set_zooms((3, 2, 1))
     |      >>> hdr.default_x_flip
     |      True
     |      >>> hdr.get_base_affine() # from center of image
     |      array([[-3.,  0.,  0.,  3.],
     |             [ 0.,  2.,  0., -4.],
     |             [ 0.,  0.,  1., -3.],
     |             [ 0.,  0.,  0.,  1.]])
     |  
     |  ggeett__ddaattaa__ddttyyppee(self)
     |      Get numpy dtype for data
     |      
     |      For examples see ``set_data_dtype``
     |  
     |  ggeett__ddaattaa__ooffffsseett(self)
     |      Return offset into data file to read data
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_data_offset()
     |      0
     |      >>> hdr['vox_offset'] = 12
     |      >>> hdr.get_data_offset()
     |      12
     |  
     |  ggeett__zzoooommss(self)
     |      Get zooms from header
     |      
     |      Returns
     |      -------
     |      z : tuple
     |         tuple of header zoom values
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.get_zooms()
     |      (1.0,)
     |      >>> hdr.set_data_shape((1,2))
     |      >>> hdr.get_zooms()
     |      (1.0, 1.0)
     |      >>> hdr.set_zooms((3, 4))
     |      >>> hdr.get_zooms()
     |      (3.0, 4.0)
     |  
     |  rraaww__ddaattaa__ffrroomm__ffiilleeoobbjj(self, fileobj)
     |      Read unscaled data array from `fileobj`
     |      
     |      Parameters
     |      ----------
     |      fileobj : file-like
     |         Must be open, and implement ``read`` and ``seek`` methods
     |      
     |      Returns
     |      -------
     |      arr : ndarray
     |         unscaled data array
     |  
     |  sseett__ddaattaa__ddttyyppee(self, datatype)
     |      Set numpy dtype for data from code or dtype or type
     |      
     |      Examples
     |      --------
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr.set_data_dtype(np.uint8)
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype(np.dtype(np.uint8))
     |      >>> hdr.get_data_dtype()
     |      dtype('uint8')
     |      >>> hdr.set_data_dtype('implausible') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "implausible" not recognized
     |      >>> hdr.set_data_dtype('none') #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "none" known but not supported
     |      >>> hdr.set_data_dtype(np.void) #doctest: +IGNORE_EXCEPTION_DETAIL
     |      Traceback (most recent call last):
     |         ...
     |      HeaderDataError: data dtype "<type 'numpy.void'>" known but not supported
     |  
     |  sseett__ddaattaa__ooffffsseett(self, offset)
     |      Set offset into data file to read data
     |  
     |  sseett__zzoooommss(self, zooms)
     |      Set zooms into header fields
     |      
     |      See docstring for ``get_zooms`` for examples
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  gguueesssseedd__eennddiiaann(klass, hdr) from __builtin__.type
     |      Guess intended endianness from mapping-like ``hdr``
     |      
     |      Parameters
     |      ----------
     |      hdr : mapping-like
     |         hdr for which to guess endianness
     |      
     |      Returns
     |      -------
     |      endianness : {'<', '>'}
     |         Guessed endianness of header
     |      
     |      Examples
     |      --------
     |      Zeros header, no information, guess native
     |      
     |      >>> hdr = AnalyzeHeader()
     |      >>> hdr_data = np.zeros((), dtype=header_dtype)
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      A valid native header is guessed native
     |      
     |      >>> hdr_data = hdr.structarr.copy()
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      And, when swapped, is guessed as swapped
     |      
     |      >>> sw_hdr_data = hdr_data.byteswap(swapped_code)
     |      >>> AnalyzeHeader.guessed_endian(sw_hdr_data) == swapped_code
     |      True
     |      
     |      The algorithm is as follows:
     |      
     |      First, look at the first value in the ``dim`` field; this
     |      should be between 0 and 7.  If it is between 1 and 7, then
     |      this must be a native endian header.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = 6
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['dim'][0] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      
     |      If the first ``dim`` value is zeros, we need a tie breaker.
     |      In that case we check the ``sizeof_hdr`` field.  This should
     |      be 348.  If it looks like the byteswapped value of 348,
     |      assumed swapped.  Otherwise assume native.
     |      
     |      >>> hdr_data = np.zeros((), dtype=header_dtype) # blank binary data
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == swapped_code
     |      True
     |      >>> hdr_data['sizeof_hdr'] = -1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |      
     |      This is overridden by the ``dim[0]`` value though:
     |      
     |      >>> hdr_data['sizeof_hdr'] = 1543569408
     |      >>> hdr_data['dim'][0] = 1
     |      >>> AnalyzeHeader.guessed_endian(hdr_data) == native_code
     |      True
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from nibabel.analyze.AnalyzeHeader:
     |  
     |  ddeeffaauulltt__xx__fflliipp = True
     |  
     |  ssiizzeeooff__hhddrr = 348
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.LabeledWrapStruct:
     |  
     |  ____ssttrr____(self)
     |      Return string representation for printing
     |  
     |  ggeett__vvaalluuee__llaabbeell(self, fieldname)
     |      Returns label for coded field
     |      
     |      A coded field is an int field containing codes that stand for
     |      discrete values that also have string labels.
     |      
     |      Parameters
     |      ----------
     |      fieldname : str
     |         name of header field to get label for
     |      
     |      Returns
     |      -------
     |      label : str
     |         label for code value in header field `fieldname`
     |      
     |      Raises
     |      ------
     |      ValueError
     |          if field is not coded.
     |      
     |      Examples
     |      --------
     |      >>> from nibabel.volumeutils import Recoder
     |      >>> recoder = Recoder(((1, 'one'), (2, 'two')), ('code', 'label'))
     |      >>> class C(LabeledWrapStruct):
     |      ...     template_dtype = np.dtype([('datatype', 'i2')])
     |      ...     _field_recoders = dict(datatype = recoder)
     |      >>> hdr  = C()
     |      >>> hdr.get_value_label('datatype')
     |      '<unknown code 0>'
     |      >>> hdr['datatype'] = 2
     |      >>> hdr.get_value_label('datatype')
     |      'two'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  ____eeqq____(self, other)
     |      equality between two structures defined by binaryblock
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr2 = WrapStruct()
     |      >>> wstr == wstr2
     |      True
     |      >>> wstr3 = WrapStruct(endianness=swapped_code)
     |      >>> wstr == wstr3
     |      True
     |  
     |  ____ggeettiitteemm____(self, item)
     |      Return values from structure data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] == 0
     |      True
     |  
     |  ____iitteerr____(self)
     |  
     |  ____nnee____(self, other)
     |  
     |  ____sseettiitteemm____(self, item, value)
     |      Set values in structured data
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr['integer'] = 3
     |      >>> wstr['integer']
     |      array(3, dtype=int16)
     |  
     |  aass__bbyytteesswwaappppeedd(self, endianness=None)
     |      return new byteswapped object with given ``endianness``
     |      
     |      Guaranteed to make a copy even if endianness is the same as
     |      the current endianness.
     |      
     |      Parameters
     |      ----------
     |      endianness : None or string, optional
     |         endian code to which to swap.  None means swap from current
     |         endianness, and is the default
     |      
     |      Returns
     |      -------
     |      wstr : ``WrapStruct``
     |         ``WrapStruct`` object with given endianness
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> wstr.endianness == native_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped()
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr = wstr.as_byteswapped(swapped_code)
     |      >>> bs_wstr.endianness == swapped_code
     |      True
     |      >>> bs_wstr is wstr
     |      False
     |      >>> bs_wstr == wstr
     |      True
     |      
     |      If you write to the resulting byteswapped data, it does not
     |      change the original.
     |      
     |      >>> bs_wstr['integer'] = 3
     |      >>> bs_wstr == wstr
     |      False
     |      
     |      If you swap to the same endianness, it returns a copy
     |      
     |      >>> nbs_wstr = wstr.as_byteswapped(native_code)
     |      >>> nbs_wstr.endianness == native_code
     |      True
     |      >>> nbs_wstr is wstr
     |      False
     |  
     |  cchheecckk__ffiixx(self, logger=None, error_level=None)
     |      Check structured data with checks
     |  
     |  ggeett(self, k, d=None)
     |      Return value for the key k if present or d otherwise
     |  
     |  iitteemmss(self)
     |      Return items from structured data
     |  
     |  kkeeyyss(self)
     |      Return keys from structured data
     |  
     |  vvaalluueess(self)
     |      Return values from structured data
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  ddiiaaggnnoossee__bbiinnaarryybblloocckk(klass, binaryblock, endianness=None) from __builtin__.type
     |      Run checks over binary data, return string
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from nibabel.wrapstruct.WrapStruct:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  bbiinnaarryybblloocckk
     |      binary block of data as string
     |      
     |      Returns
     |      -------
     |      binaryblock : string
     |          string giving binary data block
     |      
     |      Examples
     |      --------
     |      >>> # Make default empty structure
     |      >>> wstr = WrapStruct()
     |      >>> len(wstr.binaryblock)
     |      2
     |  
     |  eennddiiaannnneessss
     |      endian code of binary data
     |      
     |      The endianness code gives the current byte order
     |      interpretation of the binary data.
     |      
     |      Examples
     |      --------
     |      >>> wstr = WrapStruct()
     |      >>> code = wstr.endianness
     |      >>> code == native_code
     |      True
     |      
     |      Notes
     |      -----
     |      Endianness gives endian interpretation of binary data. It is
     |      read only because the only common use case is to set the
     |      endianness on initialization, or occasionally byteswapping the
     |      data - but this is done via the as_byteswapped method
     |  
     |  ssttrruuccttaarrrr
     |      Structured data, with data fields
     |      
     |      Examples
     |      --------
     |      >>> wstr1 = WrapStruct() # with default data
     |      >>> an_int = wstr1.structarr['integer']
     |      >>> wstr1.structarr = None
     |      Traceback (most recent call last):
     |         ...
     |      AttributeError: can't set attribute

FFUUNNCCTTIIOONNSS
    llooaadd(filename)
        Load NIfTI1 single or pair from `filename`
        
        Parameters
        ----------
        filename : str
            filename of image to be loaded
        
        Returns
        -------
        img : Nifti1Image or Nifti1Pair
            NIfTI1 single or pair image instance
        
        Raises
        ------
        ImageFileError
            if `filename` doesn't look like NIfTI1;
        IOError
            if `filename` does not exist.
    
    ssaavvee(img, filename)
        Save NIfTI1 single or pair to `filename`
        
        Parameters
        ----------
        filename : str
            filename to which to save image

DDAATTAA
    ddaattaa__ttyyppee__ccooddeess = <nibabel.volumeutils.Recoder object>
    ddiivviissiioonn = _Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192...
    eennddiiaann__ccooddeess = <nibabel.volumeutils.Recoder object>
    eexxtteennssiioonn__ccooddeess = <nibabel.volumeutils.Recoder object>
    hhaavvee__ddiiccoomm = True
    hheeaaddeerr__ddttdd = [('sizeof_hdr', 'i4'), ('data_type', 'S10'), ('db_name', ...
    hheeaaddeerr__ddttyyppee = dtype([('sizeof_hdr', '<i4'), ('data_type', 'S10... (4,...
    iinntteenntt__ccooddeess = <nibabel.volumeutils.Recoder object>
    pprriinntt__ffuunnccttiioonn = _Feature((2, 6, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0)...
    sslliiccee__oorrddeerr__ccooddeess = <nibabel.volumeutils.Recoder object>
    uunniitt__ccooddeess = <nibabel.volumeutils.Recoder object>
    xxffoorrmm__ccooddeess = <nibabel.volumeutils.Recoder object>

