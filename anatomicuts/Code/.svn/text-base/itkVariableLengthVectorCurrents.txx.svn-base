#ifndef __itkVariableLengthVectorCurrents_txx
#define __itkVariableLengthVectorCurrents_txx

#include "itkVariableLengthVectorCurrents.h"
#include "itkNumericTraitsVariableLengthVectorPixel.h"
#include "vnl/vnl_math.h"
#include <cstring>
#include <stdlib.h>
#include <string.h>


	template< typename TValueType ,class TMesh >
void VariableLengthVectorCurrents<TValueType,TMesh>::SetCell(MeshPointerType mesh, int cellId)
{
	/*typedef blitz::TinyVector<double,3> Vect;
	  typedef blitz::Array<Vect,1> ArrVect;
	  typedef blitz::TinyVector<double,3> Point;
	  typedef blitz::Array<Point,1> ArrPoint;
	  typedef blitz::TinyVector<double,3> VectPoint;
	  typedef blitz::Array<Point,1> ArrVectPoint;
	  typedef blitz::TinyVector<int,2> Face;
	  typedef blitz::Array<Face,1> ArrFace;
	  typedef blitz::Array<double,1> ArrWeight;
	  */
/*
	int numberOfPoints  = cell->GetNumberOfPoints();
	int numberOfPoints = vectorSize/3;
	ArrPoint* mp= new ArrPoint(Range(1,numberOfPoints));
	ArrPoint*  mp2 = new ArrPoint(Range(1, numberOfPoints));
	ArrFace*  mIndex= new ArrFace(Range(1,numberOfPoints-1));


	this->SetSize(vectorSize);

	int i = 1;
	for (typename CellType::PointIdIterator it = mesh->GetCell(cellId)->PointIdsBegin(); it!= mesh->GetCell(cellId)->PointIdsEnd(); it++)
	{
		PointType pt;
		pt.Fill (0.0);
		mesh->GetPoint (*it, &pt);
		*this[(i-1)*3] = pt[0];
		*this[(i-1)*3+1] = pt[1];
		*this[(i-1)*3+2] = pt[2];

		//currents
		(*mp)(i)(0) = pt[0];
		(*mp)(i)(1) = pt[1];
		(*mp)(i)(2) = pt[2];
		(*mp2)(numberOfPoints-i+1)(0) = pt[0];
		(*mp2)(numberOfPoints-i+1)(1) = pt[1];
		(*mp2)(numberOfPoints-i+1)(2) = pt[2];

		if(i>1)
		{
			(*mIndex)(i-1) = i-1,i;
		}

		i++;
	}
	//std::cout << " mp " << mp << std::endl;
	this->SetPoints(mp);
	// std::cout << " mp " << *mv.GetPoints() << std::endl;
	this->SetPointsReverse(mp2);
	this->SetVectors(mIndex);
*/
}


#endif
