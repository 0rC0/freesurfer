/*=========================================================================

  Program:   Insight Segmentation & Registration Toolkit
  Module:    $RCSfile: itkCurrentsToCentroidMembershipFunction.txx,v $
  Language:  C++
  Date:      $Date: 2009-03-04 15:23:46 $
  Version:   $Revision: 1.12 $

  Copyright (c) Insight Software Consortium. All rights reserved.
  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __itkCurrentsToCentroidMembershipFunction_txx
#define __itkCurrentsToCentroidMembershipFunction_txx

#include <blitz/array.h>
#include <blitz/tinyvec-et.h>
//using namespace blitz;


#include <iostream>
#include <limits>


#include "SqDistScalarKernel.h"
#include "CurveCurr.h" 

#include "CommonFunctions.h"

#include <utility>
#include <algorithm>

#include <fstream>
#include "vnl/vnl_matrix.h"
#include "vnl/vnl_math.h"
#include "math.h"

#include <blitz/array.h>
#include <blitz/tinyvec-et.h>


#include "interpolation.h"
#include <itkGaussianSpatialFunction.h>
#include "itkCurrentsToCentroidMembershipFunction.h"

namespace itk { 
namespace Statistics {

template < class TVector >
CurrentsToCentroidMembershipFunction< TVector >
::CurrentsToCentroidMembershipFunction():
  m_NumberOfSamples(-1)
{
}
template < class TVector >
double 
CurrentsToCentroidMembershipFunction< TVector >
::Evaluate(MeasurementVectorType &measurement)
{
   typedef blitz::TinyVector<double,3> Vect;
  int sig = this->GetSigmaCurrents();
   CauchyFunction<double> func(sig);
  SqDistScalarKernel<double,3,Vect> ker(&func);
   CurveCurr<double,3> CurvCurr(*(this->GetCentroid().GetPoints()),*measurement.GetVectors(),*this->GetCentroid().GetVectors(),&ker);
  double D = min( CurvCurr.Eval(*measurement.GetPoints()) , CurvCurr.Eval(*measurement.GetPointsReverse()));  
   return D; 
 }



template < class TVector >
void  
CurrentsToCentroidMembershipFunction< TVector >
::AddChild(MeasurementVectorType child) 
{
	childs.push_back(child);
}
 template < class TVector >
void  
CurrentsToCentroidMembershipFunction< TVector >
::RecalculateCentroid() 
{

  this->m_Variance = 0;
  typedef blitz::TinyVector<double,3> Vect;
  int sig = this->m_SigmaCurrents;
  CauchyFunction<double> func(sig);
  SqDistScalarKernel<double,3,Vect> ker(&func);
  double minDist =  numeric_limits<double>::max();

 for(int i=0; i< this->childs.size(); i++)
  {
     double min_i = 0;
    for(int j=0; j< this->childs.size() ; j++)
    {
      CurveCurr<double,3> CurvCurr(*childs[i].GetPoints(),*childs[j].GetVectors(),*childs[i].GetVectors(),&ker);
      double D = min( CurvCurr.Eval(*childs[j].GetPoints()) , CurvCurr.Eval(*childs[j].GetPointsReverse()));  

      min_i += D*D;

    }

    if( min_i < minDist )
    {
      minDist = min_i;
    this->SetCentroid(i);
	}
  }
  this->m_Variance = sqrt( minDist/this->childs.size());
}
   
template < class TVector >
void  
CurrentsToCentroidMembershipFunction< TVector >
::PrintSelf(std::ostream& os, Indent indent) const
{
  unsigned int i;
  Superclass::PrintSelf(os,indent);
}

} // end namespace Statistics
} // end of namespace itk

#endif
