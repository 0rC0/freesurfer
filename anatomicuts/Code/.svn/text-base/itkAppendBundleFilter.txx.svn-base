#include "itkAppendBundleFilter.h"
namespace itk
{
typedef struct {
  unsigned char r;
  unsigned char g;
  unsigned char b;
} color_triplet;

    void AppendBundleFilter::Update()
    {
      int i;
      int red, green, blue;
      color_triplet table[256] = {{0,0,0}}; /* Initialize to all black */

      const color_triplet black = {0,0,0};
      const color_triplet white = {255,255,255};

      table[0]   = white; /* Windows reserves first color for white */
      table[255] = black; /* Windows reserves last color as black   */

      i = 20; /* first 20 and last 20 are reserved */
      for (red = 0; red <= 255; red+= 51) {/* the six values of red */
        for (green = 0; green <= 255; green += 51) {
          for (blue = 0; blue <= 255; blue+= 51) {
            table[i].r = red;
            table[i].g = green;
            table[i].b = blue;
            ++i;
          }
        }
      }
      /* 
         As far as applications are concerned, it's not really necessary
         to define first and last entries, since windows will ignore them,
         but for program purposes, I like to document them (and for
         non-windows applications, these are the values that I would
         probably select anyhow).
       */
      table[0]   = white; /* Windows reserves first color for white */
      table[255] = black; /* Windows reserves last color as black   */


      int colorNumber =  bundleList.size();
      
      allBundles = vtkPolyData::New();
      vtkSmartPointer<vtkPoints> allPoints  = vtkPoints::New();
      vtkSmartPointer<vtkIntArray> allLabels  = vtkIntArray::New();
      vtkSmartPointer<vtkUnsignedCharArray> allColors = vtkUnsignedCharArray::New();

      allColors->SetNumberOfComponents (3);
      allLabels->SetNumberOfComponents (1);
      allLabels->SetName ("Labels");

      allBundles->Initialize();
      allBundles->Allocate();

  int currentLabel = 0;
  double val[3];

  vtkSmartPointer<vtkIntArray> intArrayRepresentativesWeights  = vtkIntArray::New();
  intArrayRepresentativesWeights->SetName("WeightsPerFiber");
  for ( i=0; i<bundleList.size(); i++)
  {

    vtkPolyData *bundle = bundleList[i];

    vtkIdType lineCount = bundle->GetNumberOfLines();
    vtkCellArray *lines = bundle->GetLines();
    lines->InitTraversal();
//28 208
  int index =((int)47.*((i%colorNumber)%(150)))%197+5;
    index = (int)(13*(i%colorNumber))%150+65;
    unsigned char color[3] = { table[index].r, table[index].g,table[index].b};
    vtkIdType pointCount, *pointBuf;
    if(rep)
    {
        vtkFieldData *fieldData = bundle->GetFieldData();
        //this is not fine, i knoww 0 will be the representatives index, or weight of fibers
        //vtkIntArray *arrayCellData = (vtkIntArray*) fieldData->GetArray("RepresentativeIndex");
        vtkIntArray *arrayCellData = (vtkIntArray*) fieldData->GetArray(0);

        if(arrayCellData != NULL)
        {
            if(   arrayCellData->GetNumberOfTuples() >1 ) 
            {
                std::cout << "WARNING: There are more than one representative index in field data " << std::endl;
            }
            //        for(int i=0; i< arrayCellData->GetNumberOfTuples();i++)
            //        {
            int cellId = arrayCellData->GetValue(0);
            for(int k=0;k<=cellId;k++)
            {
                lines->GetNextCell(pointCount, pointBuf);
            }
//            std::cout <<" rep " << cellId << std::endl;
            for (vtkIdType k=0; k<pointCount; k++)
            {
                pointBuf[k] = allPoints->InsertNextPoint ( bundle->GetPoint ( pointBuf[k] ) );
            }
            intArrayRepresentativesWeights->InsertNextValue(bundle->GetNumberOfLines());
            allBundles->InsertNextCell (VTK_POLY_LINE, pointCount, pointBuf);
            allLabels->InsertNextTuple1 ( currentLabel );
            allColors->InsertNextTuple3 ( color[0], color[1], color[2] );

            //        }
        } 
    } else
    {
        vtkFieldData *fieldData = bundle->GetFieldData();
        //this is not fine, i knoww 0 will be the representatives index, or weight of fibers
        vtkIntArray *arrayCellData = (vtkIntArray*) fieldData->GetArray(0);

        if(arrayCellData != NULL &&  arrayCellData->GetNumberOfTuples() ==  bundle->GetNumberOfLines() ) 
        {
    //        std::cout << " adding weights to file " << std::endl;
            for (int i=0;i<arrayCellData->GetNumberOfTuples();i++)
            {
                intArrayRepresentativesWeights->InsertNextValue(arrayCellData->GetValue(i));
            }
        }       


        while ( lines->GetNextCell(pointCount, pointBuf) )
        {
            for (vtkIdType k=0; k<pointCount; k++)
            {
                pointBuf[k] = allPoints->InsertNextPoint ( bundle->GetPoint ( pointBuf[k] ) );
            }

            allBundles->InsertNextCell (VTK_POLY_LINE, pointCount, pointBuf);
            allLabels->InsertNextTuple1 ( currentLabel );
            allColors->InsertNextTuple3 ( color[0], color[1], color[2] );
        }
    }
    currentLabel++;
  }
  vtkSmartPointer<vtkFieldData> fieldData = vtkFieldData::New();
  fieldData->AddArray(intArrayRepresentativesWeights);

  allBundles->SetFieldData(fieldData);
  allBundles->SetPoints ( allPoints );
  allBundles->GetCellData()->SetScalars ( allColors );
  allBundles->GetCellData()->AddArray ( allLabels );





int currentLabel = 0;
  double val[3]; //={0,0,0};

  for (unsigned int j=0; j<bundleList.size(); j++)
  {

    vtkPolyData *bundle = bundleList[j];

    vtkIdType lineCount = bundle->GetNumberOfLines();
    vtkCellArray *lines = bundle->GetLines();
    lines->InitTraversal();

    int i = currentLabel;
    val[2] = 0.5;
    val[1]= 0.5;
	val[0]=0.0;
	
	int res = i % 12;

    if (res==0 || res==1 || res==3 || res==6)
	    val[1]=0.0;
    if (res==2 || res==5 || res==8 || res==10 || res==11 || res==4)
    	val[1]=1.0;
	
	if( res==1 || res == 3|| res==4 || res==7 || res==9 || res==10)
		val[0]=1.0;
	if(res==0)
		val[0]==0.7;
	if(res==6 || res == 11)
		val[0]=0.5;

  unsigned char color[3]={(unsigned char)(val[0]*255.0),
      (unsigned char)(val[1]*255.0),
      (unsigned char)(val[2]*255.0)};
    /*unsigned char color[3]={(unsigned char)((double)rand()/(double)(RAND_MAX)*255.0),
      (unsigned char)((double)rand()/(double)(RAND_MAX)*255.0),
      (unsigned char)((double)rand()/(double)(RAND_MAX)*255.0)};
     */
    vtkIdType pointCount, *pointBuf;
    while ( lines->GetNextCell(pointCount, pointBuf) )
    {
      for (vtkIdType k=0; k<pointCount; k++)
      {
        pointBuf[k] = allPoints->InsertNextPoint ( bundle->GetPoint ( pointBuf[k] ) );
      }

      allBundles->InsertNextCell (VTK_POLY_LINE, pointCount, pointBuf);
      allLabels->InsertNextTuple1 ( currentLabel );
      allColors->InsertNextTuple3 ( color[0], color[1], color[2] );
    }

    currentLabel++;
  }


  allBundles->SetPoints ( allPoints );
  allBundles->GetCellData()->SetScalars ( allColors );
  allBundles->GetCellData()->AddArray ( allLabels );

/*
      std::cout <<  " budnles size " << bundleList.size() <<std::endl;
      for ( i=0; i<bundleList.size(); i++)
      {
        vtkPolyData *bundle = bundleList[i];

        vtkCellArray *lines = bundle->GetLines();
        lines->InitTraversal();
        //28 208
        int index =((int)47.*((i%colorNumber)%(150)))%197+5;
        index = (int)(13*(i%colorNumber))%150+65;
        unsigned char color[3] = { table[index].r, table[index].g,table[index].b};

        vtkIdType pointCount, *pointBuf;
        
        while ( lines->GetNextCell(pointCount, pointBuf) )
          {
            for (vtkIdType k=0; k<pointCount; k++)
            {
              pointBuf[k] = allPoints->InsertNextPoint ( bundle->GetPoint ( pointBuf[k] ) );
            }

            allBundles->InsertNextCell (VTK_POLY_LINE, pointCount, pointBuf);
            allLabels->InsertNextTuple1 ( currentLabel );
            allColors->InsertNextTuple3 ( color[0], color[1], color[2] );
          }
        currentLabel++;
      }

      allBundles->SetPoints ( allPoints );
      allBundles->GetCellData()->SetScalars ( allColors );
      allBundles->GetCellData()->AddArray ( allLabels );
*/
    }
}
