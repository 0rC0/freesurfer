#ifndef _itk_MeshOPTDemonsRegistrationFunction_txx_
#define _itk_MeshOPTDemonsRegistrationFunction_txx_

#include "itkMeshOPTDemonsRegistrationFunction.h"
#include "itkClosestPointMeshCorrespondencesCalculator.h"
//#include "itkMeassureMeshCorrespondencesCalculator.h"

#include "itkKdTree.h"
#include "itkKdTreeGenerator.h"
#include "itkVector.h"
#include "itkListSample.h"
//print
#include "time.h"
#include <sys/time.h>
#include "itkPolylineMeshToVTKPolyDataFilter.h"
#include "itkVectorValue.h"

#include "vtkPolyDataWriter.h"
#include <algorithm>
#include <map>
#include <sstream>
//#include <cLapack.h>
namespace itk
{

	template < class TFixedMesh,  class TMovingMesh,
		 class TFixedImage, class TMovingImage, class TDeformationField>
			 void
			 MeshOPTDemonsRegistrationFunction <TFixedMesh, TMovingMesh, TFixedImage, TMovingImage, TDeformationField>
			 ::InitializeIteration()
			 {
				 std::cout << " hola initialize iteration opt mesh demons registration function " << std::endl;
                                 Superclass::m_Metric    = 0.0;
                                 Superclass::m_RMSChange = 0.0;
                                 Superclass::m_NumberOfPointsProcessed = 0L;

				 DeformationFieldTypePointer invDef = this->GetInverseDeformationField();
				 // warp moving points, and update inputs of correspondence calculators
				 typedef itk::WarpMeshFilter<TMovingMesh,TMovingMesh, DeformationFieldType>  MeshWarperType;
				 typedef itk::PolylineMeshToVTKPolyDataFilter<TMovingMesh> VTKConverterType;
//	 typedef itk::MeassureMeshCorrespondencesCalculator<TMovingMesh,TFixedMesh> MeassuresDistanceType;
         time_t rawtime;
				 struct tm * timeinfo;

				 time ( &rawtime );
				 timeinfo = localtime ( &rawtime ); 
				 timeval curTime;
				 gettimeofday(&curTime, NULL);
				 int milli = curTime.tv_usec / 1000;

				 //				 std::cout << "currents : "<< this->GetSigma() << std::endl;
				 for (unsigned int i=0; i<Superclass::m_MovingMeshVector->Size(); i++)
				 {      
			
                                        std::cout << " i " << i << std::endl;
                                        typename WarpFilterType::Pointer warper = WarpFilterType::New();
					 warper->SetInput ( Superclass::m_MovingMeshVector->ElementAt (i) );
					 warper->SetDeformationField ( invDef );
					 warper->Update();

					 typename MovingMeshType::Pointer warpedMesh = warper->GetOutput();

					 CorrespondenceCalulatorPointerType cCalculator = Superclass::m_CorrespondenceCalculatorVector->ElementAt (i);
					 cCalculator->SetMovingMesh ( warpedMesh );
					 cCalculator->SetSpacing( this->GetMovingImage()->GetSpacing()[0]);

					 //PRINT FIBERS EACH ITERATION
					 typename VTKConverterType::Pointer converter = VTKConverterType::New();
					 converter->SetInput( warpedMesh );
					 converter->Update();

					 vtkPolyDataWriter *writer = vtkPolyDataWriter::New();
					 char meshName[100];
					 char meshName2[100];
					 strftime (meshName,100,"%H%M%S",timeinfo);
					 sprintf(meshName2, "%s%d_%.2d.vtk", meshName, milli,i);
					 writer->SetFileName(meshName2);
					 writer->SetInput( converter->GetOutputPolyData() );
					 writer->Update();
					 writer->Delete();
                     
				 }

                                

				 // K-d tree typedefs
				 typedef VectorValue< float, 3 >                             MeasurementVectorType;
				 typedef Statistics::ListSample< MeasurementVectorType > SampleType;
				 typedef Statistics::KdTreeGenerator< SampleType >       TreeGeneratorType;
				 typedef typename TreeGeneratorType::KdTreeType          TreeType;
				 typedef typename TreeType::NearestNeighbors             NeighborsType;
				 typedef typename TreeType::KdTreeNodeType               NodeType;

				 TreeType::Pointer                m_Tree;
				 SampleType::Pointer              m_Sample;
				 std::vector<SampleType::Pointer> m_SamplesCluster;

				 double radius = 0.2; //this->GetSigma();//this->GetMovingImage()->GetSpacing()[2] ;
				 m_Tree = 0;
				 m_Sample = SampleType::New();
				 m_Sample->SetMeasurementVectorSize( 3 );
				 // I create a map to know which points were already added to the list (to not repeat)
				 std::map<std::string,int> pointsMap;
				 std::vector<MeasurementVectorType>  points;
                                 std::vector<MeasurementVectorType>  allPoints;

                                 InterpolatorPointListType  cPositions;
                                 InterpolatorVectorListType cVectors;
                                 //				 InterpolatorPointListType  cMeshPositions;
                                 for (unsigned int i=0; i<Superclass::m_CorrespondenceCalculatorVector->Size(); i++)
                                 {
                                     Superclass::m_CorrespondenceCalculatorVector->ElementAt (i)->Evaluate(); //Times(5,this->GetLambdaGradientDescent());
                                     Superclass::m_Metric +=Superclass::m_CorrespondenceCalculatorVector->ElementAt (i)->Distance();
                                     Superclass::m_NumberOfPointsProcessed++;
                                     CorrespondencePointListType  positions =Superclass::m_CorrespondenceCalculatorVector->ElementAt (i)->GetOutputPositions();
                                     CorrespondenceVectorListType vectors   = Superclass::m_CorrespondenceCalculatorVector->ElementAt (i)->GetOutputVectors();
                                     MetricListType metrics =Superclass::m_CorrespondenceCalculatorVector->ElementAt (i)->GetOutputMetricValues();
         
                                     for(unsigned int j=0; j<positions.size(); j++)
                                     {
                                         cPositions.push_back( positions[j]);
                                         cVectors.push_back( -vectors[j]);
                                     }
                                 }
                                 if (Superclass::m_NumberOfPointsProcessed>0 )
                                 {
                                     Superclass::m_Metric /= Superclass::m_NumberOfPointsProcessed;
                                     Superclass::m_RMSChange /= Superclass::m_NumberOfPointsProcessed;
                                 }

                                 std::cout << " OPT  un vec to check " << cVectors[5] << " position " << cPositions[5]<<std::endl;
                                 // interpolate

                                 typename InterpolatorType::Pointer inter = InterpolatorType::New();
                                 float epsilon = -this->GetLambdaGradientDescent(); //2.;///this->GetMovingImage()->GetSpacing()[2];
				 std::cout << " Hola " << std::endl;
                                 for(unsigned int i =0; i < cVectors.size() ; i++)
                                 {
                                    double J[3];
                                     for (int j=0;j<3;j++)
                                     {   
                                         J[j] = cVectors[i][j];
                                         //    cVectors[i][j] *=epsilon;//   epsilon*(2* (lambdas(i,0))/ this->GetSigmaX() +  cVectors[i][0]/this->GetSigmaI()); 
                                     }
                                    int res= LAPACK::GaussNewtonAux(J,3);
                                    std::cout << " res: " << res << std::endl;
                                    for (int j=0;j<3;j++)
                                    {
                                        cVectors[i][j] =  J[j]*Superclass::m_Metric;
                                        cPositions[i][j] -= cVectors[i][j];
                                    }

                                 }
                                 Superclass::m_CorrespondencePositions.clear();
                                 Superclass::m_CorrespondencePositions.push_back ( cPositions );
                                 std::cout << "v  " << cVectors[0] <<"v " << cVectors[10] << std::endl ;
//				 std::cout << "p  " << cPositions[0] <<" p " << cPositions[10] ;
                                 std::cout << std::endl;
//         cVectors[i] /= cVectors[i].GetNorm();

//				 m_Interpolator = InterpolatorType::New();
                                 Superclass::m_Interpolator->SetInput   ( this->GetFixedImage() );
//				 m_Interpolator->SetSigma( this->GetMovingImage()->GetSpacing()[2]);
                                 double sigmaInter = this->GetSigma();//*this->GetMovingImage()->GetSpacing()[2];
                                 Superclass::m_Interpolator->SetSigma(sigmaInter) ;
                                 Superclass::m_Interpolator->SetVectors ( cVectors );
                                 Superclass::m_Interpolator->SetPoints  ( cPositions );
                                 Superclass::m_Interpolator->GetOutput()->SetRequestedRegion ( this->GetDeformationField()->GetRequestedRegion() );
                                 Superclass::m_Interpolator->SetNumberOfThreads(8);
                                 Superclass::m_Interpolator->Update();
                                 Superclass::m_MeshForces = Superclass::m_Interpolator->GetOutput();
                                 Superclass::m_MeshForces->DisconnectPipeline();
                         }


} // end of namespace

#endif
