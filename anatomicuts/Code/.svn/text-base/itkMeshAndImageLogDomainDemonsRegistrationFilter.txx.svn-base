#ifndef __itkMeshAndImageLogDomainDemonsRegistrationFilter_txx
#define __itkMeshAndImageLogDomainDemonsRegistrationFilter_txx

#include "itkMeshAndImageLogDomainDemonsRegistrationFilter.h"


namespace itk {

// Default constructor
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::MeshAndImageLogDomainDemonsRegistrationFilter()
{
	m_ImageDemonsRegistrationFunction = ImageDemonsRegistrationFunctionType::New();
	m_MeshDemonsRegistrationFunction  = MeshDemonsRegistrationFunctionType::New();
  
  typename DemonsRegistrationFunctionType::Pointer drfp;
  drfp = DemonsRegistrationFunctionType::New();

  drfp->SetImageDemonsFunction ( m_ImageDemonsRegistrationFunction );
  drfp->SetMeshDemonsFunction  ( m_MeshDemonsRegistrationFunction );

  this->SetDifferenceFunction( static_cast<FiniteDifferenceFunctionType *>(
                                 drfp.GetPointer() ) );

/*DemonsRegistrationFunctionPointer drfp = DemonsRegistrationFunctionType::New();
  this->SetDifferenceFunction( static_cast<FiniteDifferenceFunctionType *>(
                                 drfp.GetPointer() ) );
  */

  m_Multiplier = MultiplyByConstantType::New();
  m_Multiplier->InPlaceOn();
 
  m_BCHFilter = BCHFilterType::New();
  m_BCHFilter->InPlaceOn();

  // Set number of terms in the BCH approximation to default value
  m_BCHFilter->SetNumberOfApproximationTerms( 2 );
}


// Checks whether the DifferenceFunction is of type DemonsRegistrationFunction.
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
typename MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::DemonsRegistrationFunctionType*
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::DownCastDifferenceFunctionType()
{
  DemonsRegistrationFunctionType *drfp = 
    dynamic_cast<DemonsRegistrationFunctionType *>(this->GetDifferenceFunction().GetPointer());
 
  if( !drfp )
    {
    itkExceptionMacro( << "Could not cast difference function to SymmetricDemonsRegistrationFunction" );
    }

  return drfp;
}


// Checks whether the DifferenceFunction is of type DemonsRegistrationFunction.
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
const typename MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::DemonsRegistrationFunctionType*
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::DownCastDifferenceFunctionType() const
{
  const DemonsRegistrationFunctionType *drfp = 
    dynamic_cast<const DemonsRegistrationFunctionType *>(this->GetDifferenceFunction().GetPointer());
 
  if( !drfp )
    {
    itkExceptionMacro( << "Could not cast difference function to SymmetricDemonsRegistrationFunction" );
    }

  return drfp;
}


// Set the function state values before each iteration
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::InitializeIteration()
{
  //std::cout<<"MeshAndImageLogDomainDemonsRegistrationFilter::InitializeIteration"<<std::endl;
  // update variables in the equation object
  DemonsRegistrationFunctionType *f = this->DownCastDifferenceFunctionType();
  f->SetDeformationField( this->GetDeformationField() );
  typedef ExponentialDeformationFieldImageFilter<TField,TField >      FieldExponentiatorType;
  typedef typename FieldExponentiatorType::Pointer FieldExponentiatorPointer;
  FieldExponentiatorPointer exponentiator = FieldExponentiatorType::New();

  exponentiator->SetInput( this->GetVelocityField() );
  exponentiator->ComputeInverseOn();
  exponentiator->Update();
  DeformationFieldPointer  invField = exponentiator->GetOutput();
  invField->DisconnectPipeline();
  // Reset compute inverse back to off to avoid some broder effects
//  m_Exponentiator->ComputeInverseOff();

  f->SetInverseDeformationField(invField);
  // call the superclass  implementation ( initializes f )
  Superclass::InitializeIteration();
//  f->InitializeIteration();
}


// Get the metric value from the difference function
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
double
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh,TMovingMesh, TFixedImage,TMovingImage,TField>
::GetMetric() const
{
  return m_ImageDemonsRegistrationFunction->GetMetric() + m_MeshDemonsRegistrationFunction->GetMetric();
  //const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  //return drfp->GetMetric();
}


// Get Intensity Difference Threshold
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
double
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::GetIntensityDifferenceThreshold() const
{
  return m_ImageDemonsRegistrationFunction->GetIntensityDifferenceThreshold();
  //const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  //return drfp->GetIntensityDifferenceThreshold();
}

// Set Intensity Difference Threshold
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::SetIntensityDifferenceThreshold(double threshold) 
{
  m_ImageDemonsRegistrationFunction->SetIntensityDifferenceThreshold(threshold);
  //DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  //drfp->SetIntensityDifferenceThreshold(threshold);
}


// Set Maximum Update Step Length
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::SetMaximumUpdateStepLength(double step)
{
    m_ImageDemonsRegistrationFunction->SetMaximumUpdateStepLength(step);
  m_MeshDemonsRegistrationFunction->SetMaximumUpdateStepLength(step);
//DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  //drfp->SetMaximumUpdateStepLength(step);
}

// Get Maximum Update Step Length
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
double
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::GetMaximumUpdateStepLength() const
{
  return m_ImageDemonsRegistrationFunction->GetMaximumUpdateStepLength();
  //const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  //return drfp->GetMaximumUpdateStepLength();
}

/**
 *  Set Maximum Update Step Length
 */
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::AddMeshCorrespondenceCalculator(CorrespondenceCalulatorType *calculator)
{
  m_MeshDemonsRegistrationFunction->AddMeshCorrespondenceCalculator (calculator);
  std::cout << " number of meshes " <<   m_MeshDemonsRegistrationFunction->GetNumberOfMeshes()<< std::endl;
}

template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::SetSigma (double sigma)
{
  DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  drfp->SetSigma (sigma);
}

template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::SetSigmaI (double sigma)
{
  DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  drfp->SetSigmaI (sigma);
}

template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::SetSigmaX (double sigma)
{
  DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  drfp->SetSigmaX (sigma);
}

template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::SetLambdaGradientDescent (double sigma)
{
  DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  drfp->SetLambdaGradientDescent (sigma);
}

template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
double
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::GetSigma (void) const
{
  const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  return drfp->GetSigma ();
}
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
double
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::GetSigmaI (void) const
{
  const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  return drfp->GetSigmaI ();
}
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
double
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::GetSigmaX (void) const
{
  const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  return drfp->GetSigmaX ();
}
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TDeformationField>
double
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TDeformationField>
::GetLambdaGradientDescent (void) const
{
  const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  return drfp->GetLambdaGradientDescent ();
}


// Set number of terms used in the BCH approximation
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::SetNumberOfBCHApproximationTerms(unsigned int numterms)
{
  this->m_BCHFilter->SetNumberOfApproximationTerms(numterms);
}


// Get number of terms used in the BCH approximation
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
unsigned int
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::GetNumberOfBCHApproximationTerms() const
{
  return this->m_BCHFilter->GetNumberOfApproximationTerms();
}


// Get the metric value from the difference function
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
const double &
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::GetRMSChange() const
{
//  const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
//  return drfp->GetRMSChange();

return (m_ImageDemonsRegistrationFunction->GetRMSChange()+m_MeshDemonsRegistrationFunction->GetRMSChange());
}


// Get gradient type
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
typename MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>::GradientType
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::GetUseGradientType() const
{
  return m_ImageDemonsRegistrationFunction->GetUseGradientType();
  //const DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  //return drfp->GetUseGradientType();
}

// Set gradient type
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::SetUseGradientType(GradientType gtype) 
{
  m_ImageDemonsRegistrationFunction->SetUseGradientType(gtype);
  //DemonsRegistrationFunctionType *drfp = this->DownCastDifferenceFunctionType();
  //drfp->SetUseGradientType(gtype);
}

// Get the metric value from the difference function
template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::ApplyUpdate(TimeStepType dt)
{
  
  //std::cout<<"MeshAndImageLogDomainDemonsRegistrationFilter::ApplyUpdate"<<std::endl;
  // If we smooth the update buffer before applying it, then the are
  // approximating a viscuous problem as opposed to an elastic problem
  if ( this->GetSmoothUpdateField() )
    {
    this->SmoothUpdateField();
    }
  
  // Use time step if necessary. In many cases
  // the time step is one so this will be skipped
  if ( fabs(dt - 1.0)>1.0e-4 )
    {
    itkDebugMacro( "Using timestep: " << dt );
    m_Multiplier->SetConstant( dt );
    m_Multiplier->SetInput( this->GetUpdateBuffer() );
    m_Multiplier->GraftOutput( this->GetUpdateBuffer() );
    // in place update
    m_Multiplier->Update();
    // graft output back to this->GetUpdateBuffer()
    this->GetUpdateBuffer()->Graft( m_Multiplier->GetOutput() );
    }


  // Apply update by using BCH approximation
  m_BCHFilter->SetInput( 0, this->GetOutput() );
  m_BCHFilter->SetInput( 1, this->GetUpdateBuffer() );
  if ( m_BCHFilter->GetInPlace() )
    {
    m_BCHFilter->GraftOutput( this->GetOutput() );
    }
  else
    {
    // Work-around for http://www.itk.org/Bug/view.php?id=8672
    m_BCHFilter->GraftOutput( DeformationFieldType::New() );
    }
  m_BCHFilter->GetOutput()->SetRequestedRegion( this->GetOutput()->GetRequestedRegion() );

  // Triggers in place update
  m_BCHFilter->Update();
  
  // Region passing stuff
  this->GraftOutput( m_BCHFilter->GetOutput() );


  //Smooth the velocity field
  if( this->GetSmoothVelocityField() )
    {
    this->SmoothVelocityField();
    }

}


template <class TFixedMesh, class TMovingMesh, class TFixedImage, class TMovingImage, class TField>
void
MeshAndImageLogDomainDemonsRegistrationFilter<TFixedMesh, TMovingMesh, TFixedImage,TMovingImage,TField>
::PrintSelf(std::ostream& os, Indent indent) const
{ 
  Superclass::PrintSelf( os, indent );

  os << indent << "Multiplier: " << m_Multiplier << std::endl;
  os << indent << "BCHFilter: " << m_BCHFilter << std::endl;
}


} // end namespace itk

#endif
