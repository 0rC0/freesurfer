#ifndef __itkMultiImageResolutionLogDomainRegistration_txx
#define __itkMultiImageResolutionLogDomainRegistration_txx
#include "itkMultiImageResolutionLogDomainRegistration.h"

#include "itkRecursiveGaussianImageFilter.h"
#include "itkRecursiveMultiResolutionPyramidImageFilter.h"
#include "itkImageRegionIterator.h"
#include "vnl/vnl_math.h"

namespace itk {

    // Default constructor
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::MultiImageResolutionLogDomainRegistration()
        {

            this->SetNumberOfRequiredInputs(2);

            typename DefaultRegistrationType::Pointer registrator =
                DefaultRegistrationType::New();
            m_RegistrationFilter = static_cast<RegistrationType*>(
                    registrator.GetPointer() );

            m_FieldExpander     = FieldExpanderType::New();
            m_InitialVelocityField = NULL;

            m_NumberOfLevels = 3;
            m_NumberOfIterations.resize( m_NumberOfLevels );


            unsigned int ilevel;
            for( ilevel = 0; ilevel < m_NumberOfLevels; ilevel++ )
            {
                m_NumberOfIterations[ilevel] = 10;
            }
            m_CurrentLevel = 0;

            m_StopRegistrationFlag = false;

            m_Exponentiator = FieldExponentiatorType::New();
            m_LastIndexSetFixed = 0;
            m_LastIndexSetMoving = 0;
        }


    // Set the moving image image.
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::SetMovingImage(
                const MovingImageType * ptr, unsigned int index )
        {
            this->ProcessObject::SetNthInput( index*2+2, const_cast< MovingImageType * >( ptr ) );
            this->m_LastIndexSetMoving=index*2+2;
            std::cout << " Set moving " << this->m_LastIndexSetMoving<< std::endl;
            MovingImagePyramidPointer movingImagePyramid     = ActualFixedImagePyramidType::New();
            movingImagePyramid->SetNumberOfLevels( m_NumberOfLevels );
            if(m_MovingImagePyramids.size() > index)
            {
                m_MovingImagePyramids[index] =  movingImagePyramid;
            }
            else
            {
                m_MovingImagePyramids.push_back(movingImagePyramid);
            }
         }


    // Get the moving image image.
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        const typename MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::MovingImageType *
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GetMovingImage(unsigned int index) const
        {
            return dynamic_cast< const MovingImageType * >
                ( this->ProcessObject::GetInput( index*2+2 ) );
        }


    // Set the fixed image.
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::SetFixedImage(
                const FixedImageType * ptr, unsigned int index )
        {
            this->ProcessObject::SetNthInput( index*2+1, const_cast< FixedImageType * >( ptr ) );
            this->m_LastIndexSetFixed=index*2+1;
            std::cout << " Set Fixed " << this->m_LastIndexSetFixed <<std::endl;
            FixedImagePyramidPointer fixedImagePyramid     = ActualFixedImagePyramidType::New();
            fixedImagePyramid->SetNumberOfLevels( m_NumberOfLevels );
            if(m_FixedImagePyramids.size() > index)
            {
                m_FixedImagePyramids[index] =  fixedImagePyramid;
            }
            else
            {
                m_FixedImagePyramids.push_back(fixedImagePyramid);
            }
        }


    // Get the fixed image.
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        const typename MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::FixedImageType *
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GetFixedImage(unsigned int index) const
        {
            return dynamic_cast< const FixedImageType * >
                ( this->ProcessObject::GetInput( index*2+1 ) );
        }


    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        std::vector<SmartPointer<DataObject> >::size_type
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GetNumberOfValidRequiredInputs() const
        {
            return m_LastIndexSetMoving;
        }


    // Set the number of multi-resolution levels
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::SetNumberOfLevels(
                unsigned int num )
        {
            if( m_NumberOfLevels != num )
            {
                this->Modified();
                m_NumberOfLevels = num;
                m_NumberOfIterations.resize( m_NumberOfLevels );
            }

            if( m_MovingImagePyramids.size() && m_MovingImagePyramids[0]->GetNumberOfLevels() != num )
            {
                
                for(int i=0;i<m_MovingImagePyramids.size();i++)
                    m_MovingImagePyramids[i]->SetNumberOfLevels( m_NumberOfLevels );
            }
            if( m_FixedImagePyramids.size() && m_FixedImagePyramids[0]->GetNumberOfLevels() != num )
            {
                for(int i=0;i<m_FixedImagePyramids.size();i++)
                    m_FixedImagePyramids[i]->SetNumberOfLevels( m_NumberOfLevels );
            }  

        }


    // Standard PrintSelf method.
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::PrintSelf(std::ostream& os, Indent indent) const
        {
            Superclass::PrintSelf(os, indent);
            os << indent << "NumberOfLevels: " << m_NumberOfLevels << std::endl;
            os << indent << "CurrentLevel: " << m_CurrentLevel << std::endl;

            os << indent << "NumberOfIterations: [";
            unsigned int ilevel;
            for( ilevel = 0; ilevel < m_NumberOfLevels - 1; ilevel++ )
            {
                os << m_NumberOfIterations[ilevel] << ", ";
            }
            os << m_NumberOfIterations[ilevel] << "]" << std::endl;

            os << indent << "RegistrationFilter: ";
            os << m_RegistrationFilter.GetPointer() << std::endl;
            os << indent << "MovingImagePyramid size: ";
            os << m_MovingImagePyramids.size() << std::endl;
            os << indent << "FixedImagePyramid size: ";
            os << m_FixedImagePyramids.size() << std::endl;

            os << indent << "FieldExpander: ";
            os << m_FieldExpander.GetPointer() << std::endl;

            os << indent << "StopRegistrationFlag: ";
            os << m_StopRegistrationFlag << std::endl;

            os << indent << "Exponentiator: ";
            os << m_Exponentiator << std::endl;

        }

    /*
     * Perform a the deformable registration using a multiresolution scheme
     * using an internal mini-pipeline
     *
     *  ref_pyramid ->  registrator  ->  field_expander --|| tempField
     * test_pyramid ->           |                              |
     *                           |                              |
     *                           --------------------------------
     *
     * A tempField image is used to break the cycle between the
     * registrator and field_expander.*/
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GenerateData()
        {
            //bool lastShrinkFactorAllOnes = false; 

            // Check for NULL images and pointers
            MovingImageConstPointer movingImage = this->GetMovingImage(0);
            FixedImageConstPointer  fixedImage = this->GetFixedImage(0);

            if( !movingImage || !fixedImage )
            {
                itkExceptionMacro( << "Fixed and/or moving image not set" );
            }

            // Create the image pyramids.
            m_MovingImagePyramids[0]->SetInput( movingImage );
            m_MovingImagePyramids[0]->UpdateLargestPossibleRegion();

            m_FixedImagePyramids[0]->SetInput( fixedImage );
            m_FixedImagePyramids[0]->UpdateLargestPossibleRegion();
            if( !m_MovingImagePyramids.size() || !m_FixedImagePyramids.size() )
            {
                itkExceptionMacro( << "Fixed and/or moving pyramid not set" );
            }

            if( !m_RegistrationFilter )
            {
                itkExceptionMacro( << "Registration filter not set" );
            }

            if( this->m_InitialVelocityField && this->GetInput(0) )
            {
                itkExceptionMacro( << "Only one initial velocity can be given. "
                        << "SetInitialVelocityField should not be used in "
                        << "cunjunction with SetArbitraryInitialVelocityField "
                        << "or SetInput.");
            }

            // Initializations
            m_CurrentLevel = 0;
            m_StopRegistrationFlag = false;

            unsigned int movingLevel = vnl_math_min( (int) m_CurrentLevel, 
                    (int) m_MovingImagePyramids[0]->GetNumberOfLevels() );

            unsigned int fixedLevel = vnl_math_min( (int) m_CurrentLevel, 
                    (int) m_FixedImagePyramids[0]->GetNumberOfLevels() );

            VelocityFieldPointer tempField = NULL;

            VelocityFieldPointer inputPtr =
                const_cast< VelocityFieldType * >( this->GetInput(0) );

            if ( this->m_InitialVelocityField )
            {
                tempField = this->m_InitialVelocityField;
            }
            else if( inputPtr )
            {
                // Arbitrary initial velocity field is set.
                // smooth it and resample

                // First smooth it
                tempField = inputPtr;

                typedef RecursiveGaussianImageFilter< VelocityFieldType,
                        VelocityFieldType> GaussianFilterType;
                typename GaussianFilterType::Pointer smoother
                    = GaussianFilterType::New();

                for (unsigned int dim=0; dim<VelocityFieldType::ImageDimension; ++dim)
                {
                    // sigma accounts for the subsampling of the pyramid
                    double sigma = 0.5 * static_cast<float>(
                            m_FixedImagePyramids[0]->GetSchedule()[fixedLevel][dim] );

                    // but also for a possible discrepancy in the spacing
                    sigma *= fixedImage->GetSpacing()[dim]
                        / inputPtr->GetSpacing()[dim];

                    smoother->SetInput( tempField );

                    smoother->SetSigma( sigma );
                    smoother->SetDirection( dim );

                    smoother->Update();

                    tempField = smoother->GetOutput();
                    tempField->DisconnectPipeline();
                }


                // Now resample
                m_FieldExpander->SetInput( tempField );

                typename FloatImageType::Pointer fi = 
                    m_FixedImagePyramids[0]->GetOutput( fixedLevel );
                m_FieldExpander->SetSize( 
                        fi->GetLargestPossibleRegion().GetSize() );
                m_FieldExpander->SetOutputStartIndex(
                        fi->GetLargestPossibleRegion().GetIndex() );
                m_FieldExpander->SetOutputOrigin( fi->GetOrigin() );
                m_FieldExpander->SetOutputSpacing( fi->GetSpacing());
                m_FieldExpander->SetOutputDirection( fi->GetDirection());

                m_FieldExpander->UpdateLargestPossibleRegion();
                m_FieldExpander->SetInput( NULL );
                tempField = m_FieldExpander->GetOutput();
                tempField->DisconnectPipeline();
            }
            else
            {
                std::cout << " hola ups " << std::endl;
            }

            bool        lastShrinkFactorsAllOnes = false;

            while ( !this->Halt() )
            {
                std::cout << " !halt "<< std::endl;
                if( tempField.IsNull() )
                {
                    std::cout << "set initial velocitu fiedl  NULL"  << std::endl;
                    m_RegistrationFilter->SetInitialVelocityField( NULL );
                }
                else
                {
                    // Resample the field to be the same size as the fixed image
                    // at the current level
                    m_FieldExpander->SetInput( tempField );

                    typename FloatImageType::Pointer fi = 
                        m_FixedImagePyramids[0]->GetOutput( fixedLevel );
                    m_FieldExpander->SetSize( 
                            fi->GetLargestPossibleRegion().GetSize() );
                    m_FieldExpander->SetOutputStartIndex(
                            fi->GetLargestPossibleRegion().GetIndex() );
                    m_FieldExpander->SetOutputOrigin( fi->GetOrigin() );
                    m_FieldExpander->SetOutputSpacing( fi->GetSpacing());
                    m_FieldExpander->SetOutputDirection( fi->GetDirection());

                    m_FieldExpander->UpdateLargestPossibleRegion();
                    m_FieldExpander->SetInput( NULL );
                    tempField = m_FieldExpander->GetOutput();
                    tempField->DisconnectPipeline();
//                    std::cout << "set initial velocitu fiedl " << tempField << std::endl;
                    m_RegistrationFilter->SetInitialVelocityField( tempField );
                    m_RegistrationFilter->SetInitialDeformationField( tempField );
                    
                    m_function->SetDeformationField(tempField);
                }
               std::cout <<  " number of images " << this->GetNumberOfImages() << std::endl;
//             m_RegistrationFilter->SetImageRegistrationFunction(m_function);    
               m_RegistrationFilter->SetMovingImage( m_MovingImagePyramids[0]->GetOutput(movingLevel),0);
                    m_RegistrationFilter->SetFixedImage( m_FixedImagePyramids[0]->GetOutput(fixedLevel) ,0);
/*                   m_RegistrationFilter->SetMovingImage( m_MovingImagePyramid->GetOutput(movingLevel));
                    m_RegistrationFilter->SetFixedImage( m_FixedImagePyramid->GetOutput(fixedLevel) );
*/
//               std::cout << "moving pyramid 0 "  << m_MovingImagePyramids[0]->GetOutput(movingLevel)->GetLargestPossibleRegion () << std::endl;
                for(int i=1;i< this->GetNumberOfImages();i++)
                {
                    // Check for NULL images and pointers
                    
                    MovingImageConstPointer movingImage = this->GetMovingImage(i);
                    FixedImageConstPointer  fixedImage = this->GetFixedImage(i);

                    if( !movingImage || !fixedImage )
                    {
                        itkExceptionMacro( << "Fixed and/or moving image not set" );
                    }

                    // Create the image pyramids.
                    m_MovingImagePyramids[i]->SetInput( movingImage );
                    m_MovingImagePyramids[i]->UpdateLargestPossibleRegion();

                    m_FixedImagePyramids[i]->SetInput( fixedImage );
                    m_FixedImagePyramids[i]->UpdateLargestPossibleRegion();


                std::cout << "moving pyramid  "  << i<< " " << m_MovingImagePyramids[i]->GetOutput(movingLevel)->GetLargestPossibleRegion () << std::endl;
                    // setup registration filter and pyramids 
                    m_RegistrationFilter->SetMovingImage( m_MovingImagePyramids[i]->GetOutput(movingLevel),i);
                    m_RegistrationFilter->SetFixedImage( m_FixedImagePyramids[i]->GetOutput(fixedLevel) ,i);
                }
                //std::cout << this->GetFixedImage(0)->GetLargestPossibleRegion() << std::endl;
                //std::cout << this->GetFixedImage(1)->GetLargestPossibleRegion() << std::endl;
                m_RegistrationFilter->SetNumberOfIterations(
                        m_NumberOfIterations[m_CurrentLevel] );

                // cache shrink factors for computing the next expand factors.
                lastShrinkFactorsAllOnes = true;
                for( unsigned int idim = 0; idim < ImageDimension; idim++ )
                {
                    if ( m_FixedImagePyramids[0]->GetSchedule()[fixedLevel][idim] > 1 )
                    {
                        lastShrinkFactorsAllOnes = false;
                        break;
                    }
                }

                // compute new velocity field
                m_RegistrationFilter->UpdateLargestPossibleRegion();
                tempField = m_RegistrationFilter->GetOutput();
                tempField->DisconnectPipeline();
                typename TFixedImage::IndexType index;
                index.Fill(10);
                std::cout << " index 10 " << tempField->GetPixel(index) << std::endl;

                // Increment level counter.  
                m_CurrentLevel++;
                movingLevel = vnl_math_min( (int) m_CurrentLevel, 
                        (int) m_MovingImagePyramids[0]->GetNumberOfLevels() );
                fixedLevel = vnl_math_min( (int) m_CurrentLevel, 
                        (int) m_FixedImagePyramids[0]->GetNumberOfLevels() );

                // Invoke an iteration event.
                this->InvokeEvent( IterationEvent() );

                // We can release data from pyramid which are no longer required.
                if ( movingLevel > 0 )
                {
                    for(int i=0;i<m_MovingImagePyramids.size();i++)
                        m_MovingImagePyramids[i]->GetOutput( movingLevel - 1 )->ReleaseData();
                }
                if( fixedLevel > 0 )
                {
                    for(int i=0;i<m_FixedImagePyramids.size();i++)
                        m_FixedImagePyramids[i]->GetOutput( fixedLevel - 1 )->ReleaseData();
                }

            } // while not Halt()

            if( !lastShrinkFactorsAllOnes )
            {
                // Some of the last shrink factors are not one
                // graft the output of the expander filter to
                // to output of this filter

                // resample the field to the same size as the fixed image
                m_FieldExpander->SetInput( tempField );
                m_FieldExpander->SetSize( 
                        fixedImage->GetLargestPossibleRegion().GetSize() );
                m_FieldExpander->SetOutputStartIndex(
                        fixedImage->GetLargestPossibleRegion().GetIndex() );
                m_FieldExpander->SetOutputOrigin( fixedImage->GetOrigin() );
                m_FieldExpander->SetOutputSpacing( fixedImage->GetSpacing());
                m_FieldExpander->SetOutputDirection( fixedImage->GetDirection());

                m_FieldExpander->UpdateLargestPossibleRegion();
                this->GraftOutput( m_FieldExpander->GetOutput() );
            }
            else
            {
                // all the last shrink factors are all ones
                // graft the output of registration filter to
                // to output of this filter
                this->GraftOutput( tempField );
            }

            // Release memory
            m_FieldExpander->SetInput( NULL );
            m_FieldExpander->GetOutput()->ReleaseData();
            m_RegistrationFilter->SetInput( NULL );
            m_RegistrationFilter->GetOutput()->ReleaseData();

        }


    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::StopRegistration()
        {
            m_RegistrationFilter->StopRegistration();
            m_StopRegistrationFlag = true;
        }

    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        bool
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::Halt()
        {
            // Halt the registration after the user-specified number of levels
            if (m_NumberOfLevels != 0)
            {
                this->UpdateProgress( static_cast<float>( m_CurrentLevel ) /
                        static_cast<float>( m_NumberOfLevels ) );
            }

            if ( m_CurrentLevel >= m_NumberOfLevels )
            {
                return true;
            }
            if ( m_StopRegistrationFlag )
            {
                return true;
            }
            else
            { 
                return false; 
            }

        }


    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GenerateOutputInformation()
        {

            typename DataObject::Pointer output;

            if( this->GetInput(0) )
            {
                // Initial velocity field is set.
                // Copy information from initial field.
                this->Superclass::GenerateOutputInformation();

            }
            else if( this->GetFixedImage(0) )
            {
                // Initial deforamtion field is not set. 
                // Copy information from the fixed image.
                for (unsigned int idx = 0; idx < 
                        this->GetNumberOfOutputs(); ++idx )
                {
                    output = this->GetOutput(idx);
                    if (output)
                    {
                        output->CopyInformation(this->GetFixedImage((int)idx/2));
                    }  
                }

            }

        }


    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GenerateInputRequestedRegion()
        {

            // call the superclass's implementation
            Superclass::GenerateInputRequestedRegion();
            for(int i=0;i<this->GetNumberOfImages();i++)
            {
                // request the largest possible region for the moving image
                MovingImagePointer movingPtr = 
                    const_cast< MovingImageType * >( this->GetMovingImage(i) );
                if( movingPtr )
                {
                    movingPtr->SetRequestedRegionToLargestPossibleRegion();
                }
            }
            // just propagate up the output requested region for
            // the fixed image and initial velocity field.
            VelocityFieldPointer inputPtr = 
                const_cast< VelocityFieldType * >( this->GetInput() );
            VelocityFieldPointer outputPtr = this->GetOutput();
            if( inputPtr )
            {
                inputPtr->SetRequestedRegion( outputPtr->GetRequestedRegion() );
            }
            for(int i=0; i< this->GetNumberOfImages();i++)
            {
                FixedImagePointer fixedPtr = 
                    const_cast< FixedImageType *>( this->GetFixedImage(i) );


                if( fixedPtr )
                {
                    fixedPtr->SetRequestedRegion( outputPtr->GetRequestedRegion() );
                }
            }
        }


    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        void
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::EnlargeOutputRequestedRegion(
                DataObject * ptr )
        {
            // call the superclass's implementation
            Superclass::EnlargeOutputRequestedRegion( ptr );

            // set the output requested region to largest possible.
            VelocityFieldType * outputPtr;
            outputPtr = dynamic_cast<VelocityFieldType*>( ptr );

            if( outputPtr )
            {
                outputPtr->SetRequestedRegionToLargestPossibleRegion();
            }

        }


    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        typename MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::DeformationFieldPointer
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GetDeformationField()
        {
            //std::cout<<"MultiImageResolutionLogDomainRegistration::GetDeformationField"<<std::endl;
            m_Exponentiator->SetInput( this->GetVelocityField() );
            m_Exponentiator->ComputeInverseOff();
            m_Exponentiator->Update();
            DeformationFieldPointer field = m_Exponentiator->GetOutput();
            field->DisconnectPipeline();
            return field;
        }


    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        typename MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::DeformationFieldPointer
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GetInverseDeformationField()
        {
            //std::cout<<"MultiImageResolutionLogDomainRegistration::GetInverseDeformationField"<<std::endl;
            m_Exponentiator->SetInput( this->GetVelocityField() );
            m_Exponentiator->ComputeInverseOn();
            m_Exponentiator->Update();
            DeformationFieldPointer field = m_Exponentiator->GetOutput();
            field->DisconnectPipeline();
            // Reset compute inverse back to off to avoid some broder effects
            m_Exponentiator->ComputeInverseOff();
            return field;
        }
    template <class TFixedImage, class TMovingImage, class TField, class TRealType>
        unsigned int
        MultiImageResolutionLogDomainRegistration<TFixedImage,TMovingImage,TField,TRealType>
        ::GetNumberOfImages()
        {
             return m_LastIndexSetMoving/2;
        }
} // end namespace itk

#endif
