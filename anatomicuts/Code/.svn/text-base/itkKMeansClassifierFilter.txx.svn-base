/*=========================================================================

Program:   Insight Segmentation & Registration Toolkit
Module:    $RCSfile: itkKMeansClassifierFilter.txx,v $
Language:  C++
Date:      $Date: 2009-05-02 05:43:58 $
Version:   $Revision: 1.1 $

Copyright (c) Insight Software Consortium. All rights reserved.
See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.

This software is distributed WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __itkKMeansClassifierFilter_txx
#define __itkKMeansClassifierFilter_txx

#include "itkKMeansClassifierFilter.h"


template< class TSample, class TMembershipFunction >
	KMeansClassifierFilter< TSample , TMembershipFunction>
::KMeansClassifierFilter()
{
	this->m_NumberOfClasses = 0;
	this->SetNumberOfRequiredOutputs( 1 );
	this->ProcessObject::SetNthOutput( 0, this->MakeOutput(0) ); 

	m_DecisionRule = NULL;
}

template< class TSample, class TMembershipFunction >
void
KMeansClassifierFilter< TSample , TMembershipFunction>
::PrintSelf(std::ostream& os, Indent indent) const
{
	Superclass::PrintSelf(os,indent);
	os << indent << "NumberofClasses: "
		<< this->GetNumberOfClasses() << std::endl;
	os << indent << "DecisionRule: "
		<< this->GetDecisionRule() << std::endl;
}

template< class TSample, class TMembershipFunction >
void
	KMeansClassifierFilter< TSample , TMembershipFunction>
::SetInput( const TSample * sample )
{
	// Process object is not const-correct so the const_cast is required here
	this->ProcessObject::SetNthInput(0,
			const_cast< SampleType * >( sample ) );
}

template< class TSample, class TMembershipFunction >
const TSample *
KMeansClassifierFilter< TSample, TMembershipFunction >
::GetInput( ) const
{
	if (this->GetNumberOfInputs() < 1)
	{
		return 0;
	}

	return static_cast<const SampleType * >
		(this->ProcessObject::GetInput(0) );
}


template< class TSample, class TMembershipFunction >
void
	KMeansClassifierFilter< TSample , TMembershipFunction>
::SetClassLabels(const ClassLabelVectorType * classLabels )
{
	// Process object is not const-correct so the const_cast is required here
	this->m_classLabels = classLabels ;
}

template< class TSample, class TMembershipFunction >
void
	KMeansClassifierFilter< TSample , TMembershipFunction>
::SetMembershipFunctions( MembershipFunctionVectorType * membershipFunctions )
{
	// Process object is not const-correct so the const_cast is required here
	this->m_membershipFunctions =membershipFunctions;
	//              membershipFunctions  );
}

template< class TSample, class TMembershipFunction >
typename KMeansClassifierFilter< TSample ,TMembershipFunction>::DataObjectPointer
	KMeansClassifierFilter< TSample , TMembershipFunction>
::MakeOutput(unsigned int)
{
	return static_cast<DataObject*>( MembershipSampleType::New().GetPointer() );
}

template< class TSample, class TMembershipFunction >
void
	KMeansClassifierFilter< TSample , TMembershipFunction>
::GenerateData()
{ 
	if( this->m_membershipFunctions->size() != this->m_NumberOfClasses )
	{
		itkExceptionMacro("Number of Membership functions does not match the number of classes");
	}

	if( this->m_classLabels->size() != this->m_NumberOfClasses )
	{
		itkExceptionMacro("Number of class labels does not match the number of classes");
	}

	if( m_DecisionRule.IsNull())
	{
		itkExceptionMacro("Decision rule is not set");
	}

	SampleType * sample=
		static_cast<  SampleType * >( this->ProcessObject::GetInput( 0 ) );

	std::vector< double > discriminantScores;
	discriminantScores.resize( this->m_NumberOfClasses );

	MembershipSampleType * output = dynamic_cast< MembershipSampleType * >(
			this->ProcessObject::GetOutput(0)); 

	output->SetSample( this->GetInput() );
	output->SetNumberOfClasses( this->m_NumberOfClasses +1); 
	double lastVariance=0;
	bool goOn = true;
	for(unsigned int k=0 ; k < this->GetNumberOfIterations() ; k++ )
	{

		double currentVariance =0;
		std::cout << " iteration  "<< k << std::endl;

		for (unsigned int i = 0; i < this->m_NumberOfClasses; i++)
		{
			(*this->m_membershipFunctions)[i]->ClearChilds();
		}

		typename TSample::Iterator iter = sample->Begin();

		typename TSample::Iterator end  = sample->End();
		while (iter != end)
		{
			typename TSample::MeasurementVectorType measurements;
			measurements = iter.GetMeasurementVector();

			for (unsigned int i = 0; i < this->m_NumberOfClasses; i++)
			{
				//           discriminantScores[i] = membershipFunctionsWeightsArray[i] * membershipFunctions[i]->Evaluate(measurements);
				discriminantScores[i] = (*this->m_membershipFunctions)[i]->Evaluate(&measurements);
	//			std::cout << " score i " << i << " "<< discriminantScores[i] << " " << (*this->m_membershipFunctions)[i]->GetNumberOfChilds();      
			}
			unsigned int classIndex;
			classIndex = m_DecisionRule->Evaluate(discriminantScores);
		
//		std::cout << " ci " << classIndex <<" ds " << discriminantScores[classIndex] ;
				//            membershipFunctions[0]->AddChild(sample[0]);
			//	if(discriminantScores[classIndex] > 0.15)//std::numeric_limits<int>::max())
				{
					(*this->m_membershipFunctions)[classIndex]->AddChild(&iter.GetMeasurementVector());
				if(k== this->GetNumberOfIterations()-1)
				{
					output->AddInstance((*this->m_classLabels)[classIndex], iter.GetInstanceIdentifier());
				}
			}
			/*else
			{
				if(k== this->GetNumberOfIterations()-1)
				{
					output->AddInstance(this->m_NumberOfClasses, iter.GetInstanceIdentifier());
				}
			
			}*/
			++iter;
		}
/*		std::cout << std::endl;
		std::cout << " recalculate centroid " << std::endl;
		for (unsigned int i = 0; i < this->m_NumberOfClasses; i++)
		{
			(*this->m_membershipFunctions)[i]->RecalculateCentroid();
			std::cout << " - cluster i " << i << " variance " << (*this->m_membershipFunctions)[i]->GetVariance() << std::endl;
			currentVariance += (*this->m_membershipFunctions)[i]->GetVariance();
		}

		currentVariance /= this->m_NumberOfClasses;
		std::cout << std::endl << " variance " << currentVariance << std::endl;
		if( currentVariance == lastVariance)
		{
			goOn = false;
		}

		//   goOn= (currentVariance != lastVariance);

		currentVariance = lastVariance;
*/
	}
}

template< class TSample, class TMembershipFunction >
const typename KMeansClassifierFilter< TSample, TMembershipFunction >::MembershipSampleType *
KMeansClassifierFilter< TSample , TMembershipFunction>
::GetOutput() const
{
	return static_cast< const MembershipSampleType * >(this->ProcessObject::GetOutput(0));
}


#endif

