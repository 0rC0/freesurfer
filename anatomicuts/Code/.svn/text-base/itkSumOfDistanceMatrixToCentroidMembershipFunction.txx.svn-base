#ifndef __itkSumOfDistanceMatrixToCentroidMembershipFunction_txx
#define __itkSumOfDistanceMatrixToCentroidMembershipFunction_txx

#include <iostream>

#include <fstream>
#include "vnl/vnl_matrix.h"
#include "vnl/vnl_math.h"
#include "math.h"
#include <vnl/vnl_matrix.h>

#include "itkSumOfDistanceMatrixToCentroidMembershipFunction.h"


template < class TVector >
	SumOfDistanceMatrixToCentroidMembershipFunction< TVector >
::SumOfDistanceMatrixToCentroidMembershipFunction()
{
}
template < class TVector >
double 
	SumOfDistanceMatrixToCentroidMembershipFunction< TVector >
::Evaluate(const MeasurementVectorType *measurement) const
{
	return this->Evaluate(this->GetCentroid(), measurement);
}
template < class TVector >
double 
	SumOfDistanceMatrixToCentroidMembershipFunction< TVector >
::Evaluate(const MeasurementVectorType *m1, const MeasurementVectorType *m2 ) const
{
	double dist=0;	
	double dist2=0;	
	
	int numPoints = m2->Size();
	int points=0;
	for(int i=0;i<numPoints;i++)
	{
		//		std::cout << (*m1)[i]  << " " << (*m2)[i] << std::endl;
		if((*m1)[i] != 0 && (*m2)[i] != 0 )
		{
			dist+= (*this->m_distances)( (*m1)[i] ,(*m2)[i]); 
			points++;
		}
		if((*m1)[i] != 0 && (*m2)[numPoints-1- i] != 0 )
		{ 
			dist2+= (*this->m_distances)((*m1)[i] , (*m2)[numPoints-1-i]);	
		}
	}	

/*	if(min(dist,dist2)==0)
	{
		for(int i=0;i<numPoints;i++)
		{
			std::cout << (*m1)[i] << " "; 
		}
		std::cout << std::endl;
	}*/
	return min(dist, dist2)/points; 
}


template < class TVector >
void  
	SumOfDistanceMatrixToCentroidMembershipFunction< TVector >
::AddChild(const MeasurementVectorType* child) 
{
	childs.push_back(child);
}
template < class TVector >
void  
	SumOfDistanceMatrixToCentroidMembershipFunction< TVector >
::RecalculateCentroid() 
{

	this->m_Variance = 0;
	double minDist =  numeric_limits<double>::max();

	for(unsigned int i=0; i< this->childs.size(); i++)
	{
		double min_i = 0;
		for(unsigned int j=0; j< this->childs.size() ; j++)
		{
			double D = this->Evaluate(childs[i], childs[j]);
//			std::cout << D << " ";
			min_i += D*D;

		}

		if( min_i < minDist )
		{
			minDist = min_i;
			this->SetCentroid(this->childs[i]);
		}
	}
//	std::cout << std::endl;
	this->m_Variance =  minDist/this->childs.size();
}

template < class TVector >
void  
SumOfDistanceMatrixToCentroidMembershipFunction< TVector >
::PrintSelf(std::ostream& os, Indent indent) const
{
	Superclass::PrintSelf(os,indent);
}


#endif
