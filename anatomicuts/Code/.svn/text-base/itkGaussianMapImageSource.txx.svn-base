#ifndef _itk_GaussianMapImageSource_txx_
#define _itk_GaussianMapImageSource_txx_

#include "itkGaussianMapImageSource.h"

#include <itkImageRegionIterator.h>
#include <itkImageIterator.h>
#include <itkImageRegionConstIteratorWithIndex.h>
#include <itkGaussianSpatialFunction.h>
#include <algorithm>
#include <iostream>
namespace itk
{

  template<class TOutputImage>
  GaussianMapImageSource<TOutputImage>
  ::GaussianMapImageSource()
  {
    
    this->m_OutputSpacing.Fill(1.0);
    this->m_OutputOrigin.Fill(0.0);
    this->m_OutputDirection.SetIdentity();

    for (unsigned int i=0; i<TOutputImage::ImageDimension; i++)
      m_Sigma[i] = 1.0;
    m_Tree = 0;
    m_Sample = SampleType::New();

    SizeType size;
    size.Fill( 0 );
    this->m_OutputRegion.SetSize( size );
    
    IndexType index;
    index.Fill( 0 );
    this->m_OutputRegion.SetIndex( index );
  }


  template<class TOutputImage>
  void
  GaussianMapImageSource<TOutputImage>
  ::BeforeThreadedGenerateData()
  {
    /** Setup the K-d tree search */
    m_Sample->Clear();
    m_Sample->SetMeasurementVectorSize( 3 );
    MeasurementVectorType mv;
    for ( unsigned int n = 0; n<m_Points.size(); n++)
    {
      mv[0] = m_Points[n][0];
      mv[1] = m_Points[n][1];
      mv[2] = m_Points[n][2];
      m_Sample->PushBack( mv );
    }  
  }


  // Set the output image size.
  template <class TOutputImage>
  void 
  GaussianMapImageSource<TOutputImage>
  ::SetOutputSize( const SizeType & size )
  {
    this->m_OutputRegion.SetSize( size );
  }


  // Get the output image size.
  template <class TOutputImage>
  const typename GaussianMapImageSource<TOutputImage>
  ::SizeType &
  GaussianMapImageSource<TOutputImage>
  ::GetOutputSize()
  {
    return this->m_OutputRegion.GetSize();
  }


  // Set the output image index.
  template <class TOutputImage>
  void 
  GaussianMapImageSource<TOutputImage>
  ::SetOutputIndex( const IndexType & index )
  {
    this->m_OutputRegion.SetIndex( index );
  }


  // Get the output image index.
  template <class TOutputImage>
  const typename GaussianMapImageSource<TOutputImage>
  ::IndexType &
  GaussianMapImageSource<TOutputImage>
  ::GetOutputIndex()
  {
    return this->m_OutputRegion.GetIndex();
  }


  // Set the output image spacing.
  template <class TOutputImage>
  void 
  GaussianMapImageSource<TOutputImage>
  ::SetOutputSpacing( const double* spacing )
  {
    SpacingType s( spacing );
    this->SetOutputSpacing( s );
  }


  // Set the output image origin.
  template <class TOutputImage>
  void 
  GaussianMapImageSource<TOutputImage>
  ::SetOutputOrigin( const double* origin )
  {
    PointType p( origin );
    this->SetOutputOrigin( p );
  }
  
  // Helper method to set the output parameters based on this image
  template <class TOutputImage>
  void 
  GaussianMapImageSource<TOutputImage>
  ::SetOutputParametersFromImage ( const ImageBaseType * image )
  {
    if( !image )
    {
      itkExceptionMacro(<< "Cannot use a null image reference");
    }
    
    this->SetOutputOrigin( image->GetOrigin() );
    this->SetOutputSpacing( image->GetSpacing() );
    this->SetOutputDirection( image->GetDirection() );
    this->SetOutputRegion( image->GetLargestPossibleRegion() );
  }


  // Inform pipeline of required output region
  template <class TOutputImage>
  void 
  GaussianMapImageSource<TOutputImage>
  ::GenerateOutputInformation( void )
  {
    // call the superclass' implementation of this method
    Superclass::GenerateOutputInformation();
    
    // get pointer to the output
    typename OutputImageType::Pointer outputPtr = this->GetOutput();
    if ( !outputPtr )
    {
      return;
    }
    
    outputPtr->SetLargestPossibleRegion( m_OutputRegion );    
    outputPtr->SetSpacing( m_OutputSpacing );
    outputPtr->SetOrigin( m_OutputOrigin );
    outputPtr->SetDirection( m_OutputDirection );
  }

  
  
  template<class TOutputImage>
    void
    GaussianMapImageSource<TOutputImage>
    ::ThreadedGenerateData(const OutputImageRegionType &outputRegionForThread, int threadId)
    {
  //  std::cout << " gausian map start " ;
      typedef ImageRegionIterator<OutputImageType>               OutputImageIteratorType;

      OutputImageIteratorType itOut(this->GetOutput(), outputRegionForThread);

      typename FunctionType::Pointer function = FunctionType::New(); // one must be created for each thread
      function->SetSigma ( m_Sigma );
      
      double radius = 1.0 * std::max(std::max(m_Sigma[0],m_Sigma[1]),m_Sigma[2]);
    //  std::cout << "radius " << radius << std::endl;
      TreeGeneratorType::Pointer treeGenerator = TreeGeneratorType::New();
      treeGenerator->SetSample( m_Sample );
      treeGenerator->SetBucketSize( 100 ); // to check
      treeGenerator->Update();

      typename TreeType::Pointer tree = treeGenerator->GetOutput();

      while(!itOut.IsAtEnd())
      {
        OutputPixelType out = static_cast<OutputPixelType>( 0.0 );

        IndexType index = itOut.GetIndex();
        PointType pt;
        this->GetOutput()->TransformIndexToPhysicalPoint(index, pt);

        MeasurementVectorType queryPoint;
        for (int i=0; i<TOutputImage::ImageDimension; i++)
          queryPoint[i] = pt[i];

        TreeType::InstanceIdentifierVectorType neighbors;
        tree->Search( queryPoint, radius, neighbors ) ;
        /*if( neighbors.size()>0)
        {
          std::cout << " neighbors " << neighbors.size() << std::endl;
        }*/
        for ( unsigned int n = 0 ; n < neighbors.size() && out <1.0 ; n++ )        
        {	  
          PointType p_mean = m_Points[ neighbors[n] ];

          typename FunctionType::ArrayType mean;
          for (int i=0; i<TOutputImage::ImageDimension; i++)
            mean[i] = p_mean[i];

          function->SetMean(mean);
            
          out += function->Evaluate(pt);
//std::cout << out << std::endl;          
        }

        if (out>1.0)
          out = 1.0;

        itOut.Set(out);

        ++itOut;
      }
      //  std::cout << " gausian map end" << std::endl;
    }

  
  template<class TOutputImage>
  void
  GaussianMapImageSource<TOutputImage>
  ::AfterThreadedGenerateData()
  {
/*    typename MinMaxCalculatorType::Pointer calculator = MinMaxCalculatorType::New();
    calculator->SetImage ( this->GetOutput() );
    
    try
    {
      calculator->Compute();
    }
    catch (ExceptionObject &e)
    {
      std::cerr << e;
      throw ExceptionObject (__FILE__,__LINE__,"Error while calculating image min/max");
    }
    
    OutputPixelType maximum = calculator->GetMaximum();

    if (maximum==0.0)
      return;
    
    
    typename ScaleImageFilterType::Pointer scaler = ScaleImageFilterType::New();
    scaler->SetInput ( this->GetOutput() );
    scaler->SetScale ( 1.0 / maximum );
    try
    {
      scaler->Update();
    }
    catch (ExceptionObject &e)
    {
      std::cerr << e;
      throw ExceptionObject (__FILE__,__LINE__,"Error while scaling image");
    }
    
    this->GraftOutput (scaler->GetOutput());
  */  
    /*    
    calculator->SetImage ( this->GetOutput() );
    try
    {
      calculator->Compute();
    }
    catch (ExceptionObject &e)
    {
      std::cerr << e;
      throw ExceptionObject (__FILE__,__LINE__,"Error while calculating image min/max");
    }
    
    OutputPixelType new_maximum = calculator->GetMaximum();
    
    std::cout << "GaussianMapFilter::AfterThreadedGenerateData " << std::endl << "max value gauss "<< maximum <<  " segundo max "<< new_maximum <<  std::endl;
    */
  }
  
} // end of namespace itk


#endif
