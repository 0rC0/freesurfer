#ifndef _itk_RemoveTipPolyLineMeshFilter_txx_
#define _itk_RemoveTipPolyLineMeshFilter_txx_

#include "itkRemoveTipPolyLineMeshFilter.h"
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include "itkMesh.h"
#include "itkMeshSource.h"
#include "itkPolylineCell.h"

#include <vtkPolyData.h>
#include <vtkSmartPointer.h>

namespace itk
{

  template <class TInputMesh,class TOutputMesh>
  RemoveTipPolylineMeshFilter<TInputMesh,TOutputMesh>
  ::RemoveTipPolylineMeshFilter()
  {
  }


  template <class TInputMesh,class TOutputMesh>
  void
  RemoveTipPolylineMeshFilter<TInputMesh,TOutputMesh>
  ::GenerateData()
  {
    const InputMeshType *input = this->GetInput();

    if (input->GetNumberOfCells()==0) // in case no cell is found in the input, just return (empty output)
    {
      return;
    }

    typename InputCellsContainer::ConstIterator inputCellIt = input->GetCells()->Begin();

    int cellId =0;
    OutputMeshPointer output = this->GetOutput();
    output->SetCellsAllocationMethod(OutputMeshType::CellsAllocatedDynamicallyCellByCell);
    typedef typename TOutputMesh::CellType        CellType;
    typedef PolylineCell<CellType>                      PolylineCellType;

    int index=0;
    for ( ; inputCellIt!=input->GetCells()->End(); ++inputCellIt)
    {

//	    OutputCellAutoPointer outputCell;
	  //  inputCellIt.Value()->MakeCopy ( outputCell );
      OutputCellAutoPointer line;
      line.TakeOwnership ( new PolylineCellType );

//      offset += inputCellIt.Value()->GetNumberOfPoints();
      double lenghtSoFar = 0;
//      std::cout << " max lenght " << this->GetTipLenght() << std::endl;
      InputPointType firstPt;
      firstPt.Fill(0);
      typename OutputCellType::PointIdIterator it = inputCellIt.Value()->PointIdsBegin();
      typename OutputCellType::PointIdIterator firstPtIt = inputCellIt.Value()->PointIdsBegin();
      input->GetPoint(*it,&firstPt);
      for(it ; it!=inputCellIt.Value()->PointIdsEnd(); it++)
      {
//          std::cout << " lenght so far " << lenghtSoFar << std::endl;
        if(lenghtSoFar < this->GetTipLenght())
        {
          InputPointType pt;
          pt.Fill(0);
          input->GetPoint(*it,&pt);
          lenghtSoFar+= firstPt.EuclideanDistanceTo(pt);
 //         std::cout << pt << "  " << firstPt << std::endl;  
          firstPt = pt;
          //firstPt.Fill(0);
          //input->GetPoint(*it,&firstPt);
          firstPtIt = it;
        }
        else
        {
          break;
        }
      }

      lenghtSoFar = 0;
      InputPointType lastPt;
      lastPt.Fill(0);
      it = inputCellIt.Value()->PointIdsEnd();
      typename OutputCellType::PointIdIterator lastPtIt = inputCellIt.Value()->PointIdsEnd();
      input->GetPoint(*it,&lastPt);
      for(it ; it!=inputCellIt.Value()->PointIdsBegin(); it--)
      {
 //         std::cout << " lenght so far " << lenghtSoFar << std::endl;
        if(lenghtSoFar < this->GetTipLenght())
        {
          InputPointType pt;
          pt.Fill(0);
          input->GetPoint(*it,&pt);
          lenghtSoFar+= lastPt.EuclideanDistanceTo(pt);
//          input->GetPoint(*it,&lastPt);
          lastPt = pt;
          lastPtIt = it;
        }
        else
        {
          break;
        }
      }
      for (it = firstPtIt; it!=lastPtIt; it++)
	    {
        InputPointType pt;
		    pt.Fill (0.0);
		    input->GetPoint (*it, &pt);
//        std::cout << " pt " << pt << std::endl;
        output->SetPoint (index, pt);
//        std::cout << "index: " <<  index << std::endl;
	  
        line->SetPointId (index, index);
        index++;
	    }    
	  
//    std::cout << "chau" << std::endl;
      output->SetCell (cellId, line);
	    cellId++;
    }
    // this->CopyInputMeshToOutputMeshPointData();
  }

}

#endif
