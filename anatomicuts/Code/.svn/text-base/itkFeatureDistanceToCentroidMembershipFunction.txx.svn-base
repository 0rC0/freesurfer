#ifndef __itkFeatureDistanceToCentroidMembershipFunction_txx
#define __itkFeatureDistanceToCentroidMembershipFunction_txx

#include <iostream>

#include <fstream>
#include "vnl/vnl_matrix.h"
#include "vnl/vnl_math.h"
#include "math.h"
#include <vnl/vnl_matrix.h>

#include "itkFeatureDistanceToCentroidMembershipFunction.h"


template < class TVector >
	FeatureDistanceToCentroidMembershipFunction< TVector >
::FeatureDistanceToCentroidMembershipFunction()
{
	this->m_Variance = 0 ;
}
template < class TVector >
double 
FeatureDistanceToCentroidMembershipFunction< TVector >
::Evaluate(const MeasurementVectorType *measurement) const
{
	return this->Evaluate(this->GetCentroid(), measurement);
}
template < class TVector >
double 
FeatureDistanceToCentroidMembershipFunction< TVector >
::Evaluate(const MeasurementVectorType *m1, const MeasurementVectorType *m2 ) const
{
	double dist=0.0;	
	typedef typename MeasurementVectorType::CellType CellType;
	typedef typename CellType::const_iterator	MapIterator;
	MapIterator iter = m1->GetLabels()->begin();
	MapIterator iter2 = m2->GetLabels()->begin();

	//	std::cout << " size " <<  m1->GetLabels()->size() << std::endl;
	const CellType* labels1 = m1->GetLabels();
	const CellType* labels2 = m2->GetLabels();
/*	float direction = 0;
//	std::cout << labels1->find(0*(-1))->second << " " <<  labels2->find(0*(-1))->second << std::endl;
	for(unsigned int i=0;i<m_directionalNeighbors.size();i++)
	{

		if(labels1->find(i*(-1))->second == labels2->find(i*(-1))->second)
		{
			direction+=1;
		}

	}
	direction/=6.0;
*/
	while(iter != labels1->end())
	{
		if(iter->first >0)
		{
			std::pair<MapIterator, MapIterator> eq_range = labels2->equal_range(iter->first);
			//		while(iter2 != labels2->end())
			for(MapIterator iter2 = eq_range.first; iter2 != eq_range.second;iter2++)
			{
				/*both zero, means the fiber passes throught that label*/
				//if(iter.first == iter2.first && 
				if(iter->second ==0 &&  iter2->second  == 0 )
				{
					dist++;//=direction;
				}
				else
				{
					/*if the second value is not zero, its a label of a neighbor
					  we want to check if both are neigbors of that label, and caming from the same direction (posterior, anterior, etc) 
					  posterior(i,j)=1 that for i, j is on the posterior side*/
/*
					for(unsigned int i=0;i<m_directionalNeighbors.size();i++)
					{

						int val = (*this->m_directionalNeighbors[labels1->find(i*(-1))->second])(iter->second,iter->first);
						int val2 = (*this->m_directionalNeighbors[labels2->find(i*(-1))->second])(iter2->second, iter2->first);
*/						/*chequing that iter->second == iter2->second makes the metric check that labels are both posterior neighbors, but neigbors from the same label too (iter->second)*/
/*						if(val==1 && val2==1  && iter->second == iter2->second)
						{

//							dist+=direction;///6.0;
						}
					}
*/

				}
			}
		}

		iter++;
	}
	if( labels1->size() == 0 || labels2->size() == 0 )
	{
		std::cout << " ouch cero labels" << std::endl;
	}
//std::cout << " dist " << labels2->size() << " " << labels1->size() << "  " << dist << std::endl;	
	return  (labels2->size()+labels1->size())/(dist+1); 
//	return -dist;
}


template < class TVector >
void  
	FeatureDistanceToCentroidMembershipFunction< TVector >
::AddChild(const MeasurementVectorType* child) 
{
	this->m_Variance += this->Evaluate(child);

	childs.push_back(child);
}
template < class TVector >
void  
	FeatureDistanceToCentroidMembershipFunction< TVector >
::RecalculateCentroid() 
{
	double var = this->GetVariance();
	if(this->childs.size() > 0)
	{
		double minDist =  numeric_limits<double>::max();
		int offset = this->childs.size()/50;
		for(unsigned int i=0; i< this->childs.size(); i++)
		{
			double min_i = 0;
//			int offset2= this->childs.size();
			for(unsigned int j=0; j< this->childs.size() ; j++)
			{
				double D = this->Evaluate(childs[i], childs[j]);
				min_i += D*D;

			}

			min_i /= this->childs.size();

			min_i =pow(var - min_i,2);		
			if(  min_i < minDist )
			{
				minDist = min_i;
				this->SetCentroid(this->childs[i]);
			}
			i+=offset;
		}

		this->m_Variance =  minDist/this->childs.size();
	}
}

template < class TVector >
void  
FeatureDistanceToCentroidMembershipFunction< TVector >
::PrintSelf(std::ostream& os, Indent indent) const
{
	Superclass::PrintSelf(os,indent);
}


#endif
