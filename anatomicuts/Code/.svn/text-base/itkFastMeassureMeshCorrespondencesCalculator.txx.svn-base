#ifndef _itk_FastMeassureMeshCorrespondencesCalculator_txx
#define _itk_FastMeassureMeshCorrespondencesCalculator_txx

#include "itkFastMeassureMeshCorrespondencesCalculator.h"
#include "itkTransformMeshPointsFilter.h"
#include <iostream>
#include <limits>
#include <utility>
#include <algorithm>

#include <fstream>
#include "vnl/vnl_matrix.h"
#include "vnl/vnl_math.h"
#include "math.h"

#include "interpolation.h"
#include <itkGaussianSpatialFunction.h>
#include <climits>
using namespace alglib;


namespace itk
{

  template< class TFixedMesh, class TMovingMesh > 
    FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::FastMeassureMeshCorrespondencesCalculator()
    {
      this->lastMetric = INT_MAX;
    }

  template< class TFixedMesh, class TMovingMesh >
    void
    FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::Evaluate ()
    {
      std::cout << " evaluate fast meassures " << std::endl;
      if (!this->GetFixedMesh() || !this->GetMovingMesh())
        itkExceptionMacro (<< "Fixed and/or moving mesh not set");

      this->m_vecP.clear();
      this->m_vecV.clear();
      this->m_metric.clear();

      float sigmaSquared = pow(this->GetSigma(),2);

      float normVal = sigmaSquared; // (mp.size()+ fp.size());
      for(typename SampleType::Iterator iterMvg= m_MovingSample->Begin(); iterMvg != m_MovingSample->End(); ++iterMvg)
      {
        MeasurementVectorType m = iterMvg.GetMeasurementVector();
        TreeType::InstanceIdentifierVectorType neighbors;
        m_MovingTree->Search( m, this->GetRadio(), neighbors ) ;
        MovingVectorType corr ; //= new MovingVectorType();
		MovingVectorType corr2 ; //= new MovingVectorType();
		double normWeights=1, normWeights2 = 1; 
        corr.Fill(0);
        corr2.Fill(0);

        for ( unsigned int i = 0 ; i < neighbors.size() ; ++i )
        {
          MeasurementVectorType m2 = m_MovingTree->GetMeasurementVector( neighbors[i] );
          float vecNorm =pow(m[0]-m2[0],2)+pow(m[1]-m2[1],2)+pow(m[2]-m2[2],2);
          float norm = -2 *exp(- vecNorm/(2.*sigmaSquared))*m.GetValue()*m2.GetValue();
          
          corr[0] += norm*(m[0]-m2[0])/normVal;
          corr[1] += norm*(m[1]-m2[1])/normVal;
          corr[2] += norm*(m[2]-m2[2])/normVal;
		  //normWeights+= m.GetValue()*m2.GetValue();
        }

        m_FixedTree->Search( m, this->GetRadio(), neighbors ) ;

        for ( unsigned int i = 0 ; i < neighbors.size() ; ++i )
        {
          MeasurementVectorType f2 = m_FixedTree->GetMeasurementVector( neighbors[i] );
          float vecNorm =pow(m[0]-f2[0],2)+pow(m[1]-f2[1],2)+pow(m[2]-f2[2],2);
          float norm = 2 *exp(- vecNorm/(2.*sigmaSquared))*m.GetValue()*f2.GetValue();
          
          corr2[0] += norm*(m[0]-f2[0])/normVal;
          corr2[1] += norm*(m[1]-f2[1])/normVal;
          corr2[2] += norm*(m[2]-f2[2])/normVal;
		  //normWeights2+= m.GetValue()*f2.GetValue();

        }
        
        MovingPointType p;
        for(unsigned int i=0; i<3; i++)
		{
			p[i] = m[i];
       		corr[i]= corr[i]/normWeights+corr2[i]/normWeights2;
		}
        this->m_vecP.push_back(p );
        this->m_vecV.push_back(corr);
        this->m_metric.push_back(0);
      }
      std::cout << " end evaluate fast meassures " << std::endl;
    }
  template< class TFixedMesh, class TMovingMesh >
    void
    FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::EvaluateTimes (int times, float epsilon)
    {
      if (!this->GetFixedMesh() || !this->GetMovingMesh())
        itkExceptionMacro (<< "Fixed and/or moving mesh not set");

      this->m_vecP.clear();
      this->m_vecV.clear();
      this->m_metric.clear();

      for(int t=0;t<times;t++)
      {
        float sigmaSquared = pow(this->GetSigma(),2);
        SampleType::Pointer newSample = SampleType::New();
        newSample->SetMeasurementVectorSize( 3 );
        int j=0;

        float normVal = sigmaSquared; // (mp.size()+ fp.size());
      for(typename SampleType::Iterator iterMvg= m_MovingSample->Begin(); iterMvg != m_MovingSample->End(); ++iterMvg)
      {
        MeasurementVectorType m = iterMvg.GetMeasurementVector();
        TreeType::InstanceIdentifierVectorType neighbors;
        m_MovingTree->Search( m, this->GetRadio(), neighbors ) ;
        MovingVectorType corr ; //= new MovingVectorType();
        corr.Fill(0);

        for ( unsigned int i = 0 ; i < neighbors.size() ; ++i )
        {
          MeasurementVectorType m2 = m_MovingTree->GetMeasurementVector( neighbors[i] );
          float vecNorm =pow(m[0]-m2[0],2)+pow(m[1]-m2[1],2)+pow(m[2]-m2[2],2);
          float norm = -2 *exp(- vecNorm/(2.*sigmaSquared))*m.GetValue()*m2.GetValue();
          
          corr[0] += norm*(m[0]-m2[0])/normVal;
          corr[1] += norm*(m[1]-m2[1])/normVal;
          corr[2] += norm*(m[2]-m2[2])/normVal;

        }

        m_FixedTree->Search( m, this->GetRadio(), neighbors ) ;

        for ( unsigned int i = 0 ; i < neighbors.size() ; ++i )
        {
          MeasurementVectorType f2 = m_FixedTree->GetMeasurementVector( neighbors[i] );
          float vecNorm =pow(m[0]-f2[0],2)+pow(m[1]-f2[1],2)+pow(m[2]-f2[2],2);
          float norm = 2 *exp(- vecNorm/(2.*sigmaSquared))*m.GetValue()*f2.GetValue();
          
          corr[0] += norm*(m[0]-f2[0])/normVal;
          corr[1] += norm*(m[1]-f2[1])/normVal;
          corr[2] += norm*(m[2]-f2[2])/normVal;

        }
          corr[0] = epsilon*corr[0];
          corr[1] = epsilon*corr[1];
          corr[2] = epsilon*corr[2];

           if(t==0)
          {
            MovingPointType p;
            p[0] = m[0];
            p[1] = m[1];
            p[2] = m[2];
            this->m_vecP.push_back(p );
            this->m_vecV.push_back(corr);
            this->m_metric.push_back(0);
          }
          else
          {
            this->m_vecV[j][0]+=corr[0];
            this->m_vecV[j][1]+=corr[1];
            this->m_vecV[j][2]+=corr[2];
          }
          j++;
          MeasurementVectorType mc;
          for(int i=0;i<3;i++)
          {
            mc[i] = m[i]- corr[i];
          }
          mc.SetValue(m.GetValue());
          newSample->PushBack(mc);
        }
        m_MovingSample = newSample;
        m_MovingTree = GenerateTree(newSample);
      }
 
  }
 template< class TFixedMesh, class TMovingMesh >
    double 
    FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::Distance ()
    {
      double metric1,metric2,metric3 =0;
      float sigmaSquared = pow(this->GetSigma(),2);
      
      
      double normWeights1=1, normWeights2=1,normWeights3 = 1; 
      for(typename SampleType::Iterator iterMvg= m_MovingSample->Begin(); iterMvg != m_MovingSample->End(); ++iterMvg)
      {
        MeasurementVectorType m = iterMvg.GetMeasurementVector();
        TreeType::InstanceIdentifierVectorType neighbors;
        m_MovingTree->Search( m, this->GetRadio(), neighbors ) ;

        for ( unsigned int i = 0 ; i < neighbors.size() ; ++i )
        {
          MeasurementVectorType m2 = m_MovingTree->GetMeasurementVector( neighbors[i] );
          float vecNorm =pow(m[0]-m2[0],2)+pow(m[1]-m2[1],2)+pow(m[2]-m2[2],2);
          metric1 +=  exp(- vecNorm/(2.*sigmaSquared))*m.GetValue()*m2.GetValue();
		  //normWeights1+= m.GetValue()*m2.GetValue();
        }

        TreeType::InstanceIdentifierVectorType neighbors2;
        m_FixedTree->Search( m, this->GetRadio(), neighbors2 ) ;

        for ( unsigned int i = 0 ; i < neighbors2.size() ; ++i )
        {
          MeasurementVectorType f2 = m_FixedTree->GetMeasurementVector( neighbors2[i] );
          float vecNorm =pow(m[0]-f2[0],2)+pow(m[1]-f2[1],2)+pow(m[2]-f2[2],2);
          metric2 -= 2 *exp(- vecNorm/(2.*sigmaSquared))*m.GetValue()*f2.GetValue();
		  //normWeights2+= m.GetValue()*f2.GetValue();
        }

      }
            
      for(typename SampleType::Iterator iterFxd = m_FixedSample->Begin(); iterFxd != m_FixedSample->End();++iterFxd)
      {
        MeasurementVectorType f = iterFxd.GetMeasurementVector();
        TreeType::InstanceIdentifierVectorType neighbors;
        m_FixedTree->Search( f, this->GetRadio(), neighbors ) ;

        for ( unsigned int i = 0 ; i < neighbors.size() ; ++i )
        {
          MeasurementVectorType f2 = m_FixedTree->GetMeasurementVector( neighbors[i] );
          float vecNorm =pow(f[0]-f2[0],2)+pow(f[1]-f2[1],2)+pow(f[2]-f2[2],2);
          metric3 +=  exp(- vecNorm/(2.*sigmaSquared))*f.GetValue()*f2.GetValue();
		  //normWeights3+= f.GetValue()*f2.GetValue();
         
		}
      }
		return metric1+metric2+metric3;
//      this->RecalculateSigma();
    //  return metric;
    }
  template< class TFixedMesh, class TMovingMesh >
    void
    FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::RecalculateSigma()
    {

	this->SetSigma( this->GetSigma()-0.01*this->GetSigma());     	
std::cout << " sigma " << this->GetSigma() << std::endl;	
    }
  template< class TFixedMesh, class TMovingMesh >
typename  FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >::SamplePointer
    FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::GenerateSample(FixedMeshPointer mesh)
    {
	//float norm=1.0;  
 typedef typename TFixedMesh::CellDataContainer CellDataContainer;
      typename CellDataContainer::ConstIterator fxdCellData =mesh->GetCellData()->Begin();
        float norm = 0.0;
     for(;fxdCellData!= mesh->GetCellData()->End(); ++fxdCellData)
      {
        if(norm < fxdCellData.Value())
        {
          norm = fxdCellData.Value();
        }
      }
     if(norm==0)
 	norm=1;
     else
	norm = 1./norm;

//  TreeType::Pointer                m_Tree;
      SampleType::Pointer              sample;

      //m_Tree = 0;
      sample = SampleType::New();
      sample->SetMeasurementVectorSize( 3 );

      typedef typename TFixedMesh::CellsContainer CellsContainer;
      typename CellsContainer::ConstIterator cellIt = mesh->GetCells()->Begin();
      typename CellDataContainer::ConstIterator cellData = mesh->GetCellData()->Begin();
/*	if(mesh->GetCellData()->Begin()!=mesh->GetCellData()->End())
{*/
	  for(;cellIt!= mesh->GetCells()->End(); ++cellIt,++cellData)
      {
        typename TFixedMesh::CellTraits::PointIdIterator  pointIdIt  = cellIt.Value()->PointIdsBegin();
        for(;pointIdIt != cellIt.Value()->PointIdsEnd();pointIdIt++)
        {
          typename TFixedMesh::PointType pt;  
          mesh->GetPoint(*pointIdIt, &pt);
          MeasurementVectorType mv;
          for(int i=0;i<3;i++)
          {
            mv[i] = pt[i];
          }
          mv.SetValue(cellData.Value()*norm);
          sample->PushBack( mv );
        }
      }
 /* }
else
{
	  for(;cellIt!= mesh->GetCells()->End(); ++cellIt)
      {
        typename TFixedMesh::CellTraits::PointIdIterator  pointIdIt  = cellIt.Value()->PointIdsBegin();
        for(;pointIdIt != cellIt.Value()->PointIdsEnd();pointIdIt++)
        {
          typename TFixedMesh::PointType pt;  
          mesh->GetPoint(*pointIdIt, &pt);
          MeasurementVectorType mv;
          for(int i=0;i<3;i++)
          {
            mv[i] = pt[i];
          }
          mv.SetValue(1);
          sample->PushBack( mv );
        }
      }

}*/
      return sample;
  }  
  template< class TFixedMesh, class TMovingMesh >
typename  FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >::TreeTypePointer
    FastMeassureMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::GenerateTree(SamplePointer s)
    {
      TreeGeneratorType::Pointer treeGenerator = TreeGeneratorType::New();
      treeGenerator->SetSample( s );
      treeGenerator->SetBucketSize( 10 ); // to check
      treeGenerator->Update();

      return treeGenerator->GetOutput();

    }
  }

#endif
