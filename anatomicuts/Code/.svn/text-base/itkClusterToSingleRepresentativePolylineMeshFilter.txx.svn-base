#ifndef _itk_ClusterToSingleRepresentativePolylineMeshFilter_txx_
#define _itk_ClusterToSingleRepresentativePolylineMeshFilter_txx_

#include "itkClusterToSingleRepresentativePolylineMeshFilter.h"
#include <algorithm>

namespace itk
{

  template <class TInputMesh, class TOutputMesh>
    ClusterToSingleRepresentativePolylineMeshFilter<TInputMesh, TOutputMesh>
    ::ClusterToSingleRepresentativePolylineMeshFilter()
    {
    }


  template <class TInputMesh, class TOutputMesh>
    void
    ClusterToSingleRepresentativePolylineMeshFilter<TInputMesh, TOutputMesh>
    ::GenerateData()
    {
      const InputMeshType *input = this->GetInput();

      if (input->GetNumberOfCells()==0) // in case no cell is found in the input, just return (empty output)
      {
        return;
      }

      typename InputCellsContainer::ConstIterator inputCellIt = input->GetCells()->Begin();

      InputMeshCellType *bestCell = inputCellIt.Value();
      double             bestDist = std::numeric_limits<double>::max();

      for ( ; inputCellIt!=input->GetCells()->End(); ++inputCellIt)
      {
        double total_dist = 0.0;

        typename InputCellsContainer::ConstIterator candidateCellIt = input->GetCells()->Begin();
        for ( ; candidateCellIt!=input->GetCells()->End(); ++candidateCellIt)
        {
          if (candidateCellIt.Value()==inputCellIt.Value())
          {
            continue;
          }

          // compute distance between cell and candidateCellIt
          total_dist += std::max(this->Distance (inputCellIt.Value(), candidateCellIt.Value()) , this->Distance(candidateCellIt.Value(), inputCellIt.Value()));
        }

        if (total_dist<bestDist)
        {
          bestCell = inputCellIt.Value();
          bestDist = total_dist;
        }
      }

      // bestCell is the best cell: fill output with it
      OutputMeshPointer output = this->GetOutput();

      OutputCellAutoPointer outputCell;
      bestCell->MakeCopy ( outputCell );

      int index = 0;
      for (typename OutputCellType::PointIdIterator it = outputCell->PointIdsBegin(); it!=outputCell->PointIdsEnd(); it++)
      {
        InputPointType pt;
        pt.Fill (0.0);
        input->GetPoint (*it, &pt);
        output->SetPoint (index, pt);
        outputCell->SetPointId (index, index);
        index++;
      }    
      output->SetCell (0, outputCell);

      // this->CopyInputMeshToOutputMeshPointData();
    }


  template <class TInputMesh, class TOutputMesh>
    double
    ClusterToSingleRepresentativePolylineMeshFilter<TInputMesh, TOutputMesh>
    ::Distance(InputMeshCellType *cell1, InputMeshCellType *cell2)
    {
      const InputMeshType *input = this->GetInput();

      double total_dist = 0.0;

      typename InputMeshCellType::PointIdIterator it1 = cell1->PointIdsBegin();
      for (; it1!=cell1->PointIdsEnd(); it1++)
      {
        InputPointType point1;
        input->GetPoint (*it1, &point1);

        double min_dist = std::numeric_limits<double>::max();

        typename InputMeshCellType::PointIdIterator it2 = cell2->PointIdsBegin();
        for (; it2!=cell2->PointIdsEnd(); it2++)
        {
          InputPointType point2;
          input->GetPoint (*it2, &point2);

          double dd = point1.SquaredEuclideanDistanceTo (point2);
          if (dd<min_dist)
            min_dist = dd;
        }

        total_dist += min_dist;
      }

      return total_dist/static_cast<double>(cell1->GetNumberOfPoints());
    }

}

#endif
