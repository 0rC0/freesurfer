#ifndef _itk_ClosestPointMeshMatchingMap_txx_
#define _itk_ClosestPointMeshMatchingMap_txx_

#include "interpolation.h"
#include "itkClosestPointMeshMatchingMap.h"
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include "itkImageRegionIteratorWithIndex.h"

namespace itk
{
  template <class TInputMesh, class TOutputMesh, class TImage>
    void
    ClosestPointMeshMatchingMap<TInputMesh, TOutputMesh, TImage>
    ::GenerateData()
    {
      typedef typename TInputMesh::CellsContainer CellsContainer;


        OutputMeshPointer bestMesh;// = inputCellIt.Value();
        int  bestCantPointsMatch= 0;
	SampleType::Pointer m_Sample = SampleType::New();
	m_Sample->SetMeasurementVectorSize( 3 );

	typedef ImageRegionIteratorWithIndex<ImageType>               ImageIteratorType;
      	ImageIteratorType itMap(this->GetInputMap(), this->GetInputMap()->GetRequestedRegion());
      
      std::vector<InputPointType> points;
	while(!itMap.IsAtEnd())
	{
		MeasurementVectorType mv;
		bool greaterThanCero =false;
		if(itMap.Get() >0)
		{
			for(unsigned int i=0; i<3; i++)
			{
				mv[i]= itMap.GetIndex()[i];
				greaterThanCero |= mv[i]>0;
			}
			//	if(greaterThanCero)
			//		{
			m_Sample->PushBack( mv );
			InputPointType pt;
			this->GetInputMap()->TransformIndexToPhysicalPoint(itMap.GetIndex(),pt) ; 
			points.push_back(pt);
		}
		++itMap;
	}
      TreeGeneratorType::Pointer treeGenerator = TreeGeneratorType::New();
      treeGenerator->SetSample( m_Sample );
      treeGenerator->SetBucketSize( 100 ); // to check
      treeGenerator->Update();
      typename TreeType::Pointer tree = treeGenerator->GetOutput();

      /////////////          

      double bestBundleMatch =  std::numeric_limits<double>::max();
      for (InputListMeshIteratorType it = this->inputList.begin(); it != this->inputList.end();it++)
      {

        typename CellsContainer::ConstIterator cellIt = (*it)->GetCells()->Begin();
        int cantPoints = 0;
        double bundleDist = 0;
        for(;cellIt!= (*it)->GetCells()->End(); ++cellIt)
        {
          typename TInputMesh::CellTraits::PointIdIterator  pointIdIt  = cellIt.Value()->PointIdsBegin();
          for(;pointIdIt != cellIt.Value()->PointIdsEnd();pointIdIt++)
          {
            typename TInputMesh::PointType pt;  
            (*it)->GetPoint(*pointIdIt, &pt);

            cantPoints++;
            MeasurementVectorType queryPoint;
            for (int i=0; i<3; i++)
              queryPoint[i] = pt[i];

            TreeType::InstanceIdentifierVectorType neighbors;
            //OJO que si cambia el radio, van a cambiar la cantidad de puntos por los que divido!!
            unsigned int radio = 10;
            tree->Search( queryPoint, radio, neighbors ) ;
            double bestDist =  std::numeric_limits<double>::max();
            for ( unsigned int n = 0 ; n < neighbors.size() ; n++ )        
            {	  

              InputPointType mapPoint = points[neighbors[n]]; 
              double dist = mapPoint.SquaredEuclideanDistanceTo ( pt );
              if(dist< bestDist)
              {
                bestDist = dist;
		cantPoints++;

              }
            }
            bundleDist +=bestDist;
            //      std::cout << " lalal " << std::endl;
          }
          //   std::cout << " lalal " << std::endl;
        }
        bundleDist /= (float)cantPoints;	
        if(bundleDist<bestBundleMatch)
        {
          bestMesh = (*it);
          bestBundleMatch = bundleDist;
//          std::cout << " best " << bestBundleMatch << " mesh " << bestMesh << std::endl;
        }

      }
      std::cout << " fin " <<  std::endl;
      this->GraftOutput(bestMesh);

  }
}
#endif
