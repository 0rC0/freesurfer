#ifndef _itk_MeshDemonsRegistrationFunction_txx_
#define _itk_MeshDemonsRegistrationFunction_txx_

#include "itkMeshDemonsRegistrationFunction.h"
#include "itkClosestPointMeshCorrespondencesCalculator.h"
//#include "itkMeassureMeshCorrespondencesCalculator.h"

#include "itkKdTree.h"
#include "itkKdTreeGenerator.h"
#include "itkVector.h"
#include "itkListSample.h"
//print
#include "time.h"
#include <sys/time.h>
#include "itkPolylineMeshToVTKPolyDataFilter.h"
#include "itkVectorValue.h"

#include "vtkPolyDataWriter.h"
#include <algorithm>
#include <map>
#include <sstream>
namespace itk
{

	template < class TFixedMesh,  class TMovingMesh,
		 class TFixedImage, class TMovingImage, class TDeformationField>
			 void
			 MeshDemonsRegistrationFunction <TFixedMesh, TMovingMesh, TFixedImage, TMovingImage, TDeformationField>
			 ::InitializeIteration()
			 {
				 m_Metric    = 0.0;
				 m_RMSChange = 0.0;
				 m_NumberOfPointsProcessed = 0L;

				 DeformationFieldTypePointer invDef = this->GetInverseDeformationField();
				 // warp moving points, and update inputs of correspondence calculators
				 typedef itk::WarpMeshFilter<TMovingMesh,TMovingMesh, DeformationFieldType>  MeshWarperType;
				 typedef itk::PolylineMeshToVTKPolyDataFilter<TMovingMesh> VTKConverterType;
				 //	 typedef itk::MeassureMeshCorrespondencesCalculator<TMovingMesh,TFixedMesh> MeassuresDistanceType;
				 time_t rawtime;
				 struct tm * timeinfo;

				 time ( &rawtime );
				 timeinfo = localtime ( &rawtime ); 
				 timeval curTime;
				 gettimeofday(&curTime, NULL);
				 int milli = curTime.tv_usec / 1000;

				 //				 std::cout << "currents : "<< this->GetSigma() << std::endl;
				 for (unsigned int i=0; i<m_MovingMeshVector->Size(); i++)
				 {      

					 std::cout << " i " << i << std::endl;
					 typename WarpFilterType::Pointer warper = WarpFilterType::New();
					 warper->SetInput ( m_MovingMeshVector->ElementAt (i) );
					 warper->SetDeformationField ( invDef );
					 warper->Update();

					 typename MovingMeshType::Pointer warpedMesh = warper->GetOutput();

					 CorrespondenceCalulatorPointerType cCalculator = m_CorrespondenceCalculatorVector->ElementAt (i);
					 cCalculator->SetMovingMesh ( warpedMesh );
					 /*					 if(this->GetSigma()==-1)
										 {
										 this->SetSigma(cCalculator->GetSigmaCurrents());
										 }
										 cCalculator->SetSigma(this->GetSigma());*/
					 cCalculator->SetSpacing( this->GetMovingImage()->GetSpacing()[0]);
					 //					 cCalculator->RecalculateSigma();
					 //				   cCalculator->SetUpsamplingPointsNumber( this->GetMovingImage()->GetSpacing()[2]+1);


					 //PRINT FIBERS EACH ITERATION
					 typename VTKConverterType::Pointer converter = VTKConverterType::New();
					 converter->SetInput( warpedMesh );
					 converter->Update();

					 vtkPolyDataWriter *writer = vtkPolyDataWriter::New();
					 char meshName[100];
					 char meshName2[100];
					 strftime (meshName,100,"%H%M%S",timeinfo);
					 sprintf(meshName2, "%s%d_%.2d.vtk", meshName, milli,i);
					 writer->SetFileName(meshName2);
					 writer->SetInput( converter->GetOutputPolyData() );
					 writer->Update();
					 writer->Delete();

				 }



				 // K-d tree typedefs
				 typedef VectorValue< float, 3 >                             MeasurementVectorType;
				 typedef Statistics::ListSample< MeasurementVectorType > SampleType;
				 typedef Statistics::KdTreeGenerator< SampleType >       TreeGeneratorType;
				 typedef typename TreeGeneratorType::KdTreeType          TreeType;
				 typedef typename TreeType::NearestNeighbors             NeighborsType;
				 typedef typename TreeType::KdTreeNodeType               NodeType;

				 TreeType::Pointer                m_Tree;
				 SampleType::Pointer              m_Sample;
				 std::vector<SampleType::Pointer> m_SamplesCluster;

				 double radius = 3; //this->GetSigma();//this->GetMovingImage()->GetSpacing()[2] ;
				 m_Tree = 0;
				 m_Sample = SampleType::New();
				 m_Sample->SetMeasurementVectorSize( 3 );
				 // I create a map to know which points were already added to the list (to not repeat)
				 std::map<std::string,int> pointsMap;
				 std::vector<MeasurementVectorType>  points;
//				 std::vector<MeasurementVectorType>  allPoints;

				 InterpolatorPointListType  cPositions;
				 InterpolatorVectorListType cVectors;
				 //				 InterpolatorPointListType  cMeshPositions;
				 for (unsigned int i=0; i<m_CorrespondenceCalculatorVector->Size(); i++)
				 {
					 m_CorrespondenceCalculatorVector->ElementAt (i)->Evaluate(); //Times(5,this->GetLambdaGradientDescent());
					 m_Metric += m_CorrespondenceCalculatorVector->ElementAt (i)->Distance();
					 CorrespondencePointListType  positions = m_CorrespondenceCalculatorVector->ElementAt (i)->GetOutputPositions();
					 CorrespondenceVectorListType vectors   = m_CorrespondenceCalculatorVector->ElementAt (i)->GetOutputVectors();
					 MetricListType metrics = m_CorrespondenceCalculatorVector->ElementAt (i)->GetOutputMetricValues();

					 for(unsigned int j=0; j<positions.size(); j++)
					 {
						 cPositions.push_back( positions[j]);
						 cVectors.push_back( vectors[j]);

						 MeasurementVectorType mv;
						 MeasurementVectorType value;
						 for(int x=0;x<3;x++)
						 {
							 mv[x] = positions[j][x];
							 value[x]= vectors[j][x];
						 }
						 mv.SetValue(value);

						 m_Sample->PushBack( mv );
//						 points.push_back(mv);
						 std::stringstream seed;
						 seed << mv[0] << "_"<< mv[1] << "_"<<mv[2];
						 if(pointsMap.count(seed.str())==0)
						 {
							 pointsMap[seed.str()]= 1;
							 points.push_back(mv);
						}
		                          }
				 }
				 //  m_CorrespondencePositions.push_back ( cMeshPositions );
				 //  m_CorrespondenceVectors.push_back   ( cMeshVectors );
				 /*TreeGeneratorType::Pointer treeGenerator = TreeGeneratorType::New();
				 treeGenerator->SetSample( m_Sample );
				 treeGenerator->Update();
				 typename TreeType::Pointer tree = treeGenerator->GetOutput();
				 cPositions.clear();
				 cVectors.clear();
				 for(unsigned int n=0; n<points.size();n++)
				 {


					 MeasurementVectorType queryPoint;
					 for (int i=0; i<3; i++)
						 queryPoint[i] = points[n][i]+0.0001;

					 TreeType::InstanceIdentifierVectorType neighbors;
					 tree->Search( queryPoint, radius, neighbors ) ;
					 MovingMeshVectorType vecMean; // = new MovingMeshVectorType();

					 if(neighbors.size() > 0 )
					 {
						 vecMean = points[n].GetValue(); //[0];
						 for ( unsigned int w = 0 ; w < neighbors.size() ; w++ )        
						 {	  
							 Vector<float,3>  v = points[ neighbors[w] ].GetValue();
							 for (int i=0; i<3; i++)
								 (vecMean)[i] += v[i];

						 }
						 (vecMean) /= (neighbors.size()+1);
					 }
					 else{
						 (vecMean) = points[n].GetValue();
					 }
					 MovingMeshPointType pt ;// = new MovingMeshPointType();
					 pt[0] = points[n][0];
					 pt[1] = points[n][1];
					 pt[2] = points[n][2];

					 cPositions.push_back (pt ); // for interpolation
					 cVectors.push_back   (vecMean ); // for interpolation

				 }
				*/
				 if (m_NumberOfPointsProcessed>0 )
				 {
					 m_Metric /= m_NumberOfPointsProcessed;
					 m_RMSChange /= m_NumberOfPointsProcessed;
				 }

				 std::cout << " hola   un vec to check " << cVectors[5] << " position " << cPositions[5]<<std::endl;
				 // interpolate

				 typename InterpolatorType::Pointer inter = InterpolatorType::New();

//				 float epsilon = -this->GetLambdaGradientDescent(); //2.;///this->GetMovingImage()->GetSpacing()[2];
				 FixedMeshVectorType avgVector;	
				 avgVector.Fill(0);	
				 for(unsigned int i =0; i < cVectors.size() ; i++)
				 {


					 cVectors[i] *= -this->GetLambdaGradientDescent();//   epsilon*(2* (lambdas(i,0))/ this->GetSigmaX() +  cVectors[i][0]/this->GetSigmaI()); 
					 avgVector += cVectors[i]/cVectors.size();
					 //min maxnormalization to  range [C,D]
					 float C=-1.5;
					 float D=1.5;
					 float minVector = min(min(cVectors[i][0],cVectors[i][1]),cVectors[i][2]);
					 if(max(max(cVectors[i][0],cVectors[i][1]),cVectors[i][2])>D || minVector <C)
					 {
						 for (int j=0;j<3;j++)
							 cVectors[i][j] /= (cVectors[i].GetNorm()/D );// (cVectors[i][0]-minVector)/(D-C)+C;
					 }

                                   // threashold to maximum!
					 //					 float maximum=3;
					 //					 cVectors[i][0] = (fabs(cVectors[i][0])>maximum? cVectors[i][0]/ (fabs(cVectors[i][0]))*maximum:cVectors[i][0]);
					 //					 cVectors[i][1] = (fabs(cVectors[i][1])>maximum? cVectors[i][1]/ (fabs(cVectors[i][1]))*maximum:cVectors[i][1]);
					 //					 cVectors[i][2] = (fabs(cVectors[i][2])>maximum? cVectors[i][2]/ (fabs(cVectors[i][2]))*maximum:cVectors[i][2]);

					 cPositions[i] += cVectors[i];
					 cVectors[i]*=-1;	

				 }
		
				 m_CorrespondencePositions.clear();
				 m_CorrespondencePositions.push_back ( cPositions );
				 std::cout << "average vector  " << avgVector <<  std::endl; 
				 //				 std::cout << "p  " << cPositions[0] <<" p " << cPositions[10] ;
				 std::cout << std::endl;
				 //         cVectors[i] /= cVectors[i].GetNorm();

				 //				 m_Interpolator = InterpolatorType::New();
				 m_Interpolator->SetInput   ( this->GetFixedImage() );
				 //				 m_Interpolator->SetSigma( this->GetMovingImage()->GetSpacing()[2]);
				 double sigmaInter = this->GetSigma();//*this->GetMovingImage()->GetSpacing()[2];
				 m_Interpolator->SetSigma(sigmaInter) ;
				 m_Interpolator->SetVectors ( cVectors );
				 m_Interpolator->SetPoints  ( cPositions );
				 m_Interpolator->GetOutput()->SetRequestedRegion ( this->GetDeformationField()->GetRequestedRegion() );
				 m_Interpolator->SetNumberOfThreads(8);
				 m_Interpolator->Update();
				 m_MeshForces = m_Interpolator->GetOutput();
				 m_MeshForces->DisconnectPipeline();
}


template < class TFixedMesh,  class TMovingMesh,
	 class TFixedImage, class TMovingImage, class TDeformationField>
	 typename MeshDemonsRegistrationFunction
	 <TFixedMesh, TMovingMesh, TFixedImage, TMovingImage, TDeformationField>::PixelType
	MeshDemonsRegistrationFunction <TFixedMesh, TMovingMesh, TFixedImage, TMovingImage, TDeformationField>
::ComputeUpdate(const NeighborhoodType &it,
		void *itkNotUsed (globalData),
		const FloatOffsetType &offset)
{
	const IndexType index = it.GetIndex();

	return m_MeshForces->GetPixel(index);
	//        PixelType p = m_Interpolator->InterpolateAt(index);
	//        return p;

}


template < class TFixedMesh,  class TMovingMesh,
	 class TFixedImage, class TMovingImage, class TDeformationField>
	 void
	MeshDemonsRegistrationFunction <TFixedMesh, TMovingMesh, TFixedImage, TMovingImage, TDeformationField>
::AddMeshCorrespondenceCalculator(CorrespondenceCalulatorType *calculator)
{
	unsigned int lastIndex = m_CorrespondenceCalculatorVector->Size();

	m_CorrespondenceCalculatorVector->CreateIndex ( lastIndex );
	m_CorrespondenceCalculatorVector->SetElement  ( lastIndex, calculator );
	std::cout << " index create " << lastIndex << std::endl;
	m_MovingMeshVector->CreateIndex ( lastIndex );
	m_MovingMeshVector->SetElement  ( lastIndex, calculator->GetMovingMesh() );
	std::cout <<  " elem " << calculator->GetFixedMesh() << std::endl;
}


template < class TFixedMesh,  class TMovingMesh,
	 class TFixedImage, class TMovingImage, class TDeformationField>
	 void
	 MeshDemonsRegistrationFunction <TFixedMesh, TMovingMesh, TFixedImage, TMovingImage, TDeformationField>
	 ::PrintSelf(std::ostream& os, Indent indent) const
{
	Superclass::PrintSelf (os, indent);
	os << indent << m_CorrespondenceCalculatorVector << std::endl;
}

} // end of namespace

#endif
