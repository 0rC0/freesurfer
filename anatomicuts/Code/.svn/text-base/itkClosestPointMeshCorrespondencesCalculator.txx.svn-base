#ifndef _itk_ClosestPointMeshCorrespondencesCalculator_txx
#define _itk_ClosestPointMeshCorrespondencesCalculator_txx

#include "itkClosestPointMeshCorrespondencesCalculator.h"

#include <iostream>
#include <limits>
#include <utility>
#include <algorithm>

#include "vnl/vnl_matrix.h"
#include "vnl/vnl_math.h"
#include "math.h"


namespace itk
{

  template< class TFixedMesh, class TMovingMesh >
    void
    ClosestPointMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::Evaluate ()
    {
      if (!this->GetFixedMesh() || !this->GetMovingMesh())
        itkExceptionMacro (<< "Fixed and/or moving mesh not set");

      this->m_vecP.clear();
      this->m_vecV.clear();
      this->m_metric.clear();

      typename FixedMeshType::PointsContainer *fixedPoints   = this->GetFixedMesh()->GetPoints();
      typename MovingMeshType::PointsContainer *movingPoints = this->GetMovingMesh()->GetPoints();

      typename MovingMeshType::PointsContainer::ConstIterator movingIterator = movingPoints->Begin();

      //initialize the K-d Tree
      typename FixedMeshType::PointsContainer::ConstIterator fixedIterator = fixedPoints->Begin();
      SampleType::Pointer m_Sample = SampleType::New();
      m_Sample->SetMeasurementVectorSize( 3 );
      std::vector<FixedPointType> points;
      while ( fixedIterator!=fixedPoints->End() )
      {
        MeasurementVectorType mv;
        mv[0] = fixedIterator.Value()[0];
        mv[1] = fixedIterator.Value()[1];
        mv[2] = fixedIterator.Value()[2];
        m_Sample->PushBack( mv );
        points.push_back(fixedIterator.Value());
        ++fixedIterator;
      }
//      std::cout << " sigma " << this->GetSigma();
      double radius = this->GetSigma();
      TreeGeneratorType::Pointer treeGenerator = TreeGeneratorType::New();
      treeGenerator->SetSample( m_Sample );
      treeGenerator->SetBucketSize( 100 ); // to check
      treeGenerator->Update();
      typename TreeType::Pointer tree = treeGenerator->GetOutput();

      while ( movingIterator!=movingPoints->End() )
      {
        double minDist = std::numeric_limits<double>::max();

        MovingVectorType corr;
        MovingPointType  point;
        /*      typename FixedMeshType::PointsContainer::ConstIterator fixedIterator = fixedPoints->Begin();
                while ( fixedIterator!=fixedPoints->End() )
                {

                double dist = fixedIterator.Value().SquaredEuclideanDistanceTo ( movingIterator.Value() );
         */
        MeasurementVectorType queryPoint;
        for (int i=0; i<3; i++)
          queryPoint[i] = movingIterator.Value()[i];

        TreeType::InstanceIdentifierVectorType neighbors;
        tree->Search( queryPoint, radius, neighbors ) ;

        for ( unsigned int n = 0 ; n < neighbors.size() ; n++ )        
        {	  
                     
          FixedPointType fixedPoint = points[neighbors[n]]; 
/*          for (int i=0; i<3; i++)
            fixedPoint[i] =m_Sample[n].GetNthComponent(i);
*/

          double dist = fixedPoint.SquaredEuclideanDistanceTo ( movingIterator.Value() );
          
         /* if (dist<minDist)
          {
            minDist = dist;
            point   = fixedIterator.Value();
            corr    = fixedIterator.Value() - movingIterator.Value();
            }*/
          if (dist<minDist)
          {
            minDist = dist;
            for(int i=0; i<3;i++)
            {
              point[i]   = fixedPoint[i];
              corr[i]    = fixedPoint[i] - movingIterator.Value()[i];
            }
         }
//          ++fixedIterator;
        }
        if(minDist <std::numeric_limits<double>::max())
        {
//          std::cout << " mindist " << minDist<< " " << point[0] << " "  << point[1] << " "  << point[2] <<  " " << movingIterator.Value() << std::endl;
          this->m_vecP.push_back  ( point );
          this->m_vecV.push_back  ( corr  );
          this->m_metric.push_back( minDist );
        }
        ++movingIterator;
      }
      }
    }

#endif
