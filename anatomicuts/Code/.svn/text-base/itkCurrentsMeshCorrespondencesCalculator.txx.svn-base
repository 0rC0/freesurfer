#ifndef _itk_CurrentsMeshCorrespondencesCalculator_txx
#define _itk_CurrentsMeshCorrespondencesCalculator_txx

#include "itkCurrentsMeshCorrespondencesCalculator.h"

#include <iostream>
#include <limits>
#include <utility>
#include <algorithm>

#include <fstream>
#include "vnl/vnl_matrix.h"
#include "vnl/vnl_math.h"
#include "math.h"

#include <blitz/array.h>
#include <blitz/tinyvec-et.h>
//using namespace blitz;


#include "SqDistScalarKernel.h"
#include "CurveCurr.h" 

#include "CommonFunctions.h"



namespace itk
{
  template< class TFixedMesh, class TMovingMesh > 
    CurrentsMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::CurrentsMeshCorrespondencesCalculator()
    {
      this->sigmaCurrents = -1;
      this->lastMetric = -1;

    }

  template< class TFixedMesh, class TMovingMesh >
    void
    CurrentsMeshCorrespondencesCalculator < TFixedMesh, TMovingMesh >
    ::Evaluate ()
    {
      if (!this->GetFixedMesh() || !this->GetMovingMesh())
        itkExceptionMacro (<< "Fixed and/or moving mesh not set");

      this->m_vecP.clear();
      this->m_vecV.clear();
      this->m_metric.clear();

      typename FixedMeshType::PointsContainer *fixedPoints   = this->GetFixedMesh()->GetPoints();
      typename MovingMeshType::PointsContainer *movingPoints = this->GetMovingMesh()->GetPoints();

      typename MovingMeshType::PointsContainer::ConstIterator movingIterator = movingPoints->Begin();
      typename FixedMeshType::PointsContainer::ConstIterator fixedIterator = fixedPoints->Begin();



      //Convert to ArrayPoint to bridge with CurveCurr
      typedef blitz::TinyVector<double,3> Vect;
      typedef blitz::Array<Vect,1> ArrVect;
      typedef blitz::TinyVector<double,3> Point;
      typedef blitz::Array<Point,1> ArrPoint;
      typedef blitz::TinyVector<double,3> VectPoint;
      typedef blitz::Array<Point,1> ArrVectPoint;
      typedef blitz::TinyVector<int,2> Face;
      typedef blitz::Array<Face,1> ArrFace;

      ArrPoint fp(Range(1,fixedPoints->Size())), mp(Range(1,movingPoints->Size()));
      ArrFace fIndex(Range(1,fixedPoints->Size()-1)), mIndex(Range(1,movingPoints->Size()-1));
      int i =1;
      while ( fixedIterator!=fixedPoints->End() )
      {
        fp(i)(0) = fixedIterator.Value()[0];
        fp(i)(1) = fixedIterator.Value()[1];
        fp(i)(2) = fixedIterator.Value()[2];
        ++fixedIterator;
        i++;
      }
      double maxLenght = 0;
      if(sigmaCurrents==-1)
      {i--;
        maxLenght =pow( fp(1)(0) - fp(i)(0),2);
        maxLenght =pow( fp(1)(1) - fp(i)(1),2);
        maxLenght =pow( fp(1)(2) - fp(i)(2),2);
        maxLenght = sqrt(maxLenght);
      }
      i=1; 
      while ( movingIterator!=movingPoints->End() )
      {
        mp(i)(0) = movingIterator.Value()[0];
        mp(i)(1) = movingIterator.Value()[1];
        mp(i)(2) = movingIterator.Value()[2];
        ++movingIterator;
        i++;

      }
      if(sigmaCurrents==-1)
      { 
        i--;
        double ml = 0;
        ml =pow( mp(1)(0) - mp(i)(0),2);
        ml =pow( mp(1)(1) - mp(i)(1),2);
        ml =pow( mp(1)(2) - mp(i)(2),2);
        ml = sqrt(ml);

        if(ml>maxLenght)
          maxLenght = ml;

        this->sigmaCurrents = maxLenght/4;
      }

      for(i=1;i<fixedPoints->Size();i++)
      {
        fIndex(i) = i,i+1;
        mIndex(i) = i,i+1;
      }
      this->sigmaCurrents =  this->sigma + this->GetSpacing();
      std::cout << " sigma currents " << this->GetSpacing() << " s " << this->sigma << std::endl;
//      std::cin.get();

      Kernel<Point,Vect,VectPoint> *ker = new SqDistScalarKernel<double,3,Vect>(new CauchyFunction<double>(this->sigmaCurrents));

      // create the curve/current
      CurveCurr<double,3> CurvCurr(fp,fIndex,mIndex,ker);
      // Evaluating squared current distance
      double D = CurvCurr.Eval(mp);  

      // Evaluating gradient
      ArrVectPoint Grad = CurvCurr.Gradient(mp);
      //      cout << "Grad=" << Grad << endl;


      movingIterator = movingPoints->Begin();
      fixedIterator = fixedPoints->Begin();
      for(int j=0;j<Grad.size(); j++)
      {

        //        this->m_vecP.push_back(fixedIterator->Value());
        MovingVectorType corr;
        corr[0] = -Grad(j)(0);
        corr[1] = -Grad(j)(1);
        corr[2] = -Grad(j)(2);

        MovingPointType point; 
        /*    fixedIterator = fixedPoints->Begin();
              double distance = std::numeric_limits<double>::max();
              while(fixedIterator != fixedPoints->End())
              {
              double val = (movingIterator->Value()+ corr).SquaredEuclideanDistanceTo(fixedIterator.Value());
              if(val < distance)
              {
              point = fixedIterator->Value();
              }
              ++fixedIterator;
              }
              this->m_vecP.push_back(point);
         */  
        MovingPointType p;
        p[0] =     fixedIterator->Value()[0] - corr[0];
        p[1] =     fixedIterator->Value()[1] - corr[1];
        p[2] =     fixedIterator->Value()[2] -  corr[2];

        this->m_vecP.push_back(p );
  //      this->m_vecP.push_back(movingIterator->Value() - corr);
        //        ++fixedIterator;
        ++movingIterator;
//        std::cout << "corr " << corr << std::endl;
        this->m_vecV.push_back(corr);
        /*        double dist;
                  for(int k =0; k<3;k++)
                  {
                  dist =pow( (fp(j)(k)-Grad(j)(k)-mp(j)(k)),2);
                  }
         */
        //   std::cout << " corr " << corr << std::endl;
        this->m_metric.push_back(D/Grad.size());
        ++fixedIterator;
      }
      /*	if(this->lastMetric != -1 && D/this->lastMetric <1.005)
                {
                this->sigmaCurrents /= 2;
                }
       */

      cout << "Eval=" << D/this->lastMetric << endl;
      this->lastMetric = D;
      /*
         if (dist<minDist)
         {
         minDist = dist;
         point   = fixedIterator.Value();
         corr    = fixedIterator.Value() - movingIterator.Value();
         }	
         ++fixedIterator;
         }
         if(minDist <std::numeric_limits<double>::max())
         {
         this->m_vecP.push_back  ( point );
         this->m_vecV.push_back  ( corr  );
         this->m_metric.push_back( minDist );
         }
         ++movingIterator;
         }
       */
      }
}

#endif
