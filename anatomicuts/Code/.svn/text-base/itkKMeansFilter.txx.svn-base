#ifndef _itk_KMeansFilter_txx
#define _itk_KMeansFilter_txx


//#include "itkCurrentsMembershipFunction.h"
#include "itkKMeansFilter.h"
#include "itkDecisionRule.h"
#include "itkVector.h"
#include "itkListSample.h"
#include "itkKdTree.h"
#include "itkWeightedCentroidKdTreeGenerator.h"
#include "itkKdTreeBasedKmeansEstimator.h"
#include "itkMinimumDecisionRule.h"
//#include "itkEuclideanDistanceMetric.h"
#include "itkDistanceToCentroidMembershipFunction.h"
#include "itkCurrentsToCentroidMembershipFunction.h"
#include "itkEuclideanToCentroidMembershipFunction.h"
#include "itkKMeansClassifierFilter.h"
#include "itkNormalVariateGenerator.h"
#include <iostream>
#include <limits>
#include <utility>
#include <algorithm>
#include "vnl/vnl_matrix.h"
#include "vnl/vnl_math.h"
#include "math.h"

#include <vnl/vnl_sparse_matrix.h>
#include <vnl/algo/vnl_sparse_symmetric_eigensystem.h>
#include <vnl/algo/vnl_symmetric_eigensystem.h>


template< class TMesh,class  TMembershipFunctionType>
	void
KMeansFilter < TMesh,TMembershipFunctionType >::Update()
{
	if (!this->GetInput())
		itkExceptionMacro (<< "Mesh not set");

	int numberOfPoints  =  this->GetInput()->GetCells()->Begin().Value()->GetNumberOfPoints();
	std::cout << " number of points " << numberOfPoints << std::endl;

	typename SampleType::Pointer sample = SampleType::New();
//	sample->SetMeasurementVectorSize(numberOfPoints);
	typename EstimatorType::ParametersType initialMeans(this->GetNumberOfClusters()*numberOfPoints);

	for(unsigned int i =0; i<this->GetInput()->GetNumberOfCells();i++)
	{
		MeasurementVectorType mv(numberOfPoints);	      
		mv.SetCell(this->GetInput(), i) ; //inputCellIt.Value());
		sample->PushBack(mv);
	}

	/**	TODO: Modify the estimator to receive MEasurementVEctors and The membershipFunction
	  typename TreeGeneratorType::Pointer treeGenerator = TreeGeneratorType::New();
	  treeGenerator->SetSample( sample );
	  treeGenerator->Update();

	  EstimatorType::Pointer estimator = EstimatorType::New();

	  estimator->SetParameters( initialMeans );
	  estimator->SetKdTree( treeGenerator->GetOutput() );
	  estimator->SetMaximumIteration( 200 );
	  estimator->SetCentroidPositionChangesThreshold(0.0);
	  estimator->StartOptimization();

	  EstimatorType::ParametersType estimatedMeans = estimator->GetParameters();
	  */
	DecisionRuleType::Pointer decisionRule = DecisionRuleType::New();
	typename ClassifierType::Pointer classifier = ClassifierType::New();
	classifier->SetNumberOfIterations(this->GetNumberOfIterations());
	classifier->SetDecisionRule(decisionRule);
	classifier->SetInput( sample );
	classifier->SetNumberOfClasses( this->GetNumberOfClusters() );

	ClassLabelVectorType   classLabelsVector; // = classLabelsObject->Get();
	for(int i =0; i<this->GetNumberOfClusters();i++)
	{
		classLabelsVector.push_back( i );
	}
	classifier->SetClassLabels(&classLabelsVector);
	classifier->SetMembershipFunctions( this->GetMembershipFunctionVector());


	std::vector<int> centroidIndices =  this->SelectCentroids(sample);	

	typename MembershipFunctionType::CentroidType origin( sample->GetMeasurementVectorSize() );
	int notSoRandomInit  = this->GetInput()->GetNumberOfCells()/this->GetNumberOfClusters()-1;
	int notSoRandomInitIndex = 0;
	for ( int i = 0 ; i < this->GetNumberOfClusters() ; i++ )
	{
		//		(*this->GetMembershipFunctionVector())[i]->SetCentroid( &sample->GetMeasurementVector(notSoRandomInitIndex));
		(*this->GetMembershipFunctionVector())[i]->SetCentroid( &sample->GetMeasurementVector(centroidIndices[i]));
		notSoRandomInitIndex += notSoRandomInit;
	}
	std::cout << " before classifier update " << std::endl;
	classifier->Update();

	std::cout << " after classifier update " << std::endl;
	const typename ClassifierType::MembershipSampleType* membershipSample = classifier->GetOutput();
	typename ClassifierType::MembershipSampleType::ConstIterator iter = membershipSample->Begin();
	std::vector<int> labels; 
	while ( iter != membershipSample->End() )
	{
		labels.push_back(iter.GetClassLabel());
		++iter;
	} 
	this->SetLabels(labels);
}

template< class TMesh,class  TMembershipFunctionType>
	std::vector<int>	
KMeansFilter < TMesh ,TMembershipFunctionType>::SelectCentroids(typename SampleType::Pointer samples)
{

	std::vector<int> indices;
	const unsigned int n = samples->Size()/5; //this->GetNumberOfClusters()*10;
	typename MembershipFunctionType::Pointer membershipFunction = MembershipFunctionType::New();
	vnl_sparse_matrix<double> ms(n,n);
	int offset = samples->Size()/n;
	// The matrix must be symmetric
	for (unsigned i=0; i<n; i++) 
	{
		for (unsigned j=0; j<n; j++) 
		{
			double val = membershipFunction->Evaluate(&samples->GetMeasurementVector(i*offset), &samples->GetMeasurementVector(j*offset));
			if(val >0)
			{
				ms(i,j) = ms(j,i) = val;
			}
		}	
	}
std::cout << " hola "<< std::endl;
	//	vnl_symmetric_eigensystem<double> ed(md);
	vnl_sparse_symmetric_eigensystem es;
	es.CalculateNPairs(ms,this->GetNumberOfClusters());

	//	TEST("vnl_sparse_symmetric_eigensystem::CalculateNPairs() succeeded",			es.CalculateNPairs(ms,nvals), 0);

	// Report 'em.
	for (unsigned i=0; i<this->GetNumberOfClusters(); i++)
	{
		vnl_vector< double > vector  = es.get_eigenvector(i);
		double min_dist = std::numeric_limits<double>::max();
		int min_index=0;

		for(int j=0;j<n;j++)
		{
			double dist = 0;
			for(int k=0;k<n;k++)
			{
				dist += pow(vector(k)- ms(j,k),2);
			}
			if(dist < min_dist)
			{ 
				min_dist = dist;
				min_index=  j*offset;
			}
		}
		std::cout << " min dist " << min_dist << std::endl;
		indices.push_back(min_index);

	}
	return indices;

}
template< class TMesh,class  TMembershipFunctionType>
	void
KMeansFilter < TMesh ,TMembershipFunctionType>::SaveClustersInMeshes(MembershipFunctionVectorType membershipFunctionsVector)
{
	int numberOfPoints  = this->GetInput()->GetCells()->Begin().Value()->GetNumberOfPoints();
	for(int i=0;i<membershipFunctionsVector.size();i++)
	{ 
		MeshPointerType om = MeshType::New();
		om->SetCellsAllocationMethod( MeshType::CellsAllocatedDynamicallyCellByCell );
		int pointIndex = 0;
		int cellIndex = 0;
		int cellIndexCentroid = -1;
		MembershipFunctionPointer memFunc = membershipFunctionsVector[i];
		for(int j=0; j< memFunc->GetChilds().size();j++)
		{

			MeasurementVectorType child = memFunc->GetChilds()[j];

			MeshCellAutoPointer line;
			line.TakeOwnership ( new PolylineCellType);
			for (int k=0; k < numberOfPoints ; k++)
			{
				typename MeshType::PointType pt;
				pt[0]= (*child.GetPoints())(k+1)(0);
				pt[1]= (*child.GetPoints())(k+1)(1);
				pt[2]= (*child.GetPoints())(k+1)(2);

				om->SetPoint (pointIndex, pt);

				line->SetPointId (k,pointIndex);

				pointIndex++;
			}
			//pointIndex++;
			om->SetCell (cellIndex, line);
			if(j == memFunc->GetCentroidIndex())
			{
				//this is the representative
				om->SetCellData(0,cellIndex);
				cellIndexCentroid = cellIndex;
			}

			cellIndex++;

		}
		//std::cout << std::endl;
		if(cellIndexCentroid != -1)
		{
			this->m_Output.push_back(om);
		}

	}


}
#endif
