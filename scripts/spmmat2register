#!/bin/csh -f

set SPMMAT2REGISTER_VER = '$Id: spmmat2register,v 1.7 2000/06/07 21:32:26 greve Exp $';

set OutStream = /dev/null;
set funcvol   = ();
set structvol = ();
set regfile = "register.dat"
set subject = ();
set monly = 0;
set target = "spm";
set frows = 256;
set fcols = 256;
set fslices = 20;
set SlcOrient = "RAS";
set Intensity = 0.3;
set CoorDef = "LAS"

if($#argv == 0) goto usage_exit;

goto parse_args;
parse_args_return:

goto check_args;
check_args_return:

set structimgfile = $structvol.img
if(! -e $structimgfile ) then
  echo "ERROR: cannot find $structimgfile "
  exit 1;
endif

set funcimgfile = $funcvol.img
if(! -e $funcimgfile ) then
  echo "ERROR: cannot find $funcimgfile "
  exit 1;
endif

set outdir = `dirname $regfile`;
mkdir -p $outdir

if($monly) then
  set TARGET = " tee  $mfile "
else
  set TARGET = "matlab -display iconic "
endif 

rm -f $regfile

#-----------------------------------------------------------------#
$TARGET > $OutStream <<EOF

  SlcOrient = '$SlcOrient';
  StructVol = '$structvol.img';
  FuncVol   = '$funcvol.img';
  CoorDef   = '$CoorDef';

  % Load in the StructSubscript to Functional mm Matrix (SPM Space) %
  Ma = spm_get_space(StructVol);

  % Get the dimensions of the structual volume %
  Sdim = spm_hread(StructVol);

  % Compute structural voxel size (SPM Space)%
  dvs = sqrt(sum(Ma(1:3,1:3).^2));

  % Compute StructSubscript to Structural mm Matrix (SPM Space) %
  Qs  = diag([dvs 1]);
  Qs(:,4) = [-(Sdim(1)+1)/2 -(Sdim(2)+1)/2 -(Sdim(2)+1)/2 1]';%'

  % Load in the FuncSubscript to Functional mm Matrix (SPM Space) %
  Qf = spm_get_space(FuncVol);

  % Load header of functional volume %
  [DIM VOX SCALE TYPE OFFSET ORIGIN DESCRIP] = spm_hread(FuncVol);

  % Compute the amount that the center of the space must be shifted %
  if(~isempty(find(ORIGIN~=0)))
    dss = ORIGIN - (DIM+1)/2;
    mv_func_origin_mm = Qf * [dss 1]'; %'
  else
    mv_func_origin_mm = [0 0 0 0]'; %'
  end
  fprintf('Shifing function origin by %g, %g, %g\n',...
          mv_func_origin_mm(1),mv_func_origin_mm(2),mv_func_origin_mm(3));
  Qf(:,4) = Qf(:,4) + mv_func_origin_mm;
  Ma(:,4) = Ma(:,4) + mv_func_origin_mm;

  % Compute functional voxel size (SPM Space)%
  dvf = sqrt(sum(Qf(1:3,1:3).^2));

  % Get the dimensions of the functional volume %
  Fdim = spm_hread(FuncVol);

  % Compute the FuncSubscript to Functional mm Matrix (MGH Space) %
  Qfp = Qf;
  Qfp(2,:) = Qf(3,:);
  Qfp(3,:) = Qf(2,:);
  Qfp = abs(Qfp);
  Qfp(1,1) = -Qfp(1,1);
  Qfp(2,4) = -Qfp(2,4);
  Qfp(3,2) = -Qfp(3,2);
  Qfp(:,4) = Qfp(:,4) -1;
  Qfp(4,4) = 1;

  % Change coordinate system definition, if needed %
  Hmm = eye(4);
  if(strcmp(CoorDef,'LAS'))
    Hmm(1,1) = -1;
  end

  % Compute the matrix for register.dat %
  Mreg = Qfp*inv(Qf)*Ma*inv(Qs)*Hmm;

  SubjName = '$subject';
  fid = fopen('$regfile','w');
  if(fid == -1)
    fprintf(1,'ERROR: could not open $regfile\n');
    error('');
    quit;
  end
  fprintf(fid,'%s\n',SubjName);
  fprintf(fid,'%8.4f\n',dvf(1));
  fprintf(fid,'%8.4f\n',dvf(3));
  fprintf(fid,'%8.4f\n',$Intensity);
  fprintf(fid,'%8.4f %8.4f %8.4f %8.4f\n',Mreg'); %'
  fclose(fid);
 
  return;
EOF
#-----------------------------------------------------------------#

if(! $monly) then
  if(! -e $regfile ) then
    echo "ERROR: $regfile not created"
    echo "  Rerun with -debug flag"
    exit 1;
  endif
endif


exit 0;
#######-------------------------------------##########

parse_args:

set cmdline = "$argv";
while( $#argv != 0 )

  set flag = $argv[1]; shift;
  
  switch($flag)

    case "-fvol":
      if ( $#argv == 0) goto arg1err;
      set funcvol = $argv[1]; shift;
      breaksw

    case "-svol":
      if ( $#argv == 0) goto arg1err;
      set structvol = $argv[1]; shift;
      breaksw

    case "-o":
      if ( $#argv == 0) goto arg1err;
      set regfile = $argv[1]; shift;
      breaksw

    case "-intensity":
      if ( $#argv == 0) goto arg1err;
      set Intensity = $argv[1]; shift;
      breaksw

    case "-subject":
    case "-s":
      if ( $#argv == 0) goto arg1err;
      set subject = $argv[1]; shift;
      breaksw

    case "-coordef":
      if ( $#argv == 0) goto arg1err;
      set CoorDef = $argv[1]; shift;
      breaksw

    case "-debug":
      set verbose = 1;
      set OutStream = /dev/stdout;
      breaksw

    case "-verbose":
      set OutStream = /dev/stdout;
      breaksw

    case "-monly":
      if ( $#argv == 0) goto arg1err;
      set mfile = $argv[1]; shift;
      set monly = 1;
      breaksw

    case "-umask":
      if ( $#argv == 0) goto arg1err;
      #echo "INFO: Setting umask to $argv[1]"
      set newumask = $argv[1]; shift;
      umask $newumask
      breaksw

    default:
      echo ERROR: Flag $flag unrecognized.
      echo $cmdline
      goto usage_exit;
      breaksw
  endsw

end
goto parse_args_return;

#----------------------------------------------------------------#
check_args:

  if($#funcvol == 0) then
    echo "ERROR: must specify a functional volume";
    exit 1;
  endif  

  if($#structvol == 0) then
    echo "ERROR: must specify a structural volume";
    exit 1;
  endif  

  if($#subject == 0) then
    echo "ERROR: must specify a subject name";
    exit 1;
  endif  

  if($CoorDef != "RAS" && $CoorDef != "LAS") then
    echo "ERROR: CoorDef $CoorDef not supported"
    exit 1;
  endif

goto check_args_return;

############--------------##################
arg1err:
  echo "ERROR: flag $flag requires one argument"
  exit 1

#----------------------------------------------------------------#
usage_exit:
  echo "\nUSAGE: \n spmmat2register "
  echo "   -svol      structural volume     (required)"
  echo "   -fvol      functional volume     (required)"
  echo "   -subject   subject name          (required)"
  echo "   -o         output register file  (register.dat)"
  echo "   -intensity intensity value for register ($Intensity)"
  echo "   -coordef   coordinate definition of structs ($CoorDef)"
  echo "   -umask     newumask"
  echo "   -monly     mfile"
  echo "   -debug     print out lots of info"
  echo "\n $SPMMAT2REGISTER_VER \n"
exit 1;
