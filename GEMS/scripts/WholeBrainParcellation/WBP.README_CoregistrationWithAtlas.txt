# In order to start the segmentation process with our mesh-based probabilistic atlases, 
# we need to bring the template associated with our atlas (which defines the image grid
# the meshes were built from, i.e., coordinates of the mesh nodes indicate where they 
# are located w.r.t. the voxels of this template) in affine alignment with the 
# to-be-segmented image. 
#
# There are two logical options for this step: (1) do a Mutual Information (MI) based
# affine registration; or (2) use the initial steps of the standard FreeSurfer pipeline
# for this purpose. 
#
# Option (1) is attractive because it doesn't assume anything about the contrast
# properties in the to-be-segmented image, but might be tricky to do robustly and
# leaves skull stripping (a real headache using T1-weighted images alone) to be a
# part of our segmentation routine. On the other hand, option (2) is attractive because
# it's probably damn robust for T1-weighted images which we're going to have anyway, 
# but then we're tied to T1-weighted only and the skull stripping is known to fail 
# occasionally.
#
# Below I describe the steps required for the two options in detail:
#
# Option 1
# ========
#
# So we're coregistering the template "mni305_masked_autoCropped.mgz", which is a manually
# skull-stripped version of the MNI305 template (used as the reference space with FreeSurfer
# and copied from there) that has been auto-cropped and padded (see script 
# coregisterAndResample.sh for details), to an image-to-be-segmented (call it "orig.mgz").
# The fact that the skull has been stripped may be problematic as the MNI brain might then
# fit the outer contour of the head rather than the brain in our image "orig.mgz". Therefore,
# let's use the original MNI305 template (distributed with FreeSurfer under the name
# "mni305.cor.mgz") instead. I played around a bit, and noticed that "mni305.cor.mgz" has
# background noise in a subregion of the image area only, the rest being zeros. Since that
# proved problematic for my registration code, I manually thresholded out all the background
# noise (using kvlThresholdImage), and then auto-cropped the result so that the background
# (i.e., all those zero-valued voxels) will not dominate the registration result. I saved
# the result of this as "mni305.cor_preprocessed.mgz". Of note, this resulting template 
# still lives in MNI305 space because its image-to-world transform has always been taken
# proper care of during processing.
# 
# Registration now goes like this:

kvlRegister mni305.cor_preprocessed.mgz orig.mgz 12 2 20 1 mni305_masked_autoCropped.mgz

# which performs a full 3D affine transformation registration (12 degrees of freedom), and
# starts by aligning the images by aligning their center of "gravity" (if voxel intensities
# function as "weights"), using default settings (20 bins and multi-resolution scheme), and
# applies the resulting transformation to the atlas template "mni305_masked_autoCropped.mgz"
# 
# This will generate two images "mni305_coregistered.mgz" and 
# "mni305_masked_autoCropped_coregistered.mgz", where the latter is the valuable 
# coregistered atlas template image to be passed on to the segmentation routine 
# (called "bounding" image there)
# 
# To make sure that the registration did something useful, you can do
#


kvlResample mni305_masked_autoCropped_coregistered.mgz orig.mgz 
kvlViewImage mni305_masked_autoCropped_coregistered_resampled.mgz orig.mgz 
 
# If you notice anything wrong with this registration, you can try to start with 6 degrees
# of freedom only in the 3-D affine registration (i.e., rigid transformation using only 
# translation and rotation without skaling or skewing), and start the fully affine
# registration with 12 degrees of freedom from there instead. You can also try another 
# registration implementation, such as the one provided by FSL (included in FreeSurfer
# I think), the FreeSurfer registration module (see Option (2) below), or anything else
# for that matter (MedINRIA might have something, Elastix is also something I've seen
# used.)
#
# UPDATE: In all the cases I tried, doing the following two-stage process (first 6, then 12 degrees
# of freedom, always worked (whereas the single-step procedure above sometimes failed on
# large >30 degrees yaw rotations):
#

kvlRegister mni305.cor_preprocessed.mgz orig.mgz 6 2 20 1 mni305_masked_autoCropped.mgz
kvlRegister mni305_coregistered.mgz orig.mgz 12 0 20 1 mni305_masked_autoCropped_coregistered.mgz

# which produces "mni305_masked_autoCropped_coregistered_coregistered.mgz" as the valuable
# template to use.
#
# To visually check this, do 

kvlResample mni305_masked_autoCropped_coregistered_coregistered.mgz orig.mgz 
kvlViewImage mni305_masked_autoCropped_coregistered_coregistered_resampled.mgz orig.mgz 





#
# Option 2:
# ========
#
# 
# 
# Look at http://surfer.nmr.mgh.harvard.edu/fswiki/ReconAllDevTable to see what processing steps
# FreeSurfer does to compute the file $subject/mri/transforms/talairach.lta - this is how far you
# should run FreeSurfer in order to get FreeSurfer's robust affine Talairach-like (MNI305) registration.
# Note that currently FreeSurfer also computes another affine transformation
# $subject/mri/transforms/talairach.xfm, but that one is never actually used other than estimating
# the intracranial cavity volume.
#
# For the parsing of the "talairach.lta" file, I'm assuming it says something like "type = 0", which
# refers to a definition in the FreeSurfer header file transform.h: "#define LINEAR_VOX_TO_VOX   0",
# meaning that the transformation is between image grid coordinates (i.e., voxel grid indices in
# one image into voxel grid indices in the other). Should this type be something else in your 
# "talairach.lta" then the commands below won't work.
#
# I'm also assuming that the transformation is on a hard-coded set of line numbers; if someone ever
# changes the format of how "talairach.lta" is written out in FreeSurfer, then you'd be in trouble
# as well.
#
# Anyway, here goes: let's assume you're in a subject's FreeSurfer "mri" directory, i..e, 
# cd $subject/mri/. Then you can get the 12 parameters of the affine transformation in a single
# line, which is then applied to the mni305.cor.mgz and, more imporantly, to 
# mni305_masked_autoCropped.mgz, as follows:
# 

transformLine=`head -n 11 transforms/talairach.lta | tail -n 3`;
command=`echo kvlApplyTransform mni305.cor.mgz "$transformLine" 1 nu.mgz mni305_masked_autoCropped.mgz`;
eval $command

# which will generate the valuable file "mni305_masked_autoCropped_transformed.mgz", which is the
# coregistered atlas template image to be passed on to the segmentation routine 
# (called "bounding" image there)
#
# If you want to make sure it worked, do

kvlResample mni305_masked_autoCropped_transformed.mgz nu.mgz 
kvlViewImage mni305_masked_autoCropped_transformed_resampled.mgz nu.mgz 

#
# NOTE: you can now use any of the following volumes created by FreeSurfer to actually perform the 
# segmentation (see http://surfer.nmr.mgh.harvard.edu/fswiki/ReconAllDevTable):
#
#   rawavg.mgz  : the basic data without any preprocessing
#   orig.mgz    : resampled to 1x1x1mm grid
#   nu.mgz      : bias field corrected with N3
# 
# These are all in coregister with one another, so any of them will work with the coregistered atlas 
# template image generate above.
#
# In addition, a masked but heavily pre-processed image "brainmask.mgz" is also created, which you'd
# be crazy not to use if you're using FreeSurfer anyway. Don't use the intensities in "brainmask.mgz"
# directly because the white matter voxel intensities have been fiddled with; rather use it to extract
# a binary mask which you can then apply to orig.mgz or nu.mgz (not to rawavg.mgz unless you resample
# the mask to the original image's voxel grid):

kvlBinaryThresholdImage brainmask.mgz 1 255
kvlMaskImage nu.mgz brainmask_thresholded.mgz 

# which gives you a nice brain stripped "nu_masked.mgz" image to segment.
#
# That's it!
#






 
