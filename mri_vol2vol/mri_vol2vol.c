/*
  Name:    mri_vol2vol
  Author:  Douglas N. Greve 
  email:   analysis-bugs@nmr.mgh.harvard.edu
  Date:    2/27/02
  Purpose: converts values in one volume to another volume
  $Id: mri_vol2vol.c,v 1.24 2006/11/02 22:50:46 greve Exp $

*/

/*
BEGINUSAGE --------------------------------------------------------------

mri_vol2vol

  --mov  movvol       : input (or output template with --inv)
  --targ targvol      : output template (or input with --inv)
  --o    outvol       : output volume

  --reg  register.dat : tkRAS-to-tkRAS matrix   (tkregister2 format)
  --fsl  register.fsl : fslRAS-to-fslRAS matrix (FSL format)
  --xfm  register.xfm : ScannerRAS-to-ScannerRAS matrix (MNI format)
  --regheader         : ScannerRAS-to-ScannerRAS matrix = identity

  --inv               : sample from targ to mov

  --tal               : map to a sub FOV of MNI305 (with --reg only)
  --talres resolution : set voxel size 1mm or 2mm (def is 1)

  --fstarg            : use orig.mgz from subject in --reg as target
  --interp interptype : interpolation trilinear or nearest (def is trilin)
  --precision precisionid : output precision (def is float)
  --kernel            : save the trilinear interpolation kernel instead

  --no-resample : do not resample, just change vox2ras matrix

  --help : go ahead, make my day
  --debug
  --version 

ENDUSAGE ---------------------------------------------------------------
*/

/*
BEGINHELP --------------------------------------------------------------

Resamples a volume into another field-of-view using various types of 
matrices (FreeSurfer, FSL, SPM, and MNI). This is meant to be used
in conjunction with tkregister2.

FLAGS AND ARGUMENTS

--mov movvol 

This volume must have the same geometry as the --mov volume passed to
tkregister2 when creating/checking the registration file. By default,
this will be the input volume that will be resampled. If --inv is
specified, then this will become the geometry template for the output
instead. 

--targ targvol 

This volume must have the same geometry as the --targ volume passed to
tkregister2 when creating/checking the registration file. By default,
this will be the volume will be the geometry template for the output.
If --inv is specified, then this becomes the input volume that will be
resampled instead. The target volume can be implicitly specified with
--tal or --fstarg. 

--reg register.dat

This simple text file contains the freesurfer registration matrix. It
is the same as the file passed to and generated by tkregister2 with
the --reg flag. If --tal or --fstarg is specified, then the subject
is obtained from the regfile. 

--fsl register.fsl

Registration matrix created with the FSL flirt program using targ as
the reference and mov as input. Note: you cannot use any of the files
from $FSLDIR/etc/standard as mov or targ. These volumes do not have
geometry information in them, and FreeSurfer and FSL will default to
different things. Same as in tkregister2.

--xfm register.xfm

MNI-style registration matrix (eg, like one created with mritotal). 
This matrix maps from mov Scanner-RAS to targ Scanner-RAS, where
'Scanner-RAS' is the vox2ras matrix as found in each file.
Same as in tkregister2.

--regheader

Create a registration matrix assuuming that the mov Scanner-RAS and
targ Scanner-RAS are the same. This is the same as using a register.xfm
with the identity matrix in it. This can be used with some SPM
registrations (which change only the matrix in the .mat file). 
Same as in tkregister2.

--inv

Invert the transform. The movvol becomes the geometry template for the
output, and the targvol becomes the input that will be resampled.

--o outvol

Output volume.  By default, this will be the movvol resmapled into the
targvol space (and so will have the same geometry as the targvol). If
--inv is specified, then this will be the targvol resmapled into the
movvol space (and so will have the same geometry as the movvol). By
default, the output volume will be float, but this can be changed
with --precision. By default, the interpolation will be done with
trilinear, but this can be changed with --interp.

--tal

Resample the movvol to talairach (ie, MNI305) space. The talairach
matrix is obtained from talairach.xfm from
SUBJECTS_DIR/subjid/transforms. subjid is read from the register.dat
file. Requires --reg. Do not specify --targ as the target volume is
implicitly set to $FREESURFER_HOME/average/mni305.cor.subfovV.mgz,
where V is either 1 (for 1mm) or 2 (for 2mm). 2mm is used by default,
but this can be changed with --talres.  mni305.cor.subfovV.mgz the
MNI305 (1mm or 2mm isotropic) volume in a reduced FOV that covers only
the brain. Reducing the FOV saves space relative to the 256^3 COR FOV.
The transformation matrix is computed as R*inv(Xtal)*inv(Rtal), where
Xtal is talairach.xfm matrix, R is the matrix in the regfile, and Rtal
maps from the talairach COR FOV to the SubFOV (mni305.cor.subfovV.reg). 
If you want to sample the targvol from talairach space into the movvol 
space, then specify --inv. SUBJECTS_DIR is read from the environment 
or can be specified with --sd. 

--fstalres resmm

Set the resolution of the output when using --fstal. By default, it
is 2 mm, but can be changed to 1.0 mm with --fstalres 1

--fstarg

Set target to orig.mgz from the subject found in register.dat
file. Requires --reg.  Same as tkregister2.

--interp method

Interpolate the output based on the given method. Legal values are:
trilin aand nearest. trilin is the default. 

--precision precisionid 

Set output precision to precisionid. Legal values are uchar, short,
int, long, and float. Default is float.

--kernel

Save the trilinear interpolation kernel at each voxel instead of the 
interpolated image.

--help 

Prints out all this information.

--gdiagno diagnostic level

Sets the diagnostic level (only good for debuggin').

--version

Print out version string and exit.


EXAMPLES:

Below are some exampls of how one might use mri_vol2vol. They are not
exhaustive of all the possible combinations of options. Typically, one
uses a template to establish the registration, then resamples data
that are in correspondence with the template.

1. If a functional volume is f.bhdr (or f.nii.gz, or f.mgh, etc), and the
subject is bert, and the registration file is register.dat, then
running the following command should show that they are in
registration:

tkregister2 --reg register.dat --mov f.nii.gz

If they are not, then fix it because nothing below is going to work. You 
can also check the registration with:

tkmedit bert orig.mgz  -overlay f.nii.gz -overlay-reg register.dat

The register.dat will look something like this
----------------- register.dat --------------------------
bert
3.125
5.000
0.150000
1.000000e+00 0.000000e+00 0.000000e+00 -2.252487e+00 
0.000000e+00 -8.902127e-01 4.555448e-01 2.342102e+00 
0.000000e+00 4.555449e-01 8.902128e-01 -2.159538e-01 
0.000000e+00 0.000000e+00 0.000000e+00 1.000000e+00 
round
----------------- register.dat --------------------------

1.A. To resample the functional into anatomical space:

mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\
   --o f-in-anat.mgh

f-in-anat.mgh will have the same size and geometry as
bert/mri/orig.mgz.  You can test the result in two ways:

  # This will show the low-res functional alighned with its resampled self
  tkregister2 --reg register.dat --mov f.nii.gz --targ f-in-anat.mgh

  # This will show the resampled functional aligned with the anatomical
  tkregister2 --mov f-in-anat.mgh --targ $SUBJECTS_DIR/bert/mri/orig.mgz \\
     --regheader --reg /tmp/reg

1.B. To resample the anatomical into the functional space. This is
basically the same command line as 1.A, but --inv has been included
and the name of the output is changed.

mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\
  --o anat-in-func.mgh --inv

anat-in-func.mgh will be the same size and geometry as f.nii.gz.
You can test the result in two ways:

  # This will show the low-res anat aligned with its hires self
  tkregister2 --reg register.dat --mov anat-in-func.mgh 

  # This will show the resampled anat aligned with the functional
  tkregister2 --mov anat-in-func.mgh --targ f.nii.gz \\
     --regheader --reg /tmp/reg

1.C Map functional to anatomical without resampling. Rather, change
the vox2ras (sform/qform) matrix. This is the same cmd line as 1.A,
but --no-resample as been added.

mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\
   --o f.new.vox2ras.nii.gz --no-resample

f.new.vox2ras.nii.gz will have the same dimension and voxel size 
as f.nii.gz, but its vox2ras (sform/qform) matrix will have changed.
You can check the registration in two ways:

  # The registration is created implicitly from the vox2ras matrix
  # (that is what --regheader does). There's no need to specify 
  # and input registration
  tkregister2 --mov f.new.vox2ras.nii.gz --s bert --regheader --reg /tmp/reg

  # Display the functional as an overlay in tkmedit (no registration
  # needed).
  tkmedit bert orig.mgz -overlay f.new.vox2ras.nii.gz

1.D Map a binary mask in functional space to anatomical space. This is
basically the same cmd line as 1.A, but --interp nearest has been
added so that it does not try to interpolate the mask (ie, it will
still be binary after resampling):

mri_vol2vol --reg register.dat --mov mask.nii.gz --fstarg \\
   --o mask-in-anat.mgh --interp nearest

2. Map functional to/from talairach (MNI305) space. This uses a
two-stage registration: func-to-anat (register.dat) and
anat-to-talairach (talairach.xfm).

Make sure that sure the func-to-anat reg is correct as was done in
Example 1. Next, make sure that the anat-to-tal is correct with:

tkregister2 --s bert --fstal

2.A Map functional to talairach (MNI305) space with 2mm isotropic
resolution. This is very similar to 1.A with the addition of --tal
and --talres 2.

mri_vol2vol --mov f.nii.gz --reg register.dat \\
     --o f-in-tal.2mm.mgh --tal --talres 2

f-in-tal.2mm.mgh will be 2mm isotropic with the same geometry as
$FREESURFER_HOME/average/mni305.cor.subfov2.mgz. This command will
also create f-in-tal.2mm.mgh.reg, which will register the volume with
any average MNI305 FreeSurfer subject (fsaverage is used by default).
The resampling can be checked with:

  # This will show the functional with the fsaverage anatomical
  tkregister2 --mov f-in-tal.2mm.mgh --reg f-in-tal.2mm.mgh.reg

2.B Map functional to talairach (MNI305) space with 1mm isotropic
resolution. Same as 2.A but use --talres 1.

mri_vol2vol --mov f.nii.gz --reg register.dat \\
     --o f-in-tal.1mm.mgh --tal --talres 1

f-in-tal.1mm.mgh will take up 8 times as much space as f-in-tal.2mm.mgh

3. Apply an MNI transform to data by resampling the anatomical orig.mgz 
into talairach space using bert/mri/transforms/talairach.xfm:

First, check that the talairach.xfm is correct (this is basically the same
thing as 'tkregister2 --s bert --fstal' in Example 2:

 cd bert/mri
 tkregister2 --targ orig.mgz \\
     --mov $FREESURFER_HOME/average/mni305.cor.mgz \\
     --xfm transforms/talairach.xfm --reg /tmp/reg

 Now resample (note the --inv):
 mri_vol2vol --targ orig.mgz \\
     --mov $FREESURFER_HOME/average/mni305.cor.mgz \\
     --xfm transforms/talairach.xfm --inv \\
     --o orig-in-mni305.mgz

 Now test the resampling:
 tkregister2 --mov orig-in-mni305.mgz \\
    --targ $FREESURFER_HOME/average/mni305.cor.mgz \\
    --reg /tmp/reg --regheader


FORMATS

Data file format can be specified implicitly (through the path name)
or explicitly. All formats accepted by mri_convert can be used. 

BUGS

sinc interpolation is broken except for maybe COR to COR.


BUG REPORTING

Report bugs to analysis-bugs@nmr.mgh.harvard.edu. Include the following 
formatted as a list as follows: (1) command-line, (2) directory where
the program was run (for those in the MGH-NMR Center), (3) version, 
(4) text output, (5) description of the problem.

SEE ALSO 

mri_convert, tkregister2


ENDHELP --------------------------------------------------------------

*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <string.h>

#include "macros.h"
#include "error.h"
#include "diag.h"
#include "proto.h"

#include "matrix.h"
#include "mri.h"
#include "version.h"
#include "mri2.h"
#include "mri_identify.h"
#include "MRIio_old.h"
#include "registerio.h"
#include "resample.h"
#include "gca.h"
#include "gcamorph.h"
#include "fio.h"

#ifdef X
#undef X
#endif

// For some reason, this does not seemed to be defined in math.h
double round(double x);

static int  parse_commandline(int argc, char **argv);
static void check_options(void);
static void print_usage(void) ;
static void usage_exit(void);
static void print_help(void) ;
static void print_version(void) ;
static void argnerr(char *option, int n);
static void dump_options(FILE *fp);
static int  singledash(char *flag);
static int isflag(char *flag);
static int nth_is_arg(int nargc, char **argv, int nth);
#include "tags.h"
static int istringnmatch(char *str1, char *str2, int n);
static MATRIX *LoadRtal(int talres);
MATRIX *LoadRfsl(char *fname);

int main(int argc, char *argv[]) ;

static char vcid[] = "$Id: mri_vol2vol.c,v 1.24 2006/11/02 22:50:46 greve Exp $";
char *Progname = NULL;

int debug = 0, gdiagno = -1;

char *movvolfile=NULL;
char *targvolfile=NULL;
int  fstarg = 0;
char *outvolfile=NULL;
char *regfile=NULL;
char *xfmfile=NULL;
char *fslregfile=NULL;
char *tempvolfile=NULL;
int  invert=0;
int  fstal=0;
int  fstalres = 2; // Can only be 1 or 2
char *precision = "float";
int   precisioncode = MRI_FLOAT;
char *interpmethod = "trilinear";
int   interpcode = 0;
int   sinchw;
int   regheader=0;
int   noresample=0;

MRI *mov, *targ, *out;
MRI *in, *template;
MRI *tmpmri;

MATRIX *R, *invR, *XFM;
MATRIX *vox2vox, *vox2ras;
MATRIX *Xtal,*invXtal,*Rtal,*invRtal;
MATRIX *Tin, *invTin, *Sin, *invSin;
MATRIX *Ttemp, *invTtemp, *Stemp, *invStemp;
MATRIX *Rfsl;

char *FSH=NULL;
char *SUBJECTS_DIR=NULL;
char *talxfmfile = "talairach.xfm";

char *talsubject = NULL;
char *subject = NULL;
char *subject_outreg = NULL;

int dont_irescale = 1;
float minrescale = 0.0, maxrescale = 255.0;

float ipr, bpr, intensity;
int float2int,err, nargs;
int DoKernel=0;

char tmpstr[2000];

int DoMorph = 0;
TRANSFORM *Rtransform;  //types : M3D, M3Z, LTA, FSLMAT, DAT, OCT(TA), XFM
GCAM      *gcam;
char gcamfile[1000];

/*---------------------------------------------------------------*/
int main(int argc, char **argv)
{
  char regfile[1000];
  char cmdline[CMD_LINE_LEN] ;

  make_cmd_version_string(argc, argv, 
			  "$Id: mri_vol2vol.c,v 1.24 2006/11/02 22:50:46 greve Exp $", 
			  "$Name:  $", cmdline);

  /* rkt: check for and handle version tag */
  nargs = handle_version_option(argc, argv, 
				"$Id: mri_vol2vol.c,v 1.24 2006/11/02 22:50:46 greve Exp $",
				"$Name:  $");
  if(nargs && argc - nargs == 1) exit (0);

  Progname = argv[0] ;
  argc --;
  argv++;
  ErrorInit(NULL, NULL, NULL) ;
  DiagInit(NULL, NULL, NULL) ;

  FSH = getenv("FREESURFER_HOME");
  if(FSH==NULL){
    printf("ERROR: FREESURFER_HOME undefined.\n");
    exit(1);
  }
  if(argc == 0) usage_exit();

  parse_commandline(argc, argv);
  if(gdiagno > -1) Gdiag_no = gdiagno;
  check_options();
  dump_options(stdout);

  /*-----------------------------------------------------*/
  if(fstal){
    // Recompute R for converting to/from talairach space
    // and set the target volume file
    printf("Compute R for talairach space\n");
    Xtal = DevolveXFM(subject, NULL, NULL);
    invXtal = MatrixInverse(Xtal,NULL);
    if(Xtal == NULL) exit(1);
    if(fstalres > 0){
      Rtal = LoadRtal(fstalres);
      sprintf(tmpstr,"%s/average/mni305.cor.subfov%d.mgz",FSH,fstalres);
      targvolfile = strcpyalloc(tmpstr);
    }
    else {
      Rtal = MatrixIdentity(4,NULL);
      sprintf(tmpstr,"%s/average/mni305.cor.mgz",FSH);
      targvolfile = strcpyalloc(tmpstr);
    }
    invRtal = MatrixInverse(Rtal,NULL);
    if(Gdiag_no > 0){
      printf("matrix from regfile ---------------------- \n");
      MatrixPrint(stdout,R);
      printf("Xtal ---------------------- \n");
      MatrixPrint(stdout,Xtal);
      printf("Rtal ---------------------- \n");
      MatrixPrint(stdout,Rtal);
    }
    // Recompute: R = R*inv(Xtal)*inv(Rtal)
    R = MatrixMultiply(R,invXtal,R); 
    R = MatrixMultiply(R,invRtal,R); 
  }

  if(!invert){
    mov = MRIread(movvolfile);
    if(mov == NULL) exit(1);
    targ = MRIreadHeader(targvolfile,MRI_VOLUME_TYPE_UNKNOWN);
    if(targ == NULL) exit(1);
    in = mov;
    template = targ;
    tempvolfile = targvolfile;
  }
  else{
    mov = MRIreadHeader(movvolfile,MRI_VOLUME_TYPE_UNKNOWN);
    if(mov == NULL) exit(1);
    targ = MRIread(targvolfile);
    if(targ == NULL) exit(1);
    in = targ;
    template = mov;
    tempvolfile = movvolfile;
  }

  if(regheader){
    printf("Computing registration based on scanner-to-scanner\n");
    R = MRItkRegMtx(targ,mov,XFM);
  }

  if(fslregfile) {
    printf("Computing registration based on fsl registration\n");
    R = MRIfsl2TkReg(targ, mov, Rfsl);
  }

  if(invert){
    printf("Inverting registration\n");
    R = MatrixInverse(R,NULL);
  }
  invR = MatrixInverse(R,NULL);

  printf("\n");
  printf("Final tkRAS-to-tkRAS Matrix is:\n");
  MatrixPrint(stdout,R);
  printf("\n");

  // Vox-to-tkRAS Matrices
  Tin      = MRIxfmCRS2XYZtkreg(in); 
  invTin   = MatrixInverse(Tin,NULL);
  Ttemp    = MRIxfmCRS2XYZtkreg(template); 
  invTtemp = MatrixInverse(Ttemp,NULL);

  // Vox-to-ScannerRAS Matrices
  Sin      = MRIxfmCRS2XYZ(in,0); 
  invSin   = MatrixInverse(Sin,NULL);
  Stemp    = MRIxfmCRS2XYZ(template,0); 
  invStemp = MatrixInverse(Stemp,NULL);

  if(noresample){
    printf("Not resampling, only changing vox2ras matrix\n");
    // Compte new vox2ras instead of resampling
    // vox2ras = Stemp * invTtemp * invR * Tin
    vox2ras = MatrixMultiply(Stemp,invTtemp,NULL);
    MatrixMultiply(vox2ras,invR,vox2ras);
    MatrixMultiply(vox2ras,Tin,vox2ras);
    MRIsetVoxelToRasXform(in,vox2ras);
    MRIwrite(in,outvolfile);
    printf("To check registration, run:\n");
    printf("\n");
    printf("  tkregister2 --mov %s --targ %s --regheader --reg /tmp/reg \n",
	   outvolfile,tempvolfile);
    printf("\n");
    printf("mri_vol2vol done\n");
    return(0);
  }

  // Only gets here if resampling
  // vox2vox converts a template vox to input vox
  // vox2vox = invTin * R * Ttemp
  vox2vox = MatrixMultiply(invTin,R,NULL);
  MatrixMultiply(vox2vox,Ttemp,vox2vox);

  printf("\n");
  printf("Vox2Vox Matrix is:\n");
  MatrixPrint(stdout,vox2vox);
  printf("\n");

  // Allocate the output
  template->type = precisioncode;
  if(!DoMorph){
    if(!DoKernel){
      out = MRIcloneBySpace(template,-1,in->nframes);
      printf("Resampling\n");
      MRIvol2Vol(in,out,vox2vox,interpcode,sinchw);
    } else {
      out = MRIcloneBySpace(template,MRI_FLOAT,8);
      printf("Computing Trilinear Kernel\n");
      MRIvol2VolTLKernel(in,out,vox2vox);
    }
  } else {
    Rtransform = (TRANSFORM *)calloc(sizeof(TRANSFORM),1);
    Rtransform->xform = (void *)TransformRegDat2LTA(template, mov, R);

    printf("Reading gcam\n");
    sprintf(gcamfile,"%s/%s/mri/transforms/talairach.m3z",SUBJECTS_DIR,subject);
    gcam = GCAMread(gcamfile);
    if(gcam == NULL) exit(1);

    printf("Applying reg to gcam\n");
    GCAMapplyTransform(gcam, Rtransform);  //voxel2voxel

    printf("Applying morph to input\n");
    out = GCAMmorphToAtlas(in, gcam, NULL, -1);
  }
  
  MRIwrite(out,outvolfile);

  sprintf(regfile,"%s.reg",outvolfile);
  printf("INFO: writing registration matrix to %s\n",regfile);
  if(fstal) {
    R = Rtal;
    subject_outreg = "fsaverage";
  }
  else{
    R = MatrixIdentity(4,NULL);
    if(subject != NULL) subject_outreg = subject;
    else                subject_outreg = "subject-unknown";
    printf("Output registration matrix is identity\n");
  }
  regio_write_register(regfile,subject_outreg,out->xsize,
		       out->zsize,1,R,FLT2INT_ROUND);

  printf("To check registration, run:\n");
  printf("\n");
  if(!fstal) {
    printf("  tkregister2 --mov %s --targ %s --reg %s \n",
	   outvolfile,tempvolfile,regfile);
  }  else {
    printf("  tkregister2 --s %s --surf white --reg %s --mov %s \n",
	   subject_outreg,regfile,outvolfile);
  }

  printf("\n");
  printf("mri_vol2vol done\n");

  return(0);
}


/* ------------------------------------------------------------------ */
/* ------------------------------------------------------------------ */
/* ------------------------------------------------------------------ */
static int parse_commandline(int argc, char **argv)
{
  int  nargc , nargsused;
  char **pargv, *option ;
  int err;

  if(argc < 1) usage_exit();

  nargc   = argc;
  pargv = argv;
  while(nargc > 0){

    option = pargv[0];
    if(debug) printf("%d %s\n",nargc,option);
    nargc -= 1;
    pargv += 1;

    nargsused = 0;

    if (!strcasecmp(option,      "--help"))     print_help() ;
    else if (!strcasecmp(option, "--version"))  print_version() ;
    else if (!strcasecmp(option, "--debug"))    debug = 1;
    else if (!strcasecmp(option, "--tal"))      fstal = 1;
    else if (!strcasecmp(option, "--inv"))      invert = 1;
    else if (!strcasecmp(option, "--fstarg"))   fstarg = 1;
    else if (!strcasecmp(option, "--no-resample")) noresample = 1;
    else if (!strcasecmp(option, "--regheader")) regheader = 1;
    else if (!strcasecmp(option, "--kernel"))    DoKernel = 1;
    else if (!strcasecmp(option, "--morph")){
      DoMorph = 1;
      fstarg = 1;
    }

    else if(istringnmatch(option, "--mov",0)){
      if(nargc < 1) argnerr(option,1);
      movvolfile = pargv[0]; 
      nargsused = 1;
    }
    else if(istringnmatch(option, "--targ",0)){
      if(nargc < 1) argnerr(option,1);
      targvolfile = pargv[0]; 
      nargsused = 1;
    }
    else if (istringnmatch(option, "--reg",0)){
      if(nargc < 1) argnerr(option,1);
      regfile = pargv[0]; 
      err = regio_read_register(regfile, &subject, &ipr, &bpr, 
				&intensity, &R, &float2int);
      if(err) exit(1);
      nargsused = 1;
    }
    else if(istringnmatch(option, "--fsl",0) ||
	    istringnmatch(option, "--fslreg",0)){
      if(nargc < 1) argnerr(option,1);
      fslregfile = pargv[0]; 
      Rfsl = LoadRfsl(fslregfile);
      if(Rfsl == NULL) exit(1);
      nargsused = 1;
    }
    else if (istringnmatch(option, "--xfm",0)){
      if(nargc < 1) argnerr(option,1);
      xfmfile = pargv[0]; 
      err = regio_read_mincxfm(xfmfile, &XFM, NULL);
      if(err) exit(1);
      regheader = 1;
      nargsused = 1;
    }
    else if(istringnmatch(option, "--out",0) || 
	    istringnmatch(option, "--o",0)){
      if(nargc < 1) argnerr(option,1);
      outvolfile = pargv[0]; 
      nargsused = 1;
    }
    else if (istringnmatch(option, "--talres",8)){
      if(nargc < 1) argnerr(option,1);
      sscanf(pargv[0],"%d",&fstalres); 
      if(fstalres != 1 && fstalres != 2){
	printf("ERROR: tal res %d invalid. Only use 1 or 2\n",fstalres);
	exit(1);
      }
      nargsused = 1;
    }
    else if (istringnmatch(option, "--interp",8)){
      if(nargc < 1) argnerr(option,1);
      interpmethod = pargv[0]; nargsused = 1;
      if(!strcmp(interpmethod,"sinc") && nth_is_arg(nargc, pargv, 1)){
	sscanf(pargv[1],"%d",&sinchw); 
	nargsused ++;
      }
    }
    else if (istringnmatch(option, "--precision",0)){
      if(nargc < 1) argnerr(option,1);
      precision = pargv[0]; 
      precisioncode = MRIprecisionCode(precision);
      if(precisioncode < 0){
	printf("ERROR: precision %s unrecognized\n",precision);
	printf("       legal values are uchar, short, int, long, and float\n");
	exit(1);
      }
      nargsused = 1;
    }
    else if (istringnmatch(option, "--sd",4)){
      if(nargc < 1) argnerr(option,1);
      setenv("SUBJECTS_DIR",pargv[0],1);
      nargsused = 1;
    }
    else if ( !strcmp(option, "--gdiagno") ) {
      if(nargc < 1) argnerr(option,1);
      sscanf(pargv[0],"%d",&gdiagno);
      nargsused = 1;
    }
    else if (istringnmatch(option, "--subject",0)){
      if(nargc < 1) argnerr(option,1);
      subject = pargv[0]; nargsused = 1;
    }
    else{
      fprintf(stderr,"ERROR: Option %s unknown\n",option);
      if(singledash(option))
	fprintf(stderr,"       Did you really mean -%s ?\n",option);
      exit(-1);
    }
    nargc -= nargsused;
    pargv += nargsused;
  }
  return(0);
}
/* ------------------------------------------------------ */
static void usage_exit(void)
{
  print_usage() ;
  exit(1) ;
}
/* --------------------------------------------- */
static void print_usage(void)
{
printf("\n");
printf("mri_vol2vol\n");
printf("\n");
printf("  --mov  movvol       : input (or output template with --inv)\n");
printf("  --targ targvol      : output template (or input with --inv)\n");
printf("  --o    outvol       : output volume\n");
printf("\n");
printf("  --reg  register.dat : tkRAS-to-tkRAS matrix   (tkregister2 format)\n");
printf("  --fsl  register.fsl : fslRAS-to-fslRAS matrix (FSL format)\n");
printf("  --xfm  register.xfm : ScannerRAS-to-ScannerRAS matrix (MNI format)\n");
printf("  --regheader         : ScannerRAS-to-ScannerRAS matrix = identity\n");
printf("\n");
printf("  --inv               : sample from targ to mov\n");
printf("\n");
printf("  --tal               : map to a sub FOV of MNI305 (with --reg only)\n");
printf("  --talres resolution : set voxel size 1mm or 2mm (def is 1)\n");
printf("\n");
printf("  --fstarg            : use orig.mgz from subject in --reg as target\n");
printf("  --interp interptype : interpolation trilinear or nearest (def is trilin)\n");
printf("  --precision precisionid : output precision (def is float)\n");
printf("\n");
printf("  --no-resample : do not resample, just change vox2ras matrix\n");
printf("\n");
printf("  --help : go ahead, make my day\n");
printf("  --debug\n");
printf("  --version \n");
printf("\n");
}
/* --------------------------------------------- */
static void print_help(void)
{
  print_usage() ;
  printf("\n%s\n\n",vcid);
printf("\n");
printf("Resamples a volume into another field-of-view using various types of \n");
printf("matrices (FreeSurfer, FSL, SPM, and MNI). This is meant to be used\n");
printf("in conjunction with tkregister2.\n");
printf("\n");
printf("FLAGS AND ARGUMENTS\n");
printf("\n");
printf("--mov movvol \n");
printf("\n");
printf("This volume must have the same geometry as the --mov volume passed to\n");
printf("tkregister2 when creating/checking the registration file. By default,\n");
printf("this will be the input volume that will be resampled. If --inv is\n");
printf("specified, then this will become the geometry template for the output\n");
printf("instead. \n");
printf("\n");
printf("--targ targvol \n");
printf("\n");
printf("This volume must have the same geometry as the --targ volume passed to\n");
printf("tkregister2 when creating/checking the registration file. By default,\n");
printf("this will be the volume will be the geometry template for the output.\n");
printf("If --inv is specified, then this becomes the input volume that will be\n");
printf("resampled instead. The target volume can be implicitly specified with\n");
printf("--tal or --fstarg. \n");
printf("\n");
printf("--reg register.dat\n");
printf("\n");
printf("This simple text file contains the freesurfer registration matrix. It\n");
printf("is the same as the file passed to and generated by tkregister2 with\n");
printf("the --reg flag. If --tal or --fstarg is specified, then the subject\n");
printf("is obtained from the regfile. \n");
printf("\n");
printf("--fsl register.fsl\n");
printf("\n");
printf("Registration matrix created with the FSL flirt program using targ as\n");
printf("the reference and mov as input. Note: you cannot use any of the files\n");
printf("from $FSLDIR/etc/standard as mov or targ. These volumes do not have\n");
printf("geometry information in them, and FreeSurfer and FSL will default to\n");
printf("different things. Same as in tkregister2.\n");
printf("\n");
printf("--xfm register.xfm\n");
printf("\n");
printf("MNI-style registration matrix (eg, like one created with mritotal). \n");
printf("This matrix maps from mov Scanner-RAS to targ Scanner-RAS, where\n");
printf("'Scanner-RAS' is the vox2ras matrix as found in each file.\n");
printf("Same as in tkregister2.\n");
printf("\n");
printf("--regheader\n");
printf("\n");
printf("Create a registration matrix assuuming that the mov Scanner-RAS and\n");
printf("targ Scanner-RAS are the same. This is the same as using a register.xfm\n");
printf("with the identity matrix in it. This can be used with some SPM\n");
printf("registrations (which change only the matrix in the .mat file). \n");
printf("Same as in tkregister2.\n");
printf("\n");
printf("--inv\n");
printf("\n");
printf("Invert the transform. The movvol becomes the geometry template for the\n");
printf("output, and the targvol becomes the input that will be resampled.\n");
printf("\n");
printf("--o outvol\n");
printf("\n");
printf("Output volume.  By default, this will be the movvol resmapled into the\n");
printf("targvol space (and so will have the same geometry as the targvol). If\n");
printf("--inv is specified, then this will be the targvol resmapled into the\n");
printf("movvol space (and so will have the same geometry as the movvol). By\n");
printf("default, the output volume will be float, but this can be changed\n");
printf("with --precision. By default, the interpolation will be done with\n");
printf("trilinear, but this can be changed with --interp.\n");
printf("\n");
printf("--tal\n");
printf("\n");
printf("Resample the movvol to talairach (ie, MNI305) space. The talairach\n");
printf("matrix is obtained from talairach.xfm from\n");
printf("SUBJECTS_DIR/subjid/transforms. subjid is read from the register.dat\n");
printf("file. Requires --reg. Do not specify --targ as the target volume is\n");
printf("implicitly set to $FREESURFER_HOME/average/mni305.cor.subfovV.mgz,\n");
printf("where V is either 1 (for 1mm) or 2 (for 2mm). 2mm is used by default,\n");
printf("but this can be changed with --talres.  mni305.cor.subfovV.mgz the\n");
printf("MNI305 (1mm or 2mm isotropic) volume in a reduced FOV that covers only\n");
printf("the brain. Reducing the FOV saves space relative to the 256^3 COR FOV.\n");
printf("The transformation matrix is computed as R*inv(Xtal)*inv(Rtal), where\n");
printf("Xtal is talairach.xfm matrix, R is the matrix in the regfile, and Rtal\n");
printf("maps from the talairach COR FOV to the SubFOV (mni305.cor.subfovV.reg). \n");
printf("If you want to sample the targvol from talairach space into the movvol \n");
printf("space, then specify --inv. SUBJECTS_DIR is read from the environment \n");
printf("or can be specified with --sd. \n");
printf("\n");
printf("--fstalres resmm\n");
printf("\n");
printf("Set the resolution of the output when using --fstal. By default, it\n");
printf("is 2 mm, but can be changed to 1.0 mm with --fstalres 1\n");
printf("\n");
printf("--fstarg\n");
printf("\n");
printf("Set target to orig.mgz from the subject found in register.dat\n");
printf("file. Requires --reg.  Same as tkregister2.\n");
printf("\n");
printf("--interp method\n");
printf("\n");
printf("Interpolate the output based on the given method. Legal values are:\n");
printf("trilin aand nearest. trilin is the default. \n");
printf("\n");
printf("--precision precisionid \n");
printf("\n");
printf("Set output precision to precisionid. Legal values are uchar, short,\n");
printf("int, long, and float. Default is float.\n");
printf("\n");
printf("--help \n");
printf("\n");
printf("Prints out all this information.\n");
printf("\n");
printf("--gdiagno diagnostic level\n");
printf("\n");
printf("Sets the diagnostic level (only good for debuggin').\n");
printf("\n");
printf("--version\n");
printf("\n");
printf("Print out version string and exit.\n");
printf("\n");
printf("\n");
printf("EXAMPLES:\n");
printf("\n");
printf("Below are some exampls of how one might use mri_vol2vol. They are not\n");
printf("exhaustive of all the possible combinations of options.\n");
printf("\n");
printf("1. If a functional volume is f.bhdr (or f.nii.gz, or f.mgh, etc), and the\n");
printf("subject is bert, and the registration file is register.dat, then\n");
printf("running the following command should show that they are in\n");
printf("registration:\n");
printf("\n");
printf("tkregister2 --reg register.dat --mov f.nii.gz\n");
printf("\n");
printf("If they are not, then fix it because nothing below is going to work. You \n");
printf("can also check the registration with:\n");
printf("\n");
printf("tkmedit bert orig.mgz  -overlay f.nii.gz -overlay-reg register.dat\n");
printf("\n");
printf("The register.dat will look something like this\n");
printf("----------------- register.dat --------------------------\n");
printf("bert\n");
printf("3.125\n");
printf("5.000\n");
printf("0.150000\n");
printf("1.000000e+00 0.000000e+00 0.000000e+00 -2.252487e+00 \n");
printf("0.000000e+00 -8.902127e-01 4.555448e-01 2.342102e+00 \n");
printf("0.000000e+00 4.555449e-01 8.902128e-01 -2.159538e-01 \n");
printf("0.000000e+00 0.000000e+00 0.000000e+00 1.000000e+00 \n");
printf("round\n");
printf("----------------- register.dat --------------------------\n");
printf("\n");
printf("1.A. To resample the functional into anatomical space:\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\\n");
printf("   --o f-in-anat.mgh\n");
printf("\n");
printf("f-in-anat.mgh will have the same size and geometry as\n");
printf("bert/mri/orig.mgz.  You can test the result in two ways:\n");
printf("\n");
printf("  # This will show the low-res functional alighned with its resampled self\n");
printf("  tkregister2 --reg register.dat --mov f.nii.gz --targ f-in-anat.mgh\n");
printf("\n");
printf("  # This will show the resampled functional aligned with the anatomical\n");
printf("  tkregister2 --mov f-in-anat.mgh --targ $SUBJECTS_DIR/bert/mri/orig.mgz \\\n");
printf("     --regheader --reg /tmp/reg\n");
printf("\n");
printf("1.B. To resample the anatomical into the functional space. This is\n");
printf("basically the same command line as 1.A, but --inv has been included\n");
printf("and the name of the output is changed.\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\\n");
printf("  --o anat-in-func.mgh --inv\n");
printf("\n");
printf("anat-in-func.mgh will be the same size and geometry as f.nii.gz.\n");
printf("You can test the result in two ways:\n");
printf("\n");
printf("  # This will show the low-res anat aligned with its hires self\n");
printf("  tkregister2 --reg register.dat --mov anat-in-func.mgh \n");
printf("\n");
printf("  # This will show the resampled anat aligned with the functional\n");
printf("  tkregister2 --mov anat-in-func.mgh --targ f.nii.gz \\\n");
printf("     --regheader --reg /tmp/reg\n");
printf("\n");
printf("1.C Map functional to anatomical without resampling. Rather, change\n");
printf("the vox2ras (sform/qform) matrix. This is the same cmd line as 1.A,\n");
printf("but --no-resample as been added.\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov f.nii.gz --fstarg \\\n");
printf("   --o f.new.vox2ras.nii.gz --no-resample\n");
printf("\n");
printf("f.new.vox2ras.nii.gz will have the same dimension and voxel size \n");
printf("as f.nii.gz, but its vox2ras (sform/qform) matrix will have changed.\n");
printf("You can check the registration in two ways:\n");
printf("\n");
printf("  # The registration is created implicitly from the vox2ras matrix\n");
printf("  # (that is what --regheader does). There's no need to specify \n");
printf("  # and input registration\n");
printf("  tkregister2 --mov f.new.vox2ras.nii.gz --s bert --regheader --reg /tmp/reg\n");
printf("\n");
printf("  # Display the functional as an overlay in tkmedit (no registration\n");
printf("  # needed).\n");
printf("  tkmedit bert orig.mgz -overlay f.new.vox2ras.nii.gz\n");
printf("\n");
printf("1.D Map a binary mask in functional space to anatomical space. This is\n");
printf("basically the same cmd line as 1.A, but --interp nearest has been\n");
printf("added so that it does not try to interpolate the mask (ie, it will\n");
printf("still be binary after resampling):\n");
printf("\n");
printf("mri_vol2vol --reg register.dat --mov mask.nii.gz --fstarg \\\n");
printf("   --o mask-in-anat.mgh --interp nearest\n");
printf("\n");
printf("2. Map functional to/from talairach (MNI305) space. This uses a\n");
printf("two-stage registration: func-to-anat (register.dat) and\n");
printf("anat-to-talairach (talairach.xfm).\n");
printf("\n");
printf("Make sure that sure the func-to-anat reg is correct as was done in\n");
printf("Example 1. Next, make sure that the anat-to-tal is correct with:\n");
printf("\n");
printf("tkregister2 --s bert --fstal\n");
printf("\n");
printf("2.A Map functional to talairach (MNI305) space with 2mm isotropic\n");
printf("resolution. This is very similar to 1.A with the addition of --tal\n");
printf("and --talres 2.\n");
printf("\n");
printf("mri_vol2vol --mov f.nii.gz --reg register.dat \\\n");
printf("     --o f-in-tal.2mm.mgh --tal --talres 2\n");
printf("\n");
printf("f-in-tal.2mm.mgh will be 2mm isotropic with the same geometry as\n");
printf("$FREESURFER_HOME/average/mni305.cor.subfov2.mgz. This command will\n");
printf("also create f-in-tal.2mm.mgh.reg, which will register the volume with\n");
printf("any average MNI305 FreeSurfer subject (fsaverage is used by default).\n");
printf("The resampling can be checked with:\n");
printf("\n");
printf("  # This will show the functional with the fsaverage anatomical\n");
printf("  tkregister2 --mov f-in-tal.2mm.mgh --reg f-in-tal.2mm.mgh.reg\n");
printf("\n");
printf("2.B Map functional to talairach (MNI305) space with 1mm isotropic\n");
printf("resolution. Same as 2.A but use --talres 1.\n");
printf("\n");
printf("mri_vol2vol --mov f.nii.gz --reg register.dat \\\n");
printf("     --o f-in-tal.1mm.mgh --tal --talres 1\n");
printf("\n");
printf("f-in-tal.1mm.mgh will take up 8 times as much space as f-in-tal.2mm.mgh\n");
printf("\n");
printf("3. Apply an MNI transform to data by resampling the anatomical orig.mgz \n");
printf("into talairach space using bert/mri/transforms/talairach.xfm:\n");
printf("\n");
printf("First, check that the talairach.xfm is correct (this is basically the same\n");
printf("thing as 'tkregister2 --s bert --fstal' in Example 2:\n");
printf("\n");
printf(" cd bert/mri\n");
printf(" tkregister2 --targ orig.mgz \\\n");
printf("     --mov $FREESURFER_HOME/average/mni305.cor.mgz \\\n");
printf("     --xfm transforms/talairach.xfm --reg /tmp/reg\n");
printf("\n");
printf(" Now resample (note the --inv):\n");
printf(" mri_vol2vol --targ orig.mgz \\\n");
printf("     --mov $FREESURFER_HOME/average/mni305.cor.mgz \\\n");
printf("     --xfm transforms/talairach.xfm --inv \\\n");
printf("     --o orig-in-mni305.mgz\n");
printf("\n");
printf(" Now test the resampling:\n");
printf(" tkregister2 --mov orig-in-mni305.mgz \\\n");
printf("    --targ $FREESURFER_HOME/average/mni305.cor.mgz \\\n");
printf("    --reg /tmp/reg --regheader\n");
printf("\n");
printf("\n");
printf("FORMATS\n");
printf("\n");
printf("Data file format can be specified implicitly (through the path name)\n");
printf("or explicitly. All formats accepted by mri_convert can be used. \n");
printf("\n");
printf("BUGS\n");
printf("\n");
printf("sinc interpolation is broken except for maybe COR to COR.\n");
printf("\n");
printf("\n");
printf("BUG REPORTING\n");
printf("\n");
printf("Report bugs to analysis-bugs@nmr.mgh.harvard.edu. Include the following \n");
printf("formatted as a list as follows: (1) command-line, (2) directory where\n");
printf("the program was run (for those in the MGH-NMR Center), (3) version, \n");
printf("(4) text output, (5) description of the problem.\n");
printf("\n");
printf("SEE ALSO \n");
printf("\n");
printf("mri_convert, tkregister2\n");
printf("\n");
printf("\n");
  exit(1) ;
}
/* --------------------------------------------- */
static void check_options(void)
{
  SUBJECTS_DIR = getenv("SUBJECTS_DIR");
  if(SUBJECTS_DIR==NULL){
    printf("ERROR: SUBJECTS_DIR undefined.\n");
    exit(1);
  }
  if(movvolfile == NULL){
    printf("ERROR: No mov volume supplied.\n");
    exit(1);
  }
  if(outvolfile == NULL){
    printf("ERROR: No output volume supplied.\n");
    exit(1);
  }
  if(!fstal && !fstarg && targvolfile == NULL){
    printf("ERROR: No targ volume supplied.\n");
    exit(1);
  }
  if(fstarg && targvolfile != NULL){
    printf("ERROR: Do not specify a targ volume with --fstarg.\n");
    exit(1);
  }
  if(fstal && targvolfile != NULL){
    printf("ERROR: Do not specify a targ volume with --tal.\n");
    exit(1);
  }
  if(fstal && fstarg){
    printf("ERROR: cannot specify a --tal and --fstarg.\n");
    exit(1);
  }
  if(xfmfile != NULL && regfile != NULL){
    printf("ERROR: cannot specify both --xfm and --reg.\n");
    exit(1);
  }
  if(regheader && regfile != NULL){
    printf("ERROR: cannot specify both --regheader and --reg.\n");
    exit(1);
  }
  if(fstarg && regfile == NULL){
    printf("ERROR: Need --reg with --fstarg.\n");
    exit(1);
  }
  if(fstarg){
    sprintf(tmpstr,"%s/%s/mri/orig.mgz",SUBJECTS_DIR,subject);
    if(!fio_FileExistsReadable(tmpstr))
      sprintf(tmpstr,"%s/%s/mri/orig",SUBJECTS_DIR,subject);
    targvolfile = strcpyalloc(tmpstr);
    printf("Using %s as targ volume\n",targvolfile);
  }

  interpcode = MRIinterpCode(interpmethod);
  if(interpcode < 0){
    printf("ERROR: interpolation method %s unrecognized\n",interpmethod);
    printf("       legal values are nearest, trilin, and sinc\n");
    exit(1);
  }

  return;
}
/* --------------------------------------------- */
static void dump_options(FILE *fp)
{
  fprintf(fp,"movvol %s\n",movvolfile);
  if(targvolfile)
    fprintf(fp,"targvol %s\n",targvolfile);
  fprintf(fp,"outvol %s\n",outvolfile);
  if(regfile) fprintf(fp,"regfile %s\n",regfile);
  if(xfmfile) fprintf(fp,"xfmfile %s\n",xfmfile);
  fprintf(fp,"invert %d\n",invert);
  fprintf(fp,"tal    %d\n",fstal);
  fprintf(fp,"talres %d\n",fstalres);
  fprintf(fp,"regheader %d\n",regheader);
  fprintf(fp,"noresample %d\n",noresample);
  fprintf(fp,"interp  %s (%d)\n",interpmethod,interpcode);
  if(interpcode == SAMPLE_SINC) fprintf(fp,"sinc hw  %d\n",sinchw);
  fprintf(fp,"precision  %s (%d)\n",precision,precisioncode);
  fprintf(fp,"Gdiag_no  %d\n",Gdiag_no);

  return;
}
/* --------------------------------------------- */
static void print_version(void)
{
  printf("%s\n", vcid) ;
  exit(1) ;
}
/* --------------------------------------------- */
static void argnerr(char *option, int n)
{
  if(n==1)
    fprintf(stderr,"ERROR: %s flag needs %d argument\n",option,n);
  else
    fprintf(stderr,"ERROR: %s flag needs %d arguments\n",option,n);
  exit(-1);
}
/*---------------------------------------------------------------*/
static int singledash(char *flag)
{
  int len;
  len = strlen(flag);
  if(len < 2) return(0);
  if(flag[0] == '-' && flag[1] != '-') return(1);
  return(0);
}
/*---------------------------------------------------------------*/
static int isflag(char *flag)
{
  int len;
  len = strlen(flag);
  if(len < 2) return(0);

  if(flag[0] == '-' && flag[1] == '-') return(1);
  return(0);
}
/*---------------------------------------------------------------*/
static int nth_is_arg(int nargc, char **argv, int nth)
{
  /* Checks that nth arg exists and is not a flag */
  /* nth is 0-based */

  /* check that there are enough args for nth to exist */
  if(nargc <= nth) return(0); 

  /* check whether the nth arg is a flag */
  if(isflag(argv[nth])) return(0);

  return(1);
}

/*------------------------------------------------------------
  istringnmatch() - compare the first n characters of two strings,
  return a 1 if they match (ignoring case), a zero otherwise. If
  n=0, then do a full comparison.
  ------------------------------------------------------------*/
static int istringnmatch(char *str1, char *str2, int n)
{
  if(n > 0  && ! strncasecmp(str1,str2,n)) return(1);
  if(n <= 0 && ! strcasecmp(str1,str2)) return(1);
  return(0);
}
static MATRIX *LoadRtal(int talres)
{
  char *FSH;
  char rtalfile[2000];
  float ipr, bpr, intensity;
  int float2int, err;
  MATRIX *Rtal;

  FSH = getenv("FREESURFER_HOME");
  if(FSH==NULL){
    printf("ERROR: FREESURFER_HOME undefined.\n");
    exit(1);
  }
  sprintf(rtalfile,"%s/average/mni305.cor.subfov%d.reg",FSH,talres);
  err = regio_read_register(rtalfile, &subject, &ipr, &bpr, 
			    &intensity, &Rtal, &float2int);
  if(err) exit(1);
  return(Rtal);
}
/*-----------------------------------------------------*/
MATRIX *LoadRfsl(char *fname)
{
  MATRIX *FSLRegMat;
  FILE *fp;
  int i,j,n;

  fp = fopen(fname,"r");
  if(fp == NULL){
    printf("ERROR: cannot open %s\n",fname);
    exit(1);
  }
  FSLRegMat = MatrixAlloc(4,4,MATRIX_REAL);
  for (i=0;i<4;i++){
    for (j=0;j<4;j++){
      n = fscanf(fp,"%f",&(FSLRegMat->rptr[i+1][j+1]));
      if(n != 1){
        printf("ERROR: reading %s, row %d, col %d\n",fname,i,j);
        return(NULL);
      }
    }
  }
  return(FSLRegMat);
}


