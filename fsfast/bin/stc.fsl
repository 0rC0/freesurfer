#!/bin/csh -f
# stc.fsl - front-end for FSL's slicetimer slice timing correction

set VERSION = '$Id: stc.fsl,v 1.1 2005/07/11 23:21:31 greve Exp $'
set debug = 0;
set cmdargs = ($argv);
set PrintHelp = 0;

set infunc = ();
set outfunc = ();
set SliceSeq = ();
set tmpdir = ();
set cleanup = 1;


if($#argv == 0)  goto usage_exit;
set n = `echo $argv | grep -e -help | wc -l` 
if($n != 0) then
  set PrintHelp = 1;
  goto usage_exit;
  exit 1;
endif

goto parse_args;
parse_args_return:

goto check_params;
check_params_return:


set outdir = `dirname $outfunc`;
if($#tmpdir == 0)  set tmpdir = $outdir/tmp.$$

if($tmpdir == $outdir && $cleanup) then
  echo "ERROR: tmpdir and outdir are the same ($tmpdir)"
  echo "  If you really want to do this, run with --nocleanup"
  exit 1;
endif

mkdir -p $outdir
mkdir -p $tmpdir

set LF = $outfunc.log
if(-e $LF) mv $LF $LF.bak

date | tee -a $LF
pwd  | tee -a $LF
echo $0  | tee -a $LF
echo $cmdargs | tee -a $LF
echo $VERSION | tee -a $LF
hostname  | tee -a $LF



# Get number of input slices
set tmpfile = $tmpdir/nslices.dat
set cmd = ($DEV/mri_info/mri_info --nslices --o $tmpfile $infunc);
pwd |& tee -a $LF
echo $cmd  |& tee -a $LF
$cmd  |& tee -a $LF
if($status) exit 1;
set nslices = `cat $tmpfile`;
echo "nslices =  $nslices" |& tee -a $LF

set isodd = `echo "$nslices%2" | bc`;
echo "isodd = $isodd" |& tee -a $LF

if($SliceSeq == siemens) then
  if($isodd)   set SliceSeq = odd
  if(! $isodd) set SliceSeq = even
  echo "Changing siemens slice seq to $SliceSeq"
endif

# slice acq order file
set saof = $tmpdir/saof.dat 
rm -f $saof

# Construct the slice sequence
switch($SliceSeq)
  case "odd":
    @ nthslice = 1
    while($nthslice <= $nslices)
      echo $nthslice >> $saof
      @ nthslice = $nthslice + 2;
    end
    @ nthslice = 2
    while($nthslice <= $nslices)
      echo $nthslice >> $saof
      @ nthslice = $nthslice + 2;
    end
    breaksw
  case "even":
    @ nthslice = 2
    while($nthslice <= $nslices)
      echo $nthslice >> $saof
      @ nthslice = $nthslice + 2;
    end
    @ nthslice = 1
    while($nthslice <= $nslices)
      echo $nthslice >> $saof
      @ nthslice = $nthslice + 2;
    end
    breaksw
  case "up":
    @ nthslice = 1
    while($nthslice <= $nslices)
      echo $nthslice >> $saof
      @ nthslice = $nthslice + 1;
    end
    breaksw
  case "down":
    @ nthslice = $nslices
    while($nthslice > 0)
      echo $nthslice >> $saof
      @ nthslice = $nthslice - 1;
    end
    breaksw
endsw

echo "---------- Slice Sequence ---------------" | tee -a $LF
cat $saof | tee -a $LF
echo "-----------------------------------------" | tee -a $LF

# Convert the input to analyze
set intmp = $tmpdir/in.img
set cmd = (mri_convert $infunc $intmp -ot analyze4d)
pwd |& tee -a $LF
echo $cmd  |& tee -a $LF
$cmd  |& tee -a $LF
if($status) exit 1;


# Apply slicetimer
setenv FSLOUTPUTTYPE ANALYZE
set outtmp = $tmpdir/out.img
set cmd = (slicetimer -i $intmp -o $outtmp --ocustom=$saof)
pwd |& tee -a $LF
echo $cmd  |& tee -a $LF
$cmd  |& tee -a $LF
if($status) exit 1;

if(! -e $outtmp) then
  echo "ERROR: failed to create $outtmp" |& tee -a $LF
  exit 1;
endif

set cmd = (mri_convert -it analyze4d $outtmp $outfunc)
pwd |& tee -a $LF
echo $cmd  |& tee -a $LF
$cmd  |& tee -a $LF
if($status) exit 1;

if($cleanup) rm -rf $tmpdir

echo "stc.fsl Done"    | tee -a $LF

exit 0;
###############################################


############--------------##################
parse_args:
set cmdline = "$argv";
while( $#argv != 0 )

  set flag = $argv[1]; shift;
  
  switch($flag)

    case "--i":
      if ( $#argv == 0) goto arg1err;
      set infunc = $argv[1]; shift;
      breaksw

    case "--o":
      if ( $#argv == 0) goto arg1err;
      set outfunc = $argv[1]; shift;
      breaksw

    case "--tmp":
      if ( $#argv == 0) goto arg1err;
      set tmpdir = $argv[1]; shift;
      set nocleanup = 1;
      breaksw

    case "--debug":
      set verbose = 1;
      set echo = 1;
      breaksw

    case "--odd":
      set SliceSeq = "odd"; 
      breaksw
    case "--even":
      set SliceSeq = "even"; 
      breaksw
    case "--up":
      set SliceSeq = "up"; 
      breaksw
    case "--down":
      set SliceSeq = "down"; 
      breaksw
    case "--siemens":
      set SliceSeq = "siemens"; 
      breaksw

    default:
      echo ERROR: Flag $flag unrecognized. 
      echo $cmdline
      exit 1
      breaksw
  endsw

end

goto parse_args_return;
############--------------##################

############--------------##################
check_params:
if($#infunc == 0) then
  echo "ERROR: need input functional"
  exit 1;
endif
if($#outfunc == 0) then
  echo "ERROR: need output functional"
  exit 1;
endif
if(! -e $infunc) then
  echo "ERROR: input functional $infunc does not exist"
  exit 1;
endif
if($#SliceSeq == 0) then
  echo "ERROR: must supply a slice sequence "
  exit 1;
endif
goto check_params_return;
############--------------##################

############--------------##################
arg1err:
  echo "ERROR: flag $flag requires one argument"
  exit 1
############--------------##################

############--------------##################
usage_exit:
  echo ""
  echo "USAGE: stc.fsl"
  echo ""
  echo "   --i infunc "
  echo "   --o outfunc "
  echo "   --odd  : interleaved starting on first slice"
  echo "   --even : interleaved starting on second slice"
  echo "   --up   : sequential starting on first slice"
  echo "   --down : sequential starting on last slice"
  echo "   --siemens : use siemens default slice timing" 

  echo "   --debug"
  echo "   --version        : print version and exit"
  echo "   --help           : print help and exit"
  echo ""

  if(! $PrintHelp) exit 1;

  echo $VERSION

  echo "------------------------------------------------------------"
  cat $0 | awk 'BEGIN{prt=0}{if(prt) print $0; if($1 == "BEGINHELP") prt = 1 }'

  echo "------------------------------------------------------------"

exit 1;

#---- Everything below here is printed out as part of help -----#
BEGINHELP

Slice order starts at 1.
